var t,n,e=Object.defineProperty,i=Object.getOwnPropertyNames,r=(t,n,i)=>((t,n,i)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[n]=i)(t,"symbol"!=typeof n?n+"":n,i),a=(t={"assets/index-BVT9VAtX.js"(t,n){!function(){const t=document.createElement("link").relList;if(!(t&&t.supports&&t.supports("modulepreload"))){for(const t of document.querySelectorAll('link[rel="modulepreload"]'))n(t);new MutationObserver(t=>{for(const e of t)if("childList"===e.type)for(const t of e.addedNodes)"LINK"===t.tagName&&"modulepreload"===t.rel&&n(t)}).observe(document,{childList:!0,subtree:!0})}function n(t){if(t.ep)return;t.ep=!0;const n=function(t){const n={};return t.integrity&&(n.integrity=t.integrity),t.referrerPolicy&&(n.referrerPolicy=t.referrerPolicy),"use-credentials"===t.crossOrigin?n.credentials="include":"anonymous"===t.crossOrigin?n.credentials="omit":n.credentials="same-origin",n}(t);fetch(t.href,n)}}();const e={},i=function(t,n,i){let r=Promise.resolve();if(n&&n.length>0){document.getElementsByTagName("link");const t=document.querySelector("meta[property=csp-nonce]"),i=(null==t?void 0:t.nonce)||(null==t?void 0:t.getAttribute("nonce"));r=Promise.allSettled(n.map(t=>{if((t=function(t){return"/"+t}(t))in e)return;e[t]=!0;const n=t.endsWith(".css"),r=n?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${t}"]${r}`))return;const a=document.createElement("link");return a.rel=n?"stylesheet":"modulepreload",n||(a.as="script"),a.crossOrigin="",a.href=t,i&&a.setAttribute("nonce",i),document.head.appendChild(a),n?new Promise((n,e)=>{a.addEventListener("load",n),a.addEventListener("error",()=>e(new Error(`Unable to preload CSS for ${t}`)))}):void 0}))}function a(t){const n=new Event("vite:preloadError",{cancelable:!0});if(n.payload=t,window.dispatchEvent(n),!n.defaultPrevented)throw t}return r.then(n=>{for(const t of n||[])"rejected"===t.status&&a(t.reason);return t().catch(a)})};class a{constructor(){this.app=document.getElementById("app"),this.render()}render(){this.app.insertAdjacentHTML("afterbegin",'\n            \x3c!-- 顶部导航栏 --\x3e\n            <header class="bg-white dark:bg-gray-800 shadow-md dark:shadow-gray-700/30 sticky top-0 z-50 transition-all duration-300 w-full py-2">\n                <div class="w-full container mx-auto px-4 py-1 flex items-center justify-between">\n                    <div class="flex items-center gap-2">\n                        <i class="fa fa-exchange text-primary text-2xl"></i>\n                        <h1 class="text-lg font-bold text-gray-800 dark:text-white">排序算法可视化</h1>\n                    </div>\n                    \n                    \x3c!-- 模式切换按钮 --\x3e\n                    <div class="relative flex items-center bg-gray-100 dark:bg-gray-800 p-1 rounded-full shadow-sm transition-all duration-300 ease-in-out">\n                        <button id="single-mode-btn" class="px-6 py-2 rounded-full font-medium text-sm font-medium transition-all duration-300 ease-in-out transform bg-primary text-white shadow-md hover:shadow-lg scale-105 active:scale-95 flex items-center gap-2">\n                            <i class="fa fa-single-circle-o"></i> 单算法模式\n                        </button>\n                        <button id="competition-mode-btn" class="px-6 py-2 rounded-full font-medium text-sm font-medium transition-all duration-300 ease-in-out transform bg-transparent text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 scale-105 active:scale-95 flex items-center gap-2">\n                            <i class="fa fa-trophy"></i> 竞赛模式\n                        </button>\n                    </div>\n                    \n                    \x3c!-- 主题切换按钮 --\x3e\n                    <button id="theme-toggle" class="p-2 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 transition-all duration-300 ease-in-out transform scale-105 active:scale-95">\n                        <i class="fa fa-moon-o dark:hidden"></i>\n                        <i class="fa fa-sun-o hidden dark:block"></i>\n                    </button>\n                    \n                    \x3c!-- 语言切换按钮 --\x3e\n                    <div class="relative">\n                        <button id="language-toggle" class="p-2 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 transition-all duration-300 ease-in-out transform scale-105 active:scale-95">\n                            <i class="fa fa-globe"></i>\n                        </button>\n                        \x3c!-- 语言切换菜单 --\x3e\n                        <div id="language-menu" class="absolute hidden bg-white dark:bg-gray-800 shadow-lg rounded-lg border border-gray-200 dark:border-gray-700 right-0 mt-2 z-50 min-w-[120px]">\n                            <div class="py-1">\n                                <button class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md" data-lang="zh">\n                                    <i class="fa fa-flag mr-2"></i> 中文\n                                </button>\n                                <button class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md" data-lang="en">\n                                    <i class="fa fa-flag mr-2"></i> English\n                                </button>\n                            </div>\n                        </div>\n                    </div>\n                    \n                    \x3c!-- 桌面端导航 --\x3e\n                    <nav class="hidden md:flex items-center gap-3">\n                        <a href="#visualization" class="py-2 px-3 rounded-lg text-gray-600 dark:text-gray-300 hover:bg-primary/10 hover:text-primary transition-colors text-sm">\n                            <i class="fa fa-bar-chart mr-1"></i> 排序可视化\n                        </a>\n                        <a href="#algorithm-principle" class="py-2 px-3 rounded-lg text-gray-600 dark:text-gray-300 hover:bg-primary/10 hover:text-primary transition-colors text-sm">\n                            <i class="fa fa-lightbulb-o mr-1"></i> 算法原理\n                        </a>\n                        <a href="#complexity-analysis" class="py-2 px-3 rounded-lg text-gray-600 dark:text-gray-300 hover:bg-primary/10 hover:text-primary transition-colors text-sm">\n                            <i class="fa fa-line-chart mr-1"></i> 复杂度分析\n                        </a>\n                        <a href="#application-scenarios" class="py-2 px-3 rounded-lg text-gray-600 dark:text-gray-300 hover:bg-primary/10 hover:text-primary transition-colors text-sm">\n                            <i class="fa fa-question-circle-o mr-1"></i> 适用场景\n                        </a>\n                        <a href="#code-implementation" class="py-2 px-3 rounded-lg text-gray-600 dark:text-gray-300 hover:bg-primary/10 hover:text-primary transition-colors text-sm">\n                            <i class="fa fa-code mr-1"></i> 代码实现\n                        </a>\n                        <a href="#algorithm-comparison" class="py-2 px-3 rounded-lg text-gray-600 dark:text-gray-300 hover:bg-primary/10 hover:text-primary transition-colors text-sm">\n                            <i class="fa fa-exchange mr-1"></i> 算法对比\n                        </a>\n                    </nav>\n                    \n                    \x3c!-- 移动端菜单按钮 --\x3e\n                    <button class="text-gray-600 dark:text-gray-300 hover:text-primary md:hidden" id="menu-toggle">\n                        <i class="fa fa-bars text-xl"></i>\n                    </button>\n                </div>\n                \n                \x3c!-- 移动端菜单 --\x3e\n                    <div id="mobile-menu" class="hidden md:hidden bg-white dark:bg-gray-800 border-t dark:border-gray-700">\n                        <div class="container mx-auto px-4 py-3 flex flex-col gap-3">\n                            <div class="mb-2">\n                                <label for="mobile-algorithm-selector" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">选择算法</label>\n                                <select id="mobile-algorithm-selector" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-900 dark:text-gray-100 text-sm rounded-lg focus:ring-primary focus:border-primary block p-2">\n                                    <option value="bubbleSort">冒泡排序</option>\n                                    <option value="quickSort">快速排序</option>\n                                    <option value="selectionSort">选择排序</option>\n                                    <option value="insertionSort">插入排序</option>\n                                    <option value="mergeSort">归并排序</option>\n                                    <option value="heapSort">堆排序</option>\n                                    <option value="shellSort">希尔排序</option>\n                                    <option value="countingSort">计数排序</option>\n                                    <option value="radixSort">基数排序</option>\n                                </select>\n                            </div>\n                            <a href="#visualization" class="text-gray-600 dark:text-gray-300 hover:text-primary py-2 transition-colors">排序可视化</a>\n                            <a href="#algorithm-principle" class="text-gray-600 dark:text-gray-300 hover:text-primary py-2 transition-colors">算法原理</a>\n                            <a href="#complexity-analysis" class="text-gray-600 dark:text-gray-300 hover:text-primary py-2 transition-colors">复杂度分析</a>\n                            <a href="#application-scenarios" class="text-gray-600 dark:text-gray-300 hover:text-primary py-2 transition-colors">适用场景</a>\n                            <a href="#code-implementation" class="text-gray-600 dark:text-gray-300 hover:text-primary py-2 transition-colors">代码实现</a>\n                            <a href="#algorithm-comparison" class="text-gray-600 dark:text-gray-300 hover:text-primary py-2 transition-colors">算法对比</a>\n                        </div>\n                    </div>\n            </header>\n        '),this.setupEventListeners()}setupEventListeners(){const t=document.getElementById("menu-toggle"),n=document.getElementById("mobile-menu");t&&n&&t.addEventListener("click",()=>{n.classList.toggle("hidden")});const e=document.getElementById("theme-toggle");if(e){const t=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");this.setTheme(t),e.addEventListener("click",()=>{const t="light"==(document.documentElement.classList.contains("dark")?"dark":"light")?"dark":"light";this.setTheme(t),localStorage.setItem("theme",t)})}const i=document.getElementById("language-toggle"),r=document.getElementById("language-menu");if(i&&r){const t=localStorage.getItem("language")||"zh";this.setLanguage(t),i.addEventListener("click",()=>{r.classList.toggle("hidden")}),r.querySelectorAll("button[data-lang]").forEach(t=>{t.addEventListener("click",t=>{const n=t.target.getAttribute("data-lang");this.setLanguage(n),localStorage.setItem("language",n),r.classList.add("hidden")})}),document.addEventListener("click",t=>{i.contains(t.target)||r.contains(t.target)||r.classList.add("hidden")})}}setTheme(t){"dark"===t?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")}setLanguage(t){window.languageManager?window.languageManager.setLanguage(t):(document.documentElement.setAttribute("lang",t),localStorage.setItem("language",t),document.dispatchEvent(new CustomEvent("languageChanged",{detail:{lang:t}}))),this.updateLanguageButton(t)}updateLanguageButton(t){document.getElementById("language-toggle")}}class s{constructor(){this.app=document.getElementById("app"),this.render()}render(){this.app.insertAdjacentHTML("beforeend",'\n            \x3c!-- 主内容区域 --\x3e\n            <main class="flex-1 mx-auto px-4 pt-2 pb-6 w-full">\n\n                \n                \x3c!-- 可视化区域 --\x3e\n                <section id="visualization" class="mb-12">\n                    \x3c!-- 单算法模式布局 --\x3e\n                    <div id="single-algorithm-layout" class="grid grid-cols-1 md:grid-cols-3 gap-6 transition-all duration-500 ease-in-out transform opacity-100 scale-100">\n                        \x3c!-- 排序过程可视化 - 占2列 --\x3e\n                        <div class="md:col-span-2 bg-card rounded-xl shadow-md p-5 border border-gray-100">\n                            <div class="flex justify-between items-center mb-4 pb-2 border-b border-gray-100">\n                                <h2 class="text-lg font-semibold">排序过程可视化</h2>\n                                <div>\n                                    <div class="text-sm font-medium text-primary" id="current-algorithm-display">冒泡排序</div>\n                                </div>\n                            </div>\n                            \x3c!-- 2D/3D切换按钮 --\x3e\n                            <div class="flex justify-end mb-2">\n                                <div class="inline-flex rounded-md shadow-sm" role="group">\n                                    <button type="button" id="toggle-2d" class="px-3 py-1 text-sm font-medium text-white bg-primary rounded-l-lg border border-primary hover:bg-primary/90 active:bg-primary/80 transition-all duration-200">\n                                        <i class="fa fa-square-o mr-1"></i> 2D\n                                    </button>\n                                    <button type="button" id="toggle-3d" class="px-3 py-1 text-sm font-medium text-primary bg-white rounded-r-lg border border-primary hover:bg-gray-50 active:bg-gray-100 transition-all duration-200">\n                                        <i class="fa fa-cube mr-1"></i> 3D\n                                    </button>\n                                </div>\n                            </div>\n                            \n                            <div class="relative">\n                                \x3c!-- 2D柱体可视化容器 --\x3e\n                                <div id="bars-container" class="flex items-end justify-center gap-[2px] md:gap-[4px] h-[350px] w-full p-2 md:p-4 border border-gray-200 rounded-t-lg shadow-inner bg-white">\n                                    \x3c!-- 排序柱体元素将在这里动态生成 --\x3e\n                                </div>\n                                \n                                \x3c!-- 3D可视化容器 - 默认隐藏 --\x3e\n                                <div id="bars-container-3d" class="hidden h-[350px] w-full p-2 md:p-4 border border-gray-200 rounded-t-lg shadow-inner bg-white">\n                                    \x3c!-- 3D渲染将在这里进行 --\x3e\n                                </div>\n                            </div>\n                            <div class="flex flex-wrap gap-3 mt-2 justify-center text-xs">\n                                <div class="flex items-center gap-1.5">\n                                    <div class="w-3.5 h-3.5 bg-neutral rounded-sm"></div>\n                                    <span>未排序</span>\n                                </div>\n                                <div class="flex items-center gap-1.5">\n                                    <div class="w-3.5 h-3.5 bg-comparing rounded-sm"></div>\n                                    <span>比较中</span>\n                                </div>\n                                <div class="flex items-center gap-1.5">\n                                    <div class="w-3.5 h-3.5 bg-primary rounded-sm"></div>\n                                    <span>当前选中</span>\n                                </div>\n                                <div class="flex items-center gap-1.5">\n                                    <div class="w-3.5 h-3.5 bg-purple-500 rounded-sm"></div>\n                                    <span>基准元素</span>\n                                </div>\n                                <div class="flex items-center gap-1.5">\n                                    <div class="w-3.5 h-3.5 bg-sorted rounded-sm"></div>\n                                    <span>已排序</span>\n                                </div>\n                            </div>\n                            \x3c!-- 性能指标图表和算法推荐左右分栏 --\x3e\n                            <div class="mt-4 border-t border-gray-100 pt-4 flex flex-col md:flex-row gap-4">\n                                \x3c!-- 性能指标图表 - 占50% --\x3e\n                                <div class="w-full md:w-1/2 space-y-4">\n                                    <h3 class="text-sm font-medium text-gray-700 mb-2 flex items-center">\n                                        <i class="fa fa-line-chart mr-2 text-primary"></i> 性能指标实时图表\n                                    </h3>\n                                    <div class="w-full h-32 md:h-40 bg-white rounded-lg border border-gray-200 p-2 hover:shadow-md transition-all duration-300 ease-out">\n                                        <canvas id="performance-chart"></canvas>\n                                    </div>\n                                    \n                                    \x3c!-- 统计信息：比较次数、交换次数、数组大小 横向展示 --\x3e\n                                    <div class="flex justify-around items-center pt-2 border-t border-gray-100">\n                                        <div class="flex flex-col items-center">\n                                            <span class="text-xs text-gray-500">比较次数</span>\n                                            <span class="text-xl font-bold text-primary" id="comparison-count">0</span>\n                                        </div>\n                                        <div class="flex flex-col items-center">\n                                            <span class="text-xs text-gray-500">交换次数</span>\n                                            <span class="text-xl font-bold text-primary" id="swap-count">0</span>\n                                        </div>\n                                        <div class="flex flex-col items-center">\n                                            <span class="text-xs text-gray-500">数组大小</span>\n                                            <span class="text-xl font-bold text-neutral" id="current-array-size">20</span>\n                                        </div>\n                                    </div>\n                                </div>\n                                \n                                \x3c!-- 算法推荐区域 - 占50% --\x3e\n                                <div class="w-full md:w-1/2">\n                                    <h3 class="text-sm font-medium text-gray-700 mb-2">算法推荐</h3>\n                                    <div id="algorithm-recommendation" class="bg-card p-3 rounded-lg shadow-sm border border-gray-200 overflow-auto">\n                                        <p class="text-sm text-gray-600">生成数组后，将显示适合当前数组的算法推荐</p>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 控制面板容器 - 占1列 --\x3e\n                        <div id="control-panel-container" class="md:col-span-1 h-full"></div>\n                    </div>\n                    \n                    \x3c!-- 竞赛模式布局 - 默认隐藏 --\x3e\n                    <div id="competition-layout" class="hidden transition-all duration-500 ease-in-out transform opacity-0 scale-95">\n                        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">\n                            \x3c!-- 竞赛可视化区域 - 占2列 --\x3e\n                            <div class="md:col-span-2 bg-card rounded-xl shadow-md p-5 border border-gray-100">\n                                <div class="flex justify-between items-center mb-4 pb-2 border-b border-gray-100">\n                                    <h2 class="text-lg font-semibold">排序过程可视化</h2>\n                                    <div>\n                                        <div class="text-sm font-medium text-primary">竞赛模式</div>\n                                    </div>\n                                </div>\n                                \n                                \x3c!-- 2算法布局 - 横向并排 --\x3e\n                                <div id="competition-layout-2" class="grid grid-cols-1 sm:grid-cols-2 gap-6 mb-6">\n                                    \x3c!-- 算法1容器 --\x3e\n                                    <div class="algorithm-container bg-gray-50 rounded-xl shadow-sm p-4 border border-gray-200 hover:shadow-md transition-all duration-300 ease-out">\n                                        <div class="flex items-center justify-between mb-3 pb-2 border-b border-primary/20">\n                                            <div class="flex items-center gap-2">\n                                                <h3 class="text-base font-semibold text-primary">算法1:</h3>\n                                                <select id="algorithm-select-0" class="bg-white border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-primary focus:border-primary block p-1.5 transition-all duration-200 hover:border-primary/50 w-36">\n                                                    <option value="bubble">冒泡排序</option>\n                                                    <option value="selection">选择排序</option>\n                                                    <option value="insertion">插入排序</option>\n                                                    <option value="quick">快速排序</option>\n                                                    <option value="merge">归并排序</option>\n                                                    <option value="heap">堆排序</option>\n                                                    <option value="shell">希尔排序</option>\n                                                    <option value="counting">计数排序</option>\n                                                    <option value="radix">基数排序</option>\n                                                </select>\n                                            </div>\n                                            <div class="text-xs font-medium bg-primary/10 text-primary px-2 py-1 rounded-full" id="algorithm-status-0">就绪</div>\n                                        </div>\n                                        <div class="relative">\n                                            <div class="flex items-end justify-center gap-[2px] md:gap-[4px] h-[200px] sm:h-[250px] w-full p-2 md:p-4 border border-gray-200 rounded-t-lg shadow-inner bg-white" id="bars-container-0">\n                                                \x3c!-- 排序柱体元素将在这里动态生成 --\x3e\n                                            </div>\n                                        </div>\n                                        <div class="flex justify-around items-center mt-3 pt-3 border-t border-gray-200 text-sm">\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">比较</span>\n                                                <span class="text-base sm:text-lg font-bold text-primary" id="comparison-count-0">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">交换</span>\n                                                <span class="text-base sm:text-lg font-bold text-primary" id="swap-count-0">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">时间</span>\n                                                <span class="text-base sm:text-lg font-bold text-primary" id="execution-time-0">0ms</span>\n                                            </div>\n                                        </div>\n                                    </div>\n                                    \n                                    \x3c!-- 算法2容器 --\x3e\n                                    <div class="algorithm-container bg-gray-50 rounded-xl shadow-sm p-4 border border-gray-200 hover:shadow-md transition-all duration-300 ease-out">\n                                        <div class="flex items-center justify-between mb-3 pb-2 border-b border-orange-500/20">\n                                            <div class="flex items-center gap-2">\n                                                <h3 class="text-base font-semibold text-orange-500">算法2:</h3>\n                                                <select id="algorithm-select-1" class="bg-white border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-primary focus:border-primary block p-1.5 transition-all duration-200 hover:border-primary/50 w-36">\n                                                    <option value="bubble">冒泡排序</option>\n                                                    <option value="selection">选择排序</option>\n                                                    <option value="insertion">插入排序</option>\n                                                    <option value="quick">快速排序</option>\n                                                    <option value="merge">归并排序</option>\n                                                    <option value="heap">堆排序</option>\n                                                    <option value="shell">希尔排序</option>\n                                                    <option value="counting">计数排序</option>\n                                                    <option value="radix">基数排序</option>\n                                                </select>\n                                            </div>\n                                            <div class="text-xs font-medium bg-orange-500/10 text-orange-500 px-2 py-1 rounded-full" id="algorithm-status-1">就绪</div>\n                                        </div>\n                                        <div class="relative">\n                                            <div class="flex items-end justify-center gap-[2px] md:gap-[4px] h-[200px] sm:h-[250px] w-full p-2 md:p-4 border border-gray-200 rounded-t-lg shadow-inner bg-white" id="bars-container-1">\n                                                \x3c!-- 排序柱体元素将在这里动态生成 --\x3e\n                                            </div>\n                                        </div>\n                                        <div class="flex justify-around items-center mt-3 pt-3 border-t border-gray-200 text-sm">\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">比较</span>\n                                                <span class="text-base sm:text-lg font-bold text-orange-500" id="comparison-count-1">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">交换</span>\n                                                <span class="text-base sm:text-lg font-bold text-orange-500" id="swap-count-1">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">时间</span>\n                                                <span class="text-base sm:text-lg font-bold text-orange-500" id="execution-time-1">0ms</span>\n                                            </div>\n                                        </div>\n                                    </div>\n                                </div>\n\n                                \x3c!-- 3算法布局 - 纵向单列 --\x3e\n                                <div id="competition-layout-3" class="grid grid-cols-1 gap-6 mb-6 hidden">\n                                    \x3c!-- 算法1容器 --\x3e\n                                    <div class="algorithm-container bg-gray-50 rounded-xl shadow-sm p-4 border border-gray-200 hover:shadow-md transition-all duration-300 ease-out">\n                                        <div class="flex justify-between items-center mb-3 pb-2 border-b border-primary/20">\n                                            <h3 class="text-base font-semibold text-primary">算法1: <span id="algorithm-name-0">冒泡排序</span></h3>\n                                            <div class="text-xs font-medium bg-primary/10 text-primary px-2 py-1 rounded-full" id="algorithm-status-0">就绪</div>\n                                        </div>\n                                        <div class="relative">\n                                            <div class="flex items-end justify-center gap-[2px] md:gap-[4px] h-[180px] sm:h-[200px] w-full p-2 md:p-4 border border-gray-200 rounded-t-lg shadow-inner bg-white" id="bars-container-0">\n                                                \x3c!-- 排序柱体元素将在这里动态生成 --\x3e\n                                            </div>\n                                        </div>\n                                        <div class="flex justify-around items-center mt-3 pt-3 border-t border-gray-200 text-sm">\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">比较</span>\n                                                <span class="text-base sm:text-lg font-bold text-primary" id="comparison-count-0">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">交换</span>\n                                                <span class="text-base sm:text-lg font-bold text-primary" id="swap-count-0">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">时间</span>\n                                                <span class="text-base sm:text-lg font-bold text-primary" id="execution-time-0">0ms</span>\n                                            </div>\n                                        </div>\n                                    </div>\n                                    \n                                    \x3c!-- 算法2容器 --\x3e\n                                    <div class="algorithm-container bg-gray-50 rounded-xl shadow-sm p-4 border border-gray-200 hover:shadow-md transition-all duration-300 ease-out">\n                                        <div class="flex justify-between items-center mb-3 pb-2 border-b border-orange-500/20">\n                                            <h3 class="text-base font-semibold text-orange-500">算法2: <span id="algorithm-name-1">选择排序</span></h3>\n                                            <div class="text-xs font-medium bg-orange-500/10 text-orange-500 px-2 py-1 rounded-full" id="algorithm-status-1">就绪</div>\n                                        </div>\n                                        <div class="relative">\n                                            <div class="flex items-end justify-center gap-[2px] md:gap-[4px] h-[180px] sm:h-[200px] w-full p-2 md:p-4 border border-gray-200 rounded-t-lg shadow-inner bg-white" id="bars-container-1">\n                                                \x3c!-- 排序柱体元素将在这里动态生成 --\x3e\n                                            </div>\n                                        </div>\n                                        <div class="flex justify-around items-center mt-3 pt-3 border-t border-gray-200 text-sm">\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">比较</span>\n                                                <span class="text-base sm:text-lg font-bold text-orange-500" id="comparison-count-1">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">交换</span>\n                                                <span class="text-base sm:text-lg font-bold text-orange-500" id="swap-count-1">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">时间</span>\n                                                <span class="text-base sm:text-lg font-bold text-orange-500" id="execution-time-1">0ms</span>\n                                            </div>\n                                        </div>\n                                    </div>\n                                </div>\n                                \n                                \x3c!-- 4算法布局 - 两上两下网格 --\x3e\n                                <div id="competition-layout-4" class="grid grid-cols-1 sm:grid-cols-2 gap-6 mb-6 hidden">\n                                    \x3c!-- 算法1容器 --\x3e\n                                    <div class="algorithm-container bg-gray-50 rounded-xl shadow-sm p-4 border border-gray-200 hover:shadow-md transition-all duration-300 ease-out">\n                                        <div class="flex justify-between items-center mb-3 pb-2 border-b border-primary/20">\n                                            <h3 class="text-base font-semibold text-primary">算法1: <span id="algorithm-name-0">冒泡排序</span></h3>\n                                            <div class="text-xs font-medium bg-primary/10 text-primary px-2 py-1 rounded-full" id="algorithm-status-0">就绪</div>\n                                        </div>\n                                        <div class="relative">\n                                            <div class="flex items-end justify-center gap-[2px] md:gap-[4px] h-[180px] sm:h-[200px] w-full p-2 md:p-4 border border-gray-200 rounded-t-lg shadow-inner bg-white" id="bars-container-0">\n                                                \x3c!-- 排序柱体元素将在这里动态生成 --\x3e\n                                            </div>\n                                        </div>\n                                        <div class="flex justify-around items-center mt-3 pt-3 border-t border-gray-200 text-sm">\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">比较</span>\n                                                <span class="text-base sm:text-lg font-bold text-primary" id="comparison-count-0">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">交换</span>\n                                                <span class="text-base sm:text-lg font-bold text-primary" id="swap-count-0">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">时间</span>\n                                                <span class="text-base sm:text-lg font-bold text-primary" id="execution-time-0">0ms</span>\n                                            </div>\n                                        </div>\n                                    </div>\n                                    \n                                    \x3c!-- 算法2容器 --\x3e\n                                    <div class="algorithm-container bg-gray-50 rounded-xl shadow-sm p-4 border border-gray-200 hover:shadow-md transition-all duration-300 ease-out">\n                                        <div class="flex justify-between items-center mb-3 pb-2 border-b border-orange-500/20">\n                                            <h3 class="text-base font-semibold text-orange-500">算法2: <span id="algorithm-name-1">选择排序</span></h3>\n                                            <div class="text-xs font-medium bg-orange-500/10 text-orange-500 px-2 py-1 rounded-full" id="algorithm-status-1">就绪</div>\n                                        </div>\n                                        <div class="relative">\n                                            <div class="flex items-end justify-center gap-[2px] md:gap-[4px] h-[180px] sm:h-[200px] w-full p-2 md:p-4 border border-gray-200 rounded-t-lg shadow-inner bg-white" id="bars-container-1">\n                                                \x3c!-- 排序柱体元素将在这里动态生成 --\x3e\n                                            </div>\n                                        </div>\n                                        <div class="flex justify-around items-center mt-3 pt-3 border-t border-gray-200 text-sm">\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">比较</span>\n                                                <span class="text-base sm:text-lg font-bold text-orange-500" id="comparison-count-1">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">交换</span>\n                                                <span class="text-base sm:text-lg font-bold text-orange-500" id="swap-count-1">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">时间</span>\n                                                <span class="text-base sm:text-lg font-bold text-orange-500" id="execution-time-1">0ms</span>\n                                            </div>\n                                        </div>\n                                    </div>\n                                    \n                                    \x3c!-- 算法3容器 --\x3e\n                                    <div class="algorithm-container bg-gray-50 rounded-xl shadow-sm p-4 border border-gray-200 hover:shadow-md transition-all duration-300 ease-out">\n                                        <div class="flex justify-between items-center mb-3 pb-2 border-b border-green-500/20">\n                                            <h3 class="text-base font-semibold text-green-500">算法3: <span id="algorithm-name-2">插入排序</span></h3>\n                                            <div class="text-xs font-medium bg-green-500/10 text-green-500 px-2 py-1 rounded-full" id="algorithm-status-2">就绪</div>\n                                        </div>\n                                        <div class="relative">\n                                            <div class="flex items-end justify-center gap-[2px] md:gap-[4px] h-[180px] sm:h-[200px] w-full p-2 md:p-4 border border-gray-200 rounded-t-lg shadow-inner bg-white" id="bars-container-2">\n                                                \x3c!-- 排序柱体元素将在这里动态生成 --\x3e\n                                            </div>\n                                        </div>\n                                        <div class="flex justify-around items-center mt-3 pt-3 border-t border-gray-200 text-sm">\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">比较</span>\n                                                <span class="text-base sm:text-lg font-bold text-green-500" id="comparison-count-2">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">交换</span>\n                                                <span class="text-base sm:text-lg font-bold text-green-500" id="swap-count-2">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">时间</span>\n                                                <span class="text-base sm:text-lg font-bold text-green-500" id="execution-time-2">0ms</span>\n                                            </div>\n                                        </div>\n                                    </div>\n                                    \n                                    \x3c!-- 算法4容器 --\x3e\n                                    <div class="algorithm-container bg-gray-50 rounded-xl shadow-sm p-4 border border-gray-200 hover:shadow-md transition-all duration-300 ease-out">\n                                        <div class="flex justify-between items-center mb-3 pb-2 border-b border-purple-500/20">\n                                            <h3 class="text-base font-semibold text-purple-500">算法4: <span id="algorithm-name-3">快速排序</span></h3>\n                                            <div class="text-xs font-medium bg-purple-500/10 text-purple-500 px-2 py-1 rounded-full" id="algorithm-status-3">就绪</div>\n                                        </div>\n                                        <div class="relative">\n                                            <div class="flex items-end justify-center gap-[2px] md:gap-[4px] h-[180px] sm:h-[200px] w-full p-2 md:p-4 border border-gray-200 rounded-t-lg shadow-inner bg-white" id="bars-container-3">\n                                                \x3c!-- 排序柱体元素将在这里动态生成 --\x3e\n                                            </div>\n                                        </div>\n                                        <div class="flex justify-around items-center mt-3 pt-3 border-t border-gray-200 text-sm">\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">比较</span>\n                                                <span class="text-base sm:text-lg font-bold text-purple-500" id="comparison-count-3">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">交换</span>\n                                                <span class="text-base sm:text-lg font-bold text-purple-500" id="swap-count-3">0</span>\n                                            </div>\n                                            <div class="flex flex-col items-center space-y-1">\n                                                <span class="text-xs text-gray-500">时间</span>\n                                                <span class="text-base sm:text-lg font-bold text-purple-500" id="execution-time-3">0ms</span>\n                                            </div>\n                                        </div>\n                                    </div>\n                                </div>\n                                \n                                \x3c!-- 性能对比图表 --\x3e\n                                <div class="bg-gray-50 rounded-xl shadow-sm p-4 border border-gray-200 hover:shadow-md transition-all duration-300 ease-out">\n                                    <h4 class="text-sm font-medium text-gray-700 mb-3 flex items-center">\n                                        <i class="fa fa-line-chart mr-2 text-primary"></i> 性能对比图表\n                                    </h4>\n                                    <div class="w-full h-48 bg-white rounded-lg border border-gray-200 p-2">\n                                        <canvas id="competition-performance-chart"></canvas>\n                                    </div>\n                                </div>\n                                \n\n                            </div>\n                            \n                            \x3c!-- 竞赛控制面板 - 占1列 --\x3e\n                            <div class="md:col-span-1">\n                                \x3c!-- 统一竞赛控制面板 --\x3e\n                                <div id="competition-config-panel" class="bg-card rounded-xl shadow-md p-5 border border-gray-100 flex flex-col">\n                                    <div class="flex justify-between items-center mb-4 pb-2 border-b border-primary/20">\n                                        <h2 class="text-lg font-semibold text-primary">竞赛配置与控制</h2>\n                                    </div>\n                                    <div class="space-y-5 flex-1">\n                                        \x3c!-- 竞赛参数配置 --\x3e\n                                        <div class="space-y-4">\n                                            \x3c!-- 数组大小 --\x3e\n                                            <div>\n                                                <label for="competition-array-size" class="block text-sm font-medium text-gray-700 mb-2">数组大小</label>\n                                                <input \n                                                    type="range" \n                                                    id="competition-array-size" \n                                                    min="5" \n                                                    max="100" \n                                                    value="20" \n                                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary transition-all duration-200 hover:accent-primary/80"\n                                                >\n                                                <div class="flex justify-between mt-1 text-xs text-gray-500">\n                                                    <span>5</span>\n                                                    <span id="competition-array-size-value" class="font-medium text-gray-900">20</span>\n                                                    <span>100</span>\n                                                </div>\n                                            </div>\n                                            \n                                            \x3c!-- 执行速度 --\x3e\n                                            <div>\n                                                <label for="competition-speed" class="block text-sm font-medium text-gray-700 mb-2">执行速度</label>\n                                                <input \n                                                    type="range" \n                                                    id="competition-speed" \n                                                    min="1" \n                                                    max="500" \n                                                    value="10" \n                                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary transition-all duration-200 hover:accent-primary/80"\n                                                >\n                                                <div class="flex justify-between mt-1 text-xs text-gray-500">\n                                                    <span>慢</span>\n                                                    <span id="competition-speed-value" class="font-medium text-gray-900">10</span>\n                                                    <span>快</span>\n                                                </div>\n                                            </div>\n                                        </div>\n                                        \n                                        \x3c!-- 全局控制按钮 --\x3e\n                                        <div class="mt-6">\n                                            <h3 class="text-sm font-medium text-gray-700 mb-3">竞赛控制</h3>\n                                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">\n                                                <button id="competition-start-btn" class="w-full px-4 py-2 bg-green-500 text-white rounded-lg font-medium hover:bg-green-600 transition-all duration-200 shadow-sm hover:shadow-md active:scale-95 flex items-center justify-center gap-2">\n                                                    <i class="fa fa-play"></i> 开始\n                                                </button>\n                                                <button id="competition-pause-btn" class="w-full px-4 py-2 bg-yellow-500 text-white rounded-lg font-medium hover:bg-yellow-600 transition-all duration-200 shadow-sm hover:shadow-md active:scale-95 flex items-center justify-center gap-2">\n                                                    <i class="fa fa-pause"></i> 暂停\n                                                </button>\n                                                \n                                                \x3c!-- 增强的生成新数组按钮 --\x3e\n                                                <div class="relative">\n                                                    <button id="competition-new-array-btn" class="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg font-medium hover:bg-gray-300 transition-all duration-200 shadow-sm hover:shadow-md active:scale-95 flex items-center justify-between">\n                                                        <div class="flex items-center gap-2">\n                                                            <i class="fa fa-refresh"></i> 生成新数组\n                                                        </div>\n                                                        <i class="fa fa-chevron-down text-xs"></i>\n                                                    </button>\n                                                    \x3c!-- 下拉菜单 --\x3e\n                                                    <div id="competition-new-array-menu" class="absolute left-0 right-0 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg z-50 hidden opacity-0 transition-all duration-300 ease-out transform translate-y-2">\n                                                        <div class="py-2">\n                                                            <button class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-primary/10 hover:text-primary transition-colors" data-distribution="random">\n                                                                <i class="fa fa-random mr-2"></i> 随机数组\n                                                            </button>\n                                                            <button class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-primary/10 hover:text-primary transition-colors" data-distribution="sorted">\n                                                                <i class="fa fa-sort-amount-asc mr-2"></i> 已排序数组\n                                                            </button>\n                                                            <button class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-primary/10 hover:text-primary transition-colors" data-distribution="reverse">\n                                                                <i class="fa fa-sort-amount-desc mr-2"></i> 逆序数组\n                                                            </button>\n                                                            <button class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-primary/10 hover:text-primary transition-colors" data-distribution="nearly-sorted">\n                                                                <i class="fa fa-random mr-2"></i> 近似排序\n                                                            </button>\n                                                            <button class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-primary/10 hover:text-primary transition-colors" data-distribution="few-unique">\n                                                                <i class="fa fa-th mr-2"></i> 少数唯一值\n                                                            </button>\n                                                            <div class="border-t border-gray-100 my-1"></div>\n                                                            <button class="block w-full text-left px-4 py-2 text-sm text-primary hover:bg-primary/10 transition-colors" data-action="custom">\n                                                                <i class="fa fa-pencil mr-2"></i> 自定义数组...\n                                                            </button>\n                                                        </div>\n                                                    </div>\n                                                </div>\n                                                \n                                                <button id="competition-reset-btn" class="w-full px-4 py-2 bg-red-500 text-white rounded-lg font-medium hover:bg-red-600 transition-all duration-200 shadow-sm hover:shadow-md active:scale-95 flex items-center justify-center gap-2">\n                                                    <i class="fa fa-stop"></i> 重置\n                                                </button>\n                                            </div>\n                                        </div>\n                                    </div>\n                                </div>\n                                \n\n                            </div>\n                        </div>\n                    </div>\n                </section>\n            </main>\n            \n            \x3c!-- 自定义数组输入模态框 --\x3e\n            <div id="custom-array-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">\n                <div class="bg-white rounded-xl shadow-lg p-6 w-full max-w-md">\n                    <h2 class="text-xl font-semibold mb-4">自定义数组</h2>\n                    <div class="space-y-4">\n                        <div>\n                            <label for="custom-array-input" class="block text-sm font-medium text-gray-700 mb-2">请输入逗号分隔的数字</label>\n                            <input \n                                type="text" \n                                id="custom-array-input" \n                                placeholder="如：10,5,3,8,2" \n                                class="w-full bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-primary focus:border-primary block p-2"\n                            >\n                            <p id="custom-array-modal-error" class="text-xs text-red-500 mt-1 hidden">请输入有效的数字数组</p>\n                        </div>\n                        <div class="flex gap-3 justify-end">\n                            <button \n                                id="cancel-custom-array" \n                                class="control-btn control-btn-secondary"\n                            >\n                                <i class="fa fa-times"></i> 取消\n                            </button>\n                            <button \n                                id="confirm-custom-array" \n                                class="control-btn control-btn-primary"\n                            >\n                                <i class="fa fa-check"></i> 确认\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        '),this.app.insertAdjacentHTML("beforeend",'\n            <div class="keyboard-shortcuts">\n                <h4>键盘快捷键</h4>\n                <ul>\n                    <li><span class="key">Space</span><span class="action">开始/暂停</span></li>\n                    <li><span class="key">→</span><span class="action">步进</span></li>\n                    <li><span class="key">←</span><span class="action">步退</span></li>\n                    <li><span class="key">R</span><span class="action">重置</span></li>\n                    <li><span class="key">N</span><span class="action">生成新数组</span></li>\n                </ul>\n            </div>\n        ')}}class o{constructor(){this.app=document.getElementById("app"),this.render()}render(){const t=this.app.querySelector("#control-panel-container");t&&(t.insertAdjacentHTML("beforeend",'\n            \x3c!-- 控制面板 --\x3e\n            <div class="bg-card rounded-xl shadow-md p-5 border border-gray-100 h-full flex flex-col">\n                <h2 class="text-lg font-semibold mb-4 pb-2 border-b border-gray-100">控制面板</h2>\n                \n                <div class="space-y-6">\n                    \x3c!-- 算法选择器 --\x3e\n                    <div>\n                        <label for="algorithm-selector" class="block text-sm font-medium text-gray-700 mb-2">选择算法</label>\n                        <select id="algorithm-selector" class="w-full bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-primary focus:border-primary block p-2">\n                            <option value="bubbleSort">冒泡排序</option>\n                            <option value="quickSort">快速排序</option>\n                            <option value="selectionSort">选择排序</option>\n                            <option value="insertionSort">插入排序</option>\n                            <option value="mergeSort">归并排序</option>\n                            <option value="heapSort">堆排序</option>\n                            <option value="shellSort">希尔排序</option>\n                            <option value="countingSort">计数排序</option>\n                            <option value="radixSort">基数排序</option>\n                        </select>\n                    </div>\n                    \n                    \x3c!-- 控制按钮组 --\x3e\n                    <div class="grid grid-cols-3 gap-3 relative">\n                        \x3c!-- 新数组按钮和悬浮菜单 --\x3e\n                        <div class="relative">\n                            <button id="new-array" class="control-btn bg-primary text-white hover:bg-primary/90 active:bg-primary/80 w-full">\n                                <i class="fa fa-refresh"></i> 新数组\n                            </button>\n                            \x3c!-- 悬浮菜单 --\x3e\n                            <div id="new-array-menu" class="absolute hidden bg-white shadow-lg rounded-lg border border-gray-200 z-10 w-full mt-1">\n                                <div class="py-1">\n                                    <button class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md" data-array-type="random">\n                                        <i class="fa fa-random mr-2"></i> 随机数组\n                                    </button>\n                                    <button class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md" data-array-type="sorted">\n                                        <i class="fa fa-sort-amount-asc mr-2"></i> 已排序数组\n                                    </button>\n                                    <button class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md" data-array-type="reverse">\n                                        <i class="fa fa-sort-amount-desc mr-2"></i> 逆序数组\n                                    </button>\n                                    <button class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md" data-array-type="nearly-sorted">\n                                        <i class="fa fa-random mr-2"></i> 近似排序数组\n                                    </button>\n                                    <button class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md" data-array-type="few-unique">\n                                        <i class="fa fa-th mr-2"></i> 少数唯一值\n                                    </button>\n                                    <button class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md" data-array-type="constant">\n                                        <i class="fa fa-minus mr-2"></i> 常数数组\n                                    </button>\n                                    <button class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md" data-array-type="alternating">\n                                        <i class="fa fa-exchange mr-2"></i> 交替数组\n                                    </button>\n                                    <div class="border-t border-gray-200 my-1"></div>\n                                    <button class="w-full text-left px-4 py-2 text-sm text-primary hover:bg-gray-100 rounded-md" data-array-type="custom">\n                                        <i class="fa fa-pencil mr-2"></i> 自定义数组\n                                    </button>\n                                </div>\n                            </div>\n                        </div>\n                        <button id="start-sort" class="control-btn bg-green-500 text-white hover:bg-green-600 active:bg-green-700">\n                            <i class="fa fa-play"></i> 开始\n                        </button>\n                        <button id="pause-sort" class="control-btn bg-red-500 text-white hover:bg-red-600 active:bg-red-700" disabled>\n                            <i class="fa fa-pause"></i> 暂停\n                        </button>\n                        <button id="reset-sort" class="control-btn bg-amber-700 text-white hover:bg-amber-800 active:bg-amber-900">\n                            <i class="fa fa-stop"></i> 重置\n                        </button>\n                        <button id="step-back" class="control-btn bg-yellow-500 text-white hover:bg-yellow-600 active:bg-yellow-700" disabled>\n                            <i class="fa fa-step-backward"></i> 步退\n                        </button>\n                        <button id="step-forward" class="control-btn bg-yellow-500 text-white hover:bg-yellow-600 active:bg-yellow-700" disabled>\n                            <i class="fa fa-step-forward"></i> 步进\n                        </button>\n                    </div>\n                    \n                    \x3c!-- 数组大小和排序速度 - 水平排布，尺寸缩短 --\x3e\n                        <div class="grid grid-cols-2 gap-4">\n                            \x3c!-- 数组大小滑块 --\x3e\n                            <div>\n                                <div class="flex justify-between items-center mb-1">\n                                    <label for="array-size" class="text-xs font-medium text-gray-700">数组大小: <span id="array-size-value">20</span></label>\n                                </div>\n                                <input \n                                    type="range" \n                                    id="array-size" \n                                    min="5" \n                                    max="50" \n                                    value="20" \n                                    class="w-full h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary"\n                                >\n                            </div>\n                            \n                            \x3c!-- 排序速度滑块 --\x3e\n                            <div>\n                                <div class="flex justify-between items-center mb-1">\n                                    <label for="sort-speed" class="text-xs font-medium text-gray-700">每秒排序次数: <span id="sort-speed-value">10</span></label>\n                                </div>\n                                <input \n                                    type="range" \n                                    id="sort-speed" \n                                    min="1" \n                                    max="250" \n                                    value="10" \n                                    class="w-full h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary"\n                                >\n                            </div>\n                        </div>\n                        \n                        \n                        \n                        \n                        \x3c!-- 算法日志与步骤解释合并面板 --\x3e\n                        <div class="mt-auto flex flex-col">\n                            <div class="flex justify-between items-center mb-2">\n                                <div class="flex items-center gap-2">\n                                    <label class="text-sm font-medium text-gray-700">算法日志</label>\n                                    <span id="step-number" class="text-xs bg-primary/10 text-primary px-2 py-0.5 rounded-full">步骤: 0</span>\n                                </div>\n                                <span \n                                    id="algorithm-name-tag" \n                                    class="text-xs bg-gray-200 text-gray-700 px-2 py-0.5 rounded-md"\n                                >\n                                    冒泡排序\n                                </span>\n                            </div>\n                            <div \n                                id="algorithm-log" \n                                class="w-full bg-gray-50 border border-gray-300 rounded-lg overflow-y-auto"\n                                style="font-family: \'Fira Code\', monospace; line-height: 1.4; height: 320px; max-height: 320px;"\n                            >\n                                \x3c!-- 日志内容将动态添加 --\x3e\n                                <div id="step-explanation" class="pl-4 border-l-2 border-blue-200 ml-2 mt-1 text-gray-600">\n                                    点击开始排序按钮开始可视化，将显示每一步的详细解释。\n                                </div>\n                            </div>\n                            \n                            \x3c!-- 解释文档生成按钮 --\x3e\n                            <div class="mt-2">\n                                <div class="flex gap-2">\n                                    <button \n                                        id="generate-document-html" \n                                        class="w-full text-xs bg-green-500 text-white hover:bg-green-600 active:bg-green-700 px-3 py-2 rounded-md transition-colors duration-200"\n                                    >\n                                        <i class="fa fa-file-html-o mr-1"></i> 生成HTML文档\n                                    </button>\n                                    <button \n                                        id="generate-document-md" \n                                        class="w-full text-xs bg-blue-500 text-white hover:bg-blue-600 active:bg-blue-700 px-3 py-2 rounded-md transition-colors duration-200"\n                                    >\n                                        <i class="fa fa-file-text-o mr-1"></i> 生成Markdown文档\n                                    </button>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        '),this.bindSliderEvents())}bindSliderEvents(){const t=document.getElementById("array-size"),n=document.getElementById("array-size-value"),e=document.getElementById("sort-speed"),i=document.getElementById("sort-speed-value");t&&n&&t.addEventListener("input",function(t){const e=t.target.value;n.textContent=e}),e&&i&&e.addEventListener("input",function(t){const n=t.target.value;i.textContent=n})}}window.CodeSection=class{constructor(){this.app=document.getElementById("app"),this.render()}render(){const t=this.app.querySelector("main");t&&t.insertAdjacentHTML("beforeend",'\n            \x3c!-- 代码展示区域 --\x3e\n            <section id="code" class="mb-12">\n                <div class="bg-card rounded-xl shadow-md p-5 border border-gray-100">\n                    <h2 class="text-xl font-semibold mb-4">排序算法代码实现</h2>\n                    \n                    \x3c!-- 算法标签页 --\x3e\n                    <div class="border-b border-gray-200 mb-4">\n                        <div class="flex overflow-x-auto space-x-1 md:space-x-4">\n                            <button class="algorithm-tab py-2 px-4 border-b-2 border-primary text-primary font-medium flex items-center gap-2" data-algorithm="bubble">\n                                <i class="fa fa-exchange"></i> 冒泡排序\n                            </button>\n                            <button class="algorithm-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-algorithm="selection">\n                                <i class="fa fa-check-square-o"></i> 选择排序\n                            </button>\n                            <button class="algorithm-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-algorithm="insertion">\n                                <i class="fa fa-arrow-right"></i> 插入排序\n                            </button>\n                            <button class="algorithm-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-algorithm="quick">\n                                <i class="fa fa-bolt"></i> 快速排序\n                            </button>\n                            <button class="algorithm-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-algorithm="merge">\n                                <i class="fa fa-code-fork"></i> 归并排序\n                            </button>\n                            <button class="algorithm-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-algorithm="shell">\n                                <i class="fa fa-th"></i> 希尔排序\n                            </button>\n                            <button class="algorithm-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-algorithm="heap">\n                                <i class="fa fa-cube"></i> 堆排序\n                            </button>\n                            <button class="algorithm-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-algorithm="counting">\n                                <i class="fa fa-bar-chart"></i> 计数排序\n                            </button>\n                            <button class="algorithm-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-algorithm="radix">\n                                <i class="fa fa-sort-numeric-asc"></i> 基数排序\n                            </button>\n                        </div>\n                    </div>\n                    \n                    \x3c!-- 语言标签页 --\x3e\n                    <div class="border-b border-gray-200 mb-4">\n                        <div class="flex overflow-x-auto space-x-1 md:space-x-4">\n                            <button class="code-tab py-2 px-4 border-b-2 border-primary text-primary font-medium flex items-center gap-2" data-lang="c">\n                                <i class="fa fa-code"></i> C\n                            </button>\n                            <button class="code-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-lang="python">\n                                <i class="fa fa-python"></i> Python\n                            </button>\n                            <button class="code-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-lang="go">\n                                <i class="fa fa-golang"></i> Go\n                            </button>\n                            <button class="code-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 flex items-center gap-2" data-lang="java">\n                                <i class="fa fa-coffee"></i> Java\n                            </button>\n                        </div>\n                    </div>\n                    \n                    \x3c!-- 代码内容区域 --\x3e\n                    <div class="code-content">\n                        \x3c!-- 冒泡排序代码 --\x3e\n                        <div class="algorithm-content" data-algorithm="bubble">\n                            \x3c!-- C代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>void bubbleSort(int arr[], int n) {\n    int i, j;\n    for (i = 0; i &lt; n-1; i++) {\n        // 最后i个元素已经就位\n        for (j = 0; j &lt; n-i-1; j++) {\n            // 从0到n-i-1遍历\n            if (arr[j] &gt; arr[j+1]) {\n                // 交换元素\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Python代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def bubble_sort(arr):\n    n = len(arr)\n    # 遍历所有数组元素\n    for i in range(n):\n        # 最后i个元素已经就位\n        for j in range(0, n-i-1):\n            # 从0到n-i-1遍历\n            if arr[j] &gt; arr[j+1]:\n                # 交换元素\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr</code></pre>\n                            </div>\n                            \n                            \x3c!-- Go代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func bubbleSort(arr []int) {\n    n := len(arr)\n    for i := 0; i &lt; n-1; i++ {\n        // 最后i个元素已经就位\n        for j := 0; j &lt; n-i-1; j++ {\n            // 从0到n-i-1遍历\n            if arr[j] &gt; arr[j+1] {\n                // 交换元素\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n            }\n        }\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Java代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class BubbleSort {\n    void bubbleSort(int arr[]) {\n        int n = arr.length;\n        for (int i = 0; i &lt; n-1; i++) {\n            // 最后i个元素已经就位\n            for (int j = 0; j &lt; n-i-1; j++) {\n                // 从0到n-i-1遍历\n                if (arr[j] &gt; arr[j+1]) {\n                    // 交换元素\n                    int temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n}</code></pre>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 选择排序代码 --\x3e\n                        <div class="algorithm-content hidden" data-algorithm="selection">\n                            \x3c!-- C代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>void selectionSort(int arr[], int n) {\n    int i, j, min_idx;\n    \n    // 一个一个地将未排序部分的最小元素放到已排序部分的末尾\n    for (i = 0; i &lt; n-1; i++) {\n        // 找到未排序部分中的最小元素\n        min_idx = i;\n        for (j = i+1; j &lt; n; j++)\n            if (arr[j] &lt; arr[min_idx])\n                min_idx = j;\n        \n        // 将找到的最小元素与第一个元素交换\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Python代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def selection_sort(arr):\n    n = len(arr)\n    \n    # 一个一个地将未排序部分的最小元素放到已排序部分的末尾\n    for i in range(n):\n        # 找到未排序部分中的最小元素\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] &lt; arr[min_idx]:\n                min_idx = j\n                \n        # 将找到的最小元素与第一个元素交换\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n        \n    return arr</code></pre>\n                            </div>\n                            \n                            \x3c!-- Go代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func selectionSort(arr []int) {\n    n := len(arr)\n    \n    // 一个一个地将未排序部分的最小元素放到已排序部分的末尾\n    for i := 0; i < n-1; i++ {\n        // 找到未排序部分中的最小元素\n        min_idx := i\n        for j := i + 1; j < n; j++ {\n            if arr[j] < arr[min_idx] {\n                min_idx = j\n            }\n        }\n        \n        // 将找到的最小元素与第一个元素交换\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Java代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class SelectionSort {\n    void selectionSort(int arr[]) {\n        int n = arr.length;\n        \n        // 一个一个地将未排序部分的最小元素放到已排序部分的末尾\n        for (int i = 0; i < n-1; i++) {\n            // 找到未排序部分中的最小元素\n            int min_idx = i;\n            for (int j = i+1; j < n; j++)\n                if (arr[j] < arr[min_idx])\n                    min_idx = j;\n            \n            // 将找到的最小元素与第一个元素交换\n            int temp = arr[min_idx];\n            arr[min_idx] = arr[i];\n            arr[i] = temp;\n        }\n    }\n}</code></pre>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 插入排序代码 --\x3e\n                        <div class="algorithm-content hidden" data-algorithm="insertion">\n                            \x3c!-- C代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>void insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n        \n        /* 将arr[0..i-1]中所有大于key的元素向后移动一位 */\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Python代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def insertion_sort(arr):\n    # 遍历从1到数组长度-1的元素\n    for i in range(1, len(arr)):\n        key = arr[i]\n        # 将arr[i]放到已排序序列中的正确位置\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr</code></pre>\n                            </div>\n                            \n                            \x3c!-- Go代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func insertionSort(arr []int) {\n    n := len(arr)\n    for i := 1; i < n; i++ {\n        key := arr[i]\n        j := i - 1\n        \n        // 将arr[0..i-1]中所有大于key的元素向后移动一位\n        for j >= 0 && arr[j] > key {\n            arr[j+1] = arr[j]\n            j--\n        }\n        arr[j+1] = key\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Java代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class InsertionSort {\n    void insertionSort(int arr[]) {\n        int n = arr.length;\n        for (int i = 1; i < n; ++i) {\n            int key = arr[i];\n            int j = i - 1;\n \n            /* 将arr[0..i-1]中所有大于key的元素向后移动一位 */\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n}</code></pre>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 快速排序代码 --\x3e\n                        <div class="algorithm-content hidden" data-algorithm="quick">\n                            \x3c!-- C代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 交换两个元素\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n \n// 将数组分区的函数\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; // 选择最右边的元素作为基准\n    int i = (low - 1); // 小于基准的元素的索引\n    \n    for (int j = low; j <= high - 1; j++) {\n        // 如果当前元素小于或等于基准\n        if (arr[j] <= pivot) {\n            i++; // 增加小于基准的元素的索引\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n \n// 快速排序的主要函数\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        // pi是分区的索引，arr[pi]现在在正确的位置\n        int pi = partition(arr, low, high);\n        \n        // 分别对分区前后的子数组进行排序\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Python代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def quick_sort(arr, low, high):\n    if low < high:\n        # pi是分区的索引，arr[pi]现在在正确的位置\n        pi = partition(arr, low, high)\n        \n        # 分别对分区前后的子数组进行排序\n        quick_sort(arr, low, pi - 1)\n        quick_sort(arr, pi + 1, high)\n        \ndef partition(arr, low, high):\n    # 选择最右边的元素作为基准\n    pivot = arr[high]\n    \n    # 小于基准的元素的索引\n    i = low - 1\n    \n    for j in range(low, high):\n        # 如果当前元素小于或等于基准\n        if arr[j] <= pivot:\n            # 增加小于基准的元素的索引\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1</code></pre>\n                            </div>\n                            \n                            \x3c!-- Go代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func quickSort(arr []int, low, high int) {\n    if low < high {\n        // pi是分区的索引，arr[pi]现在在正确的位置\n        pi := partition(arr, low, high)\n        \n        // 分别对分区前后的子数组进行排序\n        quickSort(arr, low, pi-1)\n        quickSort(arr, pi+1, high)\n    }\n}\n\nfunc partition(arr []int, low, high int) int {\n    // 选择最右边的元素作为基准\n    pivot := arr[high]\n    \n    // 小于基准的元素的索引\n    i := low - 1\n    \n    for j := low; j < high; j++ {\n        // 如果当前元素小于或等于基准\n        if arr[j] <= pivot {\n            // 增加小于基准的元素的索引\n            i++\n            arr[i], arr[j] = arr[j], arr[i]\n        }\n    }\n    \n    arr[i+1], arr[high] = arr[high], arr[i+1]\n    return i + 1\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Java代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class QuickSort {\n    /* 交换两个元素 */\n    void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n \n    /* 将数组分区的函数 */\n    int partition(int[] arr, int low, int high) {\n        int pivot = arr[high]; // 选择最右边的元素作为基准\n        int i = (low - 1); // 小于基准的元素的索引\n \n        for (int j = low; j <= high - 1; j++) {\n            // 如果当前元素小于或等于基准\n            if (arr[j] <= pivot) {\n                i++; // 增加小于基准的元素的索引\n                swap(arr, i, j);\n            }\n        }\n        swap(arr, i + 1, high);\n        return (i + 1);\n    }\n \n    /* 快速排序的主要函数 */\n    void quickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            // pi是分区的索引，arr[pi]现在在正确的位置\n            int pi = partition(arr, low, high);\n \n            // 分别对分区前后的子数组进行排序\n            quickSort(arr, low, pi - 1);\n            quickSort(arr, pi + 1, high);\n        }\n    }\n}</code></pre>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 归并排序代码 --\x3e\n                        <div class="algorithm-content hidden" data-algorithm="merge">\n                            \x3c!-- C代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 合并两个子数组arr[l..m]和arr[m+1..r]\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    \n    // 创建临时数组\n    int L[n1], R[n2];\n    \n    // 复制数据到临时数组L[]和R[]\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n    \n    // 合并临时数组回arr[l..r]\n    i = 0; // 初始索引L[]\n    j = 0; // 初始索引R[]\n    k = l; // 初始索引合并的子数组\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    \n    // 复制L[]的剩余元素（如果有）\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    \n    // 复制R[]的剩余元素（如果有）\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// l是第一个索引，r是最后一个索引要排序的子数组\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        // 与(l+r)/2相同，但避免了整数溢出\n        int m = l + (r - l) / 2;\n        \n        // 排序前半部分和后半部分\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        \n        // 合并已排序的部分\n        merge(arr, l, m, r);\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Python代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def merge_sort(arr, l, r):\n    if l < r:\n        # 与(l+r)//2相同，但避免了整数溢出\n        m = l + (r - l) // 2\n        \n        # 排序前半部分和后半部分\n        merge_sort(arr, l, m)\n        merge_sort(arr, m + 1, r)\n        \n        # 合并已排序的部分\n        merge(arr, l, m, r)\n        \ndef merge(arr, l, m, r):\n    n1 = m - l + 1\n    n2 = r - m\n    \n    # 创建临时数组\n    L = [0] * (n1)\n    R = [0] * (n2)\n    \n    # 复制数据到临时数组L[]和R[]\n    for i in range(0, n1):\n        L[i] = arr[l + i]\n        \n    for j in range(0, n2):\n        R[j] = arr[m + 1 + j]\n        \n    # 合并临时数组回arr[l..r]\n    i = 0     # 初始索引L[]\n    j = 0     # 初始索引R[]\n    k = l     # 初始索引合并的子数组\n    \n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n        \n    # 复制L[]的剩余元素（如果有）\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n        \n    # 复制R[]的剩余元素（如果有）\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1</code></pre>\n                            </div>\n                            \n                            \x3c!-- Go代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func mergeSort(arr []int, l, r int) {\n    if l < r {\n        // 与(l+r)/2相同，但避免了整数溢出\n        m := l + (r - l) / 2\n        \n        // 排序前半部分和后半部分\n        mergeSort(arr, l, m)\n        mergeSort(arr, m+1, r)\n        \n        // 合并已排序的部分\n        merge(arr, l, m, r)\n    }\n}\n\nfunc merge(arr []int, l, m, r int) {\n    n1 := m - l + 1\n    n2 := r - m\n    \n    // 创建临时数组\n    L := make([]int, n1)\n    R := make([]int, n2)\n    \n    // 复制数据到临时数组L[]和R[]\n    for i := 0; i < n1; i++ {\n        L[i] = arr[l+i]\n    }\n    for j := 0; j < n2; j++ {\n        R[j] = arr[m+1+j]\n    }\n    \n    // 合并临时数组回arr[l..r]\n    i := 0 // 初始索引L[]\n    j := 0 // 初始索引R[]\n    k := l // 初始索引合并的子数组\n    \n    for i < n1 && j < n2 {\n        if L[i] <= R[j] {\n            arr[k] = L[i]\n            i++\n        } else {\n            arr[k] = R[j]\n            j++\n        }\n        k++\n    }\n    \n    // 复制L[]的剩余元素（如果有）\n    for i < n1 {\n        arr[k] = L[i]\n        i++\n        k++\n    }\n    \n    // 复制R[]的剩余元素（如果有）\n    for j < n2 {\n        arr[k] = R[j]\n        j++\n        k++\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Java代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class MergeSort {\n    // 合并两个子数组arr[l..m]和arr[m+1..r]\n    void merge(int arr[], int l, int m, int r) {\n        // 找到两个子数组的大小\n        int n1 = m - l + 1;\n        int n2 = r - m;\n \n        // 创建临时数组\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n \n        // 复制数据到临时数组\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n \n        // 合并临时数组\n \n        // 初始索引第一个和第二个子数组\n        int i = 0, j = 0;\n \n        // 合并子数组的初始索引\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n \n        // 复制L[]的剩余元素（如果有）\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n \n        // 复制R[]的剩余元素（如果有）\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n \n    // 主函数，用于排序arr[l..r]\n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            // 找到中点\n            int m = l + (r - l) / 2;\n \n            // 排序前半部分和后半部分\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n \n            // 合并已排序的部分\n            merge(arr, l, m, r);\n        }\n    }\n}</code></pre>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 希尔排序代码 --\x3e\n                        <div class="algorithm-content hidden" data-algorithm="shell">\n                            \x3c!-- C代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 希尔排序实现\nvoid shellSort(int arr[], int n) {\n    // 初始步长为数组长度的一半，然后逐渐减小步长\n    for (int gap = n/2; gap > 0; gap /= 2) {\n        // 对每个步长组进行插入排序\n        for (int i = gap; i < n; i++) {\n            // 保存当前元素\n            int temp = arr[i];\n            int j;\n            // 插入排序当前步长组\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n                arr[j] = arr[j - gap];\n            }\n            // 将当前元素插入到正确位置\n            arr[j] = temp;\n        }\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Python代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def shell_sort(arr):\n    n = len(arr)\n    # 初始步长为数组长度的一半，然后逐渐减小步长\n    gap = n // 2\n    \n    while gap > 0:\n        # 对每个步长组进行插入排序\n        for i in range(gap, n):\n            # 保存当前元素\n            temp = arr[i]\n            j = i\n            # 插入排序当前步长组\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # 将当前元素插入到正确位置\n            arr[j] = temp\n        # 减小步长\n        gap //= 2\n    \n    return arr</code></pre>\n                            </div>\n                            \n                            \x3c!-- Go代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func shellSort(arr []int) {\n    n := len(arr)\n    // 初始步长为数组长度的一半，然后逐渐减小步长\n    for gap := n / 2; gap > 0; gap /= 2 {\n        // 对每个步长组进行插入排序\n        for i := gap; i < n; i++ {\n            // 保存当前元素\n            temp := arr[i]\n            j := i\n            // 插入排序当前步长组\n            for j >= gap && arr[j - gap] > temp {\n                arr[j] = arr[j - gap]\n                j -= gap\n            }\n            // 将当前元素插入到正确位置\n            arr[j] = temp\n        }\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Java代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class ShellSort {\n    // 希尔排序实现\n    void shellSort(int arr[]) {\n        int n = arr.length;\n        // 初始步长为数组长度的一半，然后逐渐减小步长\n        for (int gap = n/2; gap > 0; gap /= 2) {\n            // 对每个步长组进行插入排序\n            for (int i = gap; i < n; i += 1) {\n                // 保存当前元素\n                int temp = arr[i];\n                int j;\n                // 插入排序当前步长组\n                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n                    arr[j] = arr[j - gap];\n                }\n                // 将当前元素插入到正确位置\n                arr[j] = temp;\n            }\n        }\n    }\n}</code></pre>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 堆排序代码 --\x3e\n                        <div class="algorithm-content hidden" data-algorithm="heap">\n                            \x3c!-- C代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 交换两个元素\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\n// 堆调整函数，将以root为根的子树调整为最大堆\nvoid heapify(int arr[], int n, int root) {\n    int largest = root;       // 初始化最大值为根节点\n    int left = 2 * root + 1;  // 左子节点\n    int right = 2 * root + 2; // 右子节点\n\n    // 如果左子节点比根节点大\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n\n    // 如果右子节点比最大值大\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n\n    // 如果最大值不是根节点\n    if (largest != root) {\n        swap(&arr[root], &arr[largest]);\n\n        // 递归地调整受影响的子树\n        heapify(arr, n, largest);\n    }\n}\n\n// 堆排序主函数\nvoid heapSort(int arr[], int n) {\n    // 构建最大堆（从最后一个非叶子节点开始）\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    // 一个一个地提取元素\n    for (int i = n - 1; i > 0; i--) {\n        // 将当前根节点（最大值）移到数组末尾\n        swap(&arr[0], &arr[i]);\n\n        // 对剩余的堆进行调整\n        heapify(arr, i, 0);\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Python代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def heapify(arr, n, root):\n    """将以root为根的子树调整为最大堆"""\n    largest = root       # 初始化最大值为根节点\n    left = 2 * root + 1  # 左子节点\n    right = 2 * root + 2 # 右子节点\n\n    # 如果左子节点比根节点大\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # 如果右子节点比最大值大\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # 如果最大值不是根节点\n    if largest != root:\n        # 交换根节点和最大值\n        arr[root], arr[largest] = arr[largest], arr[root]\n\n        # 递归地调整受影响的子树\n        heapify(arr, n, largest)\n\n\ndef heap_sort(arr):\n    """堆排序主函数"""\n    n = len(arr)\n\n    # 构建最大堆（从最后一个非叶子节点开始）\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # 一个一个地提取元素\n    for i in range(n - 1, 0, -1):\n        # 将当前根节点（最大值）移到数组末尾\n        arr[0], arr[i] = arr[i], arr[0]\n\n        # 对剩余的堆进行调整\n        heapify(arr, i, 0)\n\n    return arr</code></pre>\n                            </div>\n                            \n                            \x3c!-- Go代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 堆调整函数，将以root为根的子树调整为最大堆\nfunc heapify(arr []int, n, root int) {\n    largest := root       // 初始化最大值为根节点\n    left := 2*root + 1    // 左子节点\n    right := 2*root + 2   // 右子节点\n\n    // 如果左子节点比根节点大\n    if left < n && arr[left] > arr[largest] {\n        largest = left\n    }\n\n    // 如果右子节点比最大值大\n    if right < n && arr[right] > arr[largest] {\n        largest = right\n    }\n\n    // 如果最大值不是根节点\n    if largest != root {\n        // 交换根节点和最大值\n        arr[root], arr[largest] = arr[largest], arr[root]\n\n        // 递归地调整受影响的子树\n        heapify(arr, n, largest)\n    }\n}\n\n// HeapSort 堆排序主函数\nfunc HeapSort(arr []int) {\n    n := len(arr)\n\n    // 构建最大堆（从最后一个非叶子节点开始）\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(arr, n, i)\n    }\n\n    // 一个一个地提取元素\n    for i := n - 1; i > 0; i-- {\n        // 将当前根节点（最大值）移到数组末尾\n        arr[0], arr[i] = arr[i], arr[0]\n\n        // 对剩余的堆进行调整\n        heapify(arr, i, 0)\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Java代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class HeapSort {\n    // 交换两个元素\n    void swap(int arr[], int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    // 堆调整函数，将以root为根的子树调整为最大堆\n    void heapify(int arr[], int n, int root) {\n        int largest = root;       // 初始化最大值为根节点\n        int left = 2 * root + 1;  // 左子节点\n        int right = 2 * root + 2; // 右子节点\n\n        // 如果左子节点比根节点大\n        if (left < n && arr[left] > arr[largest])\n            largest = left;\n\n        // 如果右子节点比最大值大\n        if (right < n && arr[right] > arr[largest])\n            largest = right;\n\n        // 如果最大值不是根节点\n        if (largest != root) {\n            // 交换根节点和最大值\n            swap(arr, root, largest);\n\n            // 递归地调整受影响的子树\n            heapify(arr, n, largest);\n        }\n    }\n\n    // 堆排序主函数\n    void heapSort(int arr[]) {\n        int n = arr.length;\n\n        // 构建最大堆（从最后一个非叶子节点开始）\n        for (int i = n / 2 - 1; i >= 0; i--)\n            heapify(arr, n, i);\n\n        // 一个一个地提取元素\n        for (int i = n - 1; i > 0; i--) {\n            // 将当前根节点（最大值）移到数组末尾\n            swap(arr, 0, i);\n\n            // 对剩余的堆进行调整\n            heapify(arr, i, 0);\n        }\n    }\n}</code></pre>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 计数排序代码 --\x3e\n                        <div class="algorithm-content hidden" data-algorithm="counting">\n                            \x3c!-- C代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 计数排序实现\nvoid countingSort(int arr[], int n) {\n    // 找出数组中的最大值\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n\n    // 创建计数数组\n    int count[max + 1];\n    // 初始化计数数组为0\n    for (int i = 0; i <= max; i++) {\n        count[i] = 0;\n    }\n\n    // 统计每个元素出现的次数\n    for (int i = 0; i < n; i++) {\n        count[arr[i]]++;\n    }\n\n    // 计算累积计数\n    for (int i = 1; i <= max; i++) {\n        count[i] += count[i - 1];\n    }\n\n    // 创建输出数组\n    int output[n];\n    // 从后向前遍历原数组，将元素放到正确位置\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n\n    // 将排序结果复制回原数组\n    for (int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Python代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def counting_sort(arr):\n    # 找出数组中的最大值\n    max_val = max(arr)\n    # 找出数组中的最小值\n    min_val = min(arr)\n    # 计算范围\n    range_of_elements = max_val - min_val + 1\n    \n    # 创建计数数组\n    count = [0] * range_of_elements\n    # 创建输出数组\n    output = [0] * len(arr)\n    \n    # 统计每个元素出现的次数\n    for i in range(len(arr)):\n        count[arr[i] - min_val] += 1\n    \n    # 计算累积计数\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    \n    # 从后向前遍历原数组，将元素放到正确位置\n    for i in range(len(arr) - 1, -1, -1):\n        output[count[arr[i] - min_val] - 1] = arr[i]\n        count[arr[i] - min_val] -= 1\n    \n    # 将排序结果复制回原数组\n    for i in range(len(arr)):\n        arr[i] = output[i]\n    \n    return arr</code></pre>\n                            </div>\n                            \n                            \x3c!-- Go代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// CountingSort 计数排序实现\nfunc CountingSort(arr []int) []int {\n    if len(arr) <= 1 {\n        return arr\n    }\n    \n    // 找出数组中的最大值和最小值\n    maxVal := arr[0]\n    minVal := arr[0]\n    for _, v := range arr {\n        if v > maxVal {\n            maxVal = v\n        }\n        if v < minVal {\n            minVal = v\n        }\n    }\n    \n    // 计算范围\n    rangeOfElements := maxVal - minVal + 1\n    \n    // 创建计数数组\n    count := make([]int, rangeOfElements)\n    \n    // 统计每个元素出现的次数\n    for _, v := range arr {\n        count[v-minVal]++\n    }\n    \n    // 计算累积计数\n    for i := 1; i < len(count); i++ {\n        count[i] += count[i-1]\n    }\n    \n    // 创建输出数组\n    output := make([]int, len(arr))\n    \n    // 从后向前遍历原数组，将元素放到正确位置\n    for i := len(arr) - 1; i >= 0; i-- {\n        output[count[arr[i]-minVal]-1] = arr[i]\n        count[arr[i]-minVal]--\n    }\n    \n    return output\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Java代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class CountingSort {\n    // 计数排序实现\n    void countingSort(int arr[]) {\n        // 找出数组中的最大值\n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        \n        // 找出数组中的最小值\n        int min = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] < min) {\n                min = arr[i];\n            }\n        }\n        \n        // 计算范围\n        int range = max - min + 1;\n        \n        // 创建计数数组\n        int count[] = new int[range];\n        // 创建输出数组\n        int output[] = new int[arr.length];\n        \n        // 统计每个元素出现的次数\n        for (int i = 0; i < arr.length; i++) {\n            count[arr[i] - min]++;\n        }\n        \n        // 计算累积计数\n        for (int i = 1; i < count.length; i++) {\n            count[i] += count[i - 1];\n        }\n        \n        // 从后向前遍历原数组，将元素放到正确位置\n        for (int i = arr.length - 1; i >= 0; i--) {\n            output[count[arr[i] - min] - 1] = arr[i];\n            count[arr[i] - min]--;\n        }\n        \n        // 将排序结果复制回原数组\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = output[i];\n        }\n    }\n}</code></pre>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 基数排序代码 --\x3e\n                        <div class="algorithm-content hidden" data-algorithm="radix">\n                            \x3c!-- C代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 找出数组中的最大值\nint getMax(int arr[], int n) {\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\n// 按照指定的位进行计数排序\nvoid countSort(int arr[], int n, int exp) {\n    int output[n]; // 输出数组\n    int i, count[10] = {0};\n    \n    // 统计每个数字出现的次数\n    for (i = 0; i < n; i++) {\n        count[(arr[i] / exp) % 10]++;\n    }\n    \n    // 计算累积计数\n    for (i = 1; i < 10; i++) {\n        count[i] += count[i - 1];\n    }\n    \n    // 从后向前遍历原数组，将元素放到正确位置\n    for (i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    \n    // 将排序结果复制回原数组\n    for (i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\n// 基数排序主函数\nvoid radixSort(int arr[], int n) {\n    // 找出数组中的最大值，确定排序的位数\n    int m = getMax(arr, n);\n    \n    // 对每一位进行计数排序\n    for (int exp = 1; m / exp > 0; exp *= 10) {\n        countSort(arr, n, exp);\n    }\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Python代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def radix_sort(arr):\n    # 找出数组中的最大值\n    max_val = max(arr)\n    \n    # 对每一位进行计数排序\n    exp = 1\n    while max_val // exp > 0:\n        count_sort(arr, exp)\n        exp *= 10\n    \n    return arr\n\ndef count_sort(arr, exp):\n    n = len(arr)\n    # 输出数组\n    output = [0] * n\n    # 计数数组\n    count = [0] * 10\n    \n    # 统计每个数字出现的次数\n    for i in range(n):\n        index = arr[i] // exp\n        count[index % 10] += 1\n    \n    # 计算累积计数\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    \n    # 从后向前遍历原数组，将元素放到正确位置\n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n    \n    # 将排序结果复制回原数组\n    for i in range(n):\n        arr[i] = output[i]</code></pre>\n                            </div>\n                            \n                            \x3c!-- Go代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// RadixSort 基数排序主函数\nfunc RadixSort(arr []int) []int {\n    if len(arr) <= 1 {\n        return arr\n    }\n    \n    // 找出数组中的最大值\n    maxVal := arr[0]\n    for _, v := range arr {\n        if v > maxVal {\n            maxVal = v\n        }\n    }\n    \n    // 对每一位进行计数排序\n    for exp := 1; maxVal/exp > 0; exp *= 10 {\n        arr = countSort(arr, exp)\n    }\n    \n    return arr\n}\n\n// 按照指定的位进行计数排序\nfunc countSort(arr []int, exp int) []int {\n    n := len(arr)\n    // 输出数组\n    output := make([]int, n)\n    // 计数数组\n    count := make([]int, 10)\n    \n    // 统计每个数字出现的次数\n    for i := 0; i < n; i++ {\n        count[(arr[i]/exp)%10]++\n    }\n    \n    // 计算累积计数\n    for i := 1; i < 10; i++ {\n        count[i] += count[i-1]\n    }\n    \n    // 从后向前遍历原数组，将元素放到正确位置\n    for i := n - 1; i >= 0; i-- {\n        output[count[(arr[i]/exp)%10]-1] = arr[i]\n        count[(arr[i]/exp)%10]--\n    }\n    \n    return output\n}</code></pre>\n                            </div>\n                            \n                            \x3c!-- Java代码 --\x3e\n                            <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class RadixSort {\n    // 找出数组中的最大值\n    int getMax(int arr[]) {\n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        return max;\n    }\n    \n    // 按照指定的位进行计数排序\n    void countSort(int arr[], int exp) {\n        int n = arr.length;\n        // 输出数组\n        int output[] = new int[n];\n        // 计数数组\n        int count[] = new int[10];\n        \n        // 统计每个数字出现的次数\n        for (int i = 0; i < n; i++) {\n            count[(arr[i] / exp) % 10]++;\n        }\n        \n        // 计算累积计数\n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n        \n        // 从后向前遍历原数组，将元素放到正确位置\n        for (int i = n - 1; i >= 0; i--) {\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n            count[(arr[i] / exp) % 10]--;\n        }\n        \n        // 将排序结果复制回原数组\n        for (int i = 0; i < n; i++) {\n            arr[i] = output[i];\n        }\n    }\n    \n    // 基数排序主函数\n    void radixSort(int arr[]) {\n        // 找出数组中的最大值，确定排序的位数\n        int m = getMax(arr);\n        \n        // 对每一位进行计数排序\n        for (int exp = 1; m / exp > 0; exp *= 10) {\n            countSort(arr, exp);\n        }\n    }\n}</code></pre>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </section>\n        ')}};class l{constructor(){this.app=document.getElementById("app"),this.render(),this.setupEventListeners()}render(){const t=this.app.querySelector("main");t&&t.insertAdjacentHTML("beforeend",'\n            \x3c!-- 算法说明区域 --\x3e\n            <section id="explanation" class="mb-12">\n                <div class="bg-card rounded-xl shadow-md p-5 border border-gray-100">\n                    <h2 class="text-xl font-semibold mb-6">排序算法说明</h2>\n                    \n                    \x3c!-- 算法选择标签页 - 始终全宽 --\x3e\n                    <div class="border-b border-gray-200 mb-6 w-full">\n                        <div class="flex overflow-x-auto space-x-1 md:space-x-4">\n                            <button class="explanation-tab py-2 px-4 border-b-2 border-primary text-primary font-medium" data-algorithm="bubble">冒泡排序</button>\n                            <button class="explanation-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-algorithm="selection">选择排序</button>\n                            <button class="explanation-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-algorithm="insertion">插入排序</button>\n                            <button class="explanation-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-algorithm="quick">快速排序</button>\n                            <button class="explanation-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-algorithm="merge">归并排序</button>\n                            <button class="explanation-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-algorithm="shell">希尔排序</button>\n                            <button class="explanation-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-algorithm="heap">堆排序</button>\n                            <button class="explanation-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-algorithm="counting">计数排序</button>\n                            <button class="explanation-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-algorithm="radix">基数排序</button>\n                        </div>\n                    </div>\n                    \n                    \x3c!-- 算法说明和代码实现容器 --\x3e\n                    <div id="algorithm-content-container" class="space-y-8">\n                    \n                    \x3c!-- 冒泡排序说明 --\x3e\n                    <div class="algorithm-explanation" data-algorithm="bubble">\n                        \x3c!-- 算法信息卡片 --\x3e\n                        <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 rounded-lg border border-blue-100 mb-6 shadow-sm">\n                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4">\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">算法类型</h4>\n                                    <p class="text-sm font-medium text-blue-900 flex items-center gap-1"><i class="fa fa-exchange text-blue-500"></i> 交换排序</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">稳定性</h4>\n                                    <p class="text-sm font-medium text-green-700">稳定</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最佳时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">平均时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n²)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最坏时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n²)</p>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 算法原理 --\x3e\n                        <div class="mb-8" id="algorithm-principle">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法原理</h3>\n                            <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-100 mb-4">\n                                <h4 class="font-medium mb-2 text-yellow-800">历史背景</h4>\n                                <p class="text-yellow-700">\n                                    冒泡排序是最古老的排序算法之一，其名称来源于较小的元素会"冒泡"到数组的顶部。虽然无法确定具体的发明者，但最早的文献记载可以追溯到1956年。冒泡排序因其简单易懂的特性，常被用作排序算法教学的入门示例。\n                                </p>\n                            </div>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                <strong>冒泡排序（Bubble Sort）</strong>是一种简单直观的交换排序算法，其核心思想是通过重复走访待排序数列，比较相邻元素并在顺序错误时进行交换，使得每次遍历都能将最大的元素“冒泡”到数列末尾。\n                            </p>\n                            <h4 class="font-medium mb-2 mt-4">排序步骤：</h4>\n                            <div class="step-by-step mb-4">\n                                \x3c!-- 步骤指示器 --\x3e\n                                <div class="flex mb-4 space-x-2">\n                                    <span class="step-indicator active bg-primary text-white rounded-full w-8 h-8 flex items-center justify-center">1</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">2</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">3</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">4</span>\n                                </div>\n                                \n                                \x3c!-- 步骤内容 --\x3e\n                                <div class="step-content bg-white p-4 rounded-lg border border-gray-200 shadow-sm mb-4 min-h-[80px]">\n                                    <div class="step-item active">比较相邻的元素。如果第一个比第二个大，就交换它们两个；</div>\n                                    <div class="step-item hidden">对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</div>\n                                    <div class="step-item hidden">针对所有的元素重复以上的步骤，除了最后一个；</div>\n                                    <div class="step-item hidden">持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</div>\n                                </div>\n                                \n                                \x3c!-- 导航按钮 --\x3e\n                                <div class="flex justify-between">\n                                    <button class="step-nav-btn prev-btn bg-gray-200 text-gray-500 hover:bg-gray-300 px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>\n                                        上一步\n                                    </button>\n                                    <button class="step-nav-btn next-btn bg-primary text-white hover:bg-primary/90 px-4 py-2 rounded-lg">\n                                        下一步\n                                    </button>\n                                </div>\n                            </div>\n                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100 mb-4">\n                                <h4 class="font-medium mb-2 text-blue-800">算法特点：</h4>\n                                <ul class="list-disc list-inside space-y-1 text-blue-700">\n                                    <li>稳定排序算法：相等元素的相对位置不会改变</li>\n                                    <li>原地排序：不需要额外的存储空间</li>\n                                    <li>简单易实现：代码结构清晰，易于理解</li>\n                                    <li>自适应排序：对于部分有序的数据，效率会有所提升</li>\n                                </ul>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 复杂度分析 --\x3e\n                        <div class="mb-8" id="complexity-analysis">\n                            <h3 class="text-lg font-medium mb-3 text-primary">复杂度分析</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-gray-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2">时间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base">\n                                        <li>最佳情况：<span class="font-semibold">O(n)</span> - 当输入数组已经完全排序时，只需遍历一次即可完成排序</li>\n                                        <li>平均情况：<span class="font-semibold">O(n²)</span> - 对于随机排列的数组，需要进行n(n-1)/2次比较和交换</li>\n                                        <li>最坏情况：<span class="font-semibold">O(n²)</span> - 当输入数组完全逆序时，需要进行最多的比较和交换操作</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-gray-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2">空间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base">\n                                        <li>额外空间：<span class="font-semibold">O(1)</span></li>\n                                        <li>原地排序算法，只需要一个临时变量用于交换操作</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 适用场景 --\x3e\n                        <div id="application-scenarios" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">适用场景</h3>\n                            <p class="mb-3 text-gray-700 text-sm sm:text-base">冒泡排序在以下场景中可能有用：</p>\n                            <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base mb-4">\n                                <li>当数据量很小时（通常n ≤ 50）</li>\n                                <li>对于几乎已经排序的数据，效率接近O(n)</li>\n                                <li>教学场景，用于解释排序算法的基本原理和交换排序思想</li>\n                                <li>需要稳定排序且对性能要求不高的场景</li>\n                            </ul>\n                        </div>\n                        \n                        \x3c!-- 算法优缺点 --\x3e\n                        <div id="algorithm-pros-cons" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法优缺点</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-green-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2 text-green-800">优点</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-green-700 text-sm sm:text-base">\n                                        <li>实现简单，代码易于理解和维护</li>\n                                        <li>稳定排序，不改变相等元素的相对位置</li>\n                                        <li>原地排序，不需要额外的存储空间</li>\n                                        <li>自适应，对于部分有序数据效率较高</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-red-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2 text-red-800">缺点</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-red-700 text-sm sm:text-base">\n                                        <li>时间复杂度较高，对于大规模数据效率低下</li>\n                                        <li>元素交换次数较多，影响性能</li>\n                                        <li>比较次数较多，即使在部分有序情况下</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n                    \n                    \x3c!-- 选择排序说明 --\x3e\n                    <div class="algorithm-explanation hidden" data-algorithm="selection">\n                        \x3c!-- 算法信息卡片 --\x3e\n                        <div class="bg-gradient-to-r from-orange-50 to-amber-50 p-4 rounded-lg border border-orange-100 mb-6 shadow-sm">\n                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4">\n                                <div>\n                                    <h4 class="text-xs font-semibold text-orange-600 uppercase tracking-wider mb-1">算法类型</h4>\n                                    <p class="text-sm font-medium text-orange-900 flex items-center gap-1"><i class="fa fa-sort-amount-desc text-orange-500"></i> 选择排序</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">稳定性</h4>\n                                    <p class="text-sm font-medium text-red-700">不稳定</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最佳时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n²)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">平均时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n²)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最坏时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n²)</p>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 算法原理 --\x3e\n                        <div class="mb-8" id="algorithm-principle">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法原理</h3>\n                            <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-100 mb-4">\n                                <h4 class="font-medium mb-2 text-yellow-800">历史背景</h4>\n                                <p class="text-yellow-700">\n                                    选择排序也是一种古老的排序算法，其思想可以追溯到早期的制表机和穿孔卡片系统。虽然无法确定具体的发明者，但它在计算机科学发展的早期就已经被广泛使用。选择排序的特点是交换次数少，这在早期存储设备（如磁带）写入成本较高的情况下具有一定优势。\n                                </p>\n                            </div>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                <strong>选择排序（Selection Sort）</strong>是一种简单直观的选择排序算法，其核心思想是每次从待排序元素中选择最小（或最大）的元素，将其放到已排序序列的末尾，直到所有元素均排序完毕。\n                            </p>\n                            <h4 class="font-medium mb-2 mt-4">排序步骤：</h4>\n                            <div class="step-by-step mb-4">\n                                \x3c!-- 步骤指示器 --\x3e\n                                <div class="flex mb-4 space-x-2">\n                                    <span class="step-indicator active bg-primary text-white rounded-full w-8 h-8 flex items-center justify-center">1</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">2</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">3</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">4</span>\n                                </div>\n                                \n                                \x3c!-- 步骤内容 --\x3e\n                                <div class="step-content bg-white p-4 rounded-lg border border-gray-200 shadow-sm mb-4 min-h-[80px]">\n                                    <div class="step-item active">初始状态：无序区为R[1..n]，有序区为空；</div>\n                                    <div class="step-item hidden">第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]；</div>\n                                    <div class="step-item hidden">将R[k]与无序区的第1个记录R[i]交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</div>\n                                    <div class="step-item hidden">n-1趟结束，数组有序化了。</div>\n                                </div>\n                                \n                                \x3c!-- 导航按钮 --\x3e\n                                <div class="flex justify-between">\n                                    <button class="step-nav-btn prev-btn bg-gray-200 text-gray-500 hover:bg-gray-300 px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>\n                                        上一步\n                                    </button>\n                                    <button class="step-nav-btn next-btn bg-primary text-white hover:bg-primary/90 px-4 py-2 rounded-lg">\n                                        下一步\n                                    </button>\n                                </div>\n                            </div>\n                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100 mb-4">\n                                <h4 class="font-medium mb-2 text-blue-800">算法特点：</h4>\n                                <ul class="list-disc list-inside space-y-1 text-blue-700">\n                                    <li>不稳定排序算法：相等元素的相对位置可能会改变</li>\n                                    <li>原地排序：不需要额外的存储空间</li>\n                                    <li>简单易实现：代码结构清晰，易于理解</li>\n                                    <li>交换次数少：最多进行n-1次交换操作</li>\n                                </ul>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 复杂度分析 --\x3e\n                        <div class="mb-8" id="complexity-analysis">\n                            <h3 class="text-lg font-medium mb-3 text-primary">复杂度分析</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-gray-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2">时间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base">\n                                        <li>最佳情况：<span class="font-semibold">O(n²)</span> - 即使输入数组已经完全排序，仍需进行n(n-1)/2次比较</li>\n                                        <li>平均情况：<span class="font-semibold">O(n²)</span> - 对于随机排列的数组，需要进行n(n-1)/2次比较</li>\n                                        <li>最坏情况：<span class="font-semibold">O(n²)</span> - 当输入数组完全逆序时，比较次数不变，仍需n(n-1)/2次</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-gray-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2">空间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base">\n                                        <li>额外空间：<span class="font-semibold">O(1)</span></li>\n                                        <li>原地排序算法，只需要一个临时变量用于交换操作</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 适用场景 --\x3e\n                        <div id="application-scenarios" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">适用场景</h3>\n                            <p class="mb-3 text-gray-700 text-sm sm:text-base">选择排序在以下场景中可能有用：</p>\n                            <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base mb-4">\n                                <li>当内存空间有限，需要最小化写操作时（选择排序交换次数少）</li>\n                                <li>对于小规模数据，简单性比效率更重要时</li>\n                                <li>教学场景，用于解释排序算法的基本原理和选择排序思想</li>\n                                <li>需要原地排序且对稳定性要求不高的场景</li>\n                            </ul>\n                        </div>\n                        \n                        \x3c!-- 算法优缺点 --\x3e\n                        <div id="algorithm-pros-cons" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法优缺点</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-green-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2 text-green-800">优点</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-green-700 text-sm sm:text-base">\n                                        <li>实现简单，代码易于理解和维护</li>\n                                        <li>原地排序，不需要额外的存储空间</li>\n                                        <li>交换次数少，最多进行n-1次交换</li>\n                                        <li>适用于某些硬件平台，如写入操作比读取操作昂贵的场景</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-red-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2 text-red-800">缺点</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-red-700 text-sm sm:text-base">\n                                        <li>时间复杂度较高，对于大规模数据效率低下</li>\n                                        <li>不稳定排序，可能改变相等元素的相对位置</li>\n                                        <li>比较次数固定，不受输入数据影响</li>\n                                        <li>不适合处理部分有序的数据</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n                    \n                    \x3c!-- 插入排序说明 --\x3e\n                    <div class="algorithm-explanation hidden" data-algorithm="insertion">\n                        \x3c!-- 算法信息卡片 --\x3e\n                        <div class="bg-gradient-to-r from-green-50 to-emerald-50 p-4 rounded-lg border border-green-100 mb-6 shadow-sm">\n                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4">\n                                <div>\n                                    <h4 class="text-xs font-semibold text-green-600 uppercase tracking-wider mb-1">算法类型</h4>\n                                    <p class="text-sm font-medium text-green-900 flex items-center gap-1"><i class="fa fa-sort text-green-500"></i> 插入排序</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">稳定性</h4>\n                                    <p class="text-sm font-medium text-green-700">稳定</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最佳时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">平均时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n²)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最坏时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n²)</p>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 算法原理 --\x3e\n                        <div class="mb-8" id="algorithm-principle">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法原理</h3>\n                            <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-100 mb-4">\n                                <h4 class="font-medium mb-2 text-yellow-800">历史背景</h4>\n                                <p class="text-yellow-700">\n                                    插入排序是最古老的排序算法之一，其思想可以追溯到人类手动排序的方式，比如整理扑克牌或排序文件。在计算机科学中，插入排序早在1946年就被John Mauchly在ENIAC计算机上实现。由于其简单性和对小规模数据的高效性，插入排序至今仍在许多场景中使用，尤其是作为更复杂排序算法的子过程。\n                                </p>\n                            </div>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                <strong>插入排序（Insertion Sort）</strong>是一种简单直观的排序算法，其核心思想是将待排序元素逐个插入到已排序序列中的适当位置。它的工作原理类似于我们在玩扑克牌时，将新摸到的牌插入到手中已排好序的牌中的过程。\n                            </p>\n                            <h4 class="font-medium mb-2 mt-4">排序步骤：</h4>\n                            <div class="step-by-step mb-4">\n                                \x3c!-- 步骤指示器 --\x3e\n                                <div class="flex mb-4 space-x-2">\n                                    <span class="step-indicator active bg-primary text-white rounded-full w-8 h-8 flex items-center justify-center">1</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">2</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">3</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">4</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">5</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">6</span>\n                                </div>\n                                \n                                \x3c!-- 步骤内容 --\x3e\n                                <div class="step-content bg-white p-4 rounded-lg border border-gray-200 shadow-sm mb-4 min-h-[80px]">\n                                    <div class="step-item active">从第一个元素开始，该元素可以认为已经被排序；</div>\n                                    <div class="step-item hidden">取出下一个元素，在已经排序的元素序列中从后向前扫描；</div>\n                                    <div class="step-item hidden">如果该元素（已排序）大于新元素，将该元素移到下一位置；</div>\n                                    <div class="step-item hidden">重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</div>\n                                    <div class="step-item hidden">将新元素插入到该位置后；</div>\n                                    <div class="step-item hidden">重复步骤2~5。</div>\n                                </div>\n                                \n                                \x3c!-- 导航按钮 --\x3e\n                                <div class="flex justify-between">\n                                    <button class="step-nav-btn prev-btn bg-gray-200 text-gray-500 hover:bg-gray-300 px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>\n                                        上一步\n                                    </button>\n                                    <button class="step-nav-btn next-btn bg-primary text-white hover:bg-primary/90 px-4 py-2 rounded-lg">\n                                        下一步\n                                    </button>\n                                </div>\n                            </div>\n                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100 mb-4">\n                                <h4 class="font-medium mb-2 text-blue-800">算法特点：</h4>\n                                <ul class="list-disc list-inside space-y-1 text-blue-700">\n                                    <li>稳定排序算法：相等元素的相对位置不会改变</li>\n                                    <li>原地排序：不需要额外的存储空间</li>\n                                    <li>简单易实现：代码结构清晰，易于理解</li>\n                                    <li>自适应排序：对于部分有序的数据，效率会显著提升</li>\n                                    <li>增量排序：可以在排序过程中对数组进行增量排序</li>\n                                </ul>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 复杂度分析 --\x3e\n                        <div class="mb-8" id="complexity-analysis">\n                            <h3 class="text-lg font-medium mb-3 text-primary">复杂度分析</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-gray-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2">时间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base">\n                                        <li>最佳情况：<span class="font-semibold">O(n)</span> - 当输入数组已经完全排序时，只需遍历一次即可完成排序</li>\n                                        <li>平均情况：<span class="font-semibold">O(n²)</span> - 对于随机排列的数组，需要进行n(n-1)/4次比较和移动</li>\n                                        <li>最坏情况：<span class="font-semibold">O(n²)</span> - 当输入数组完全逆序时，需要进行最多的比较和移动操作</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-gray-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2">空间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base">\n                                        <li>额外空间：<span class="font-semibold">O(1)</span></li>\n                                        <li>原地排序算法，只需要一个临时变量用于存储当前要插入的元素</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 适用场景 --\x3e\n                        <div id="application-scenarios" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">适用场景</h3>\n                            <p class="mb-3 text-gray-700 text-sm sm:text-base">插入排序在以下场景中表现良好：</p>\n                            <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base mb-4">\n                                <li>对于几乎已经排序的数据，效率接近O(n)</li>\n                                <li>小规模数据（通常n ≤ 100）</li>\n                                <li>需要稳定排序的场景</li>\n                                <li>作为更复杂排序算法的一部分（如快速排序的小规模子数组处理）</li>\n                                <li>需要增量排序的场景，即数据可能会持续输入</li>\n                            </ul>\n                        </div>\n                        \n                        \x3c!-- 算法优缺点 --\x3e\n                        <div id="algorithm-pros-cons" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法优缺点</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-green-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2 text-green-800">优点</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-green-700 text-sm sm:text-base">\n                                        <li>实现简单，代码易于理解和维护</li>\n                                        <li>稳定排序，不改变相等元素的相对位置</li>\n                                        <li>原地排序，不需要额外的存储空间</li>\n                                        <li>自适应，对于部分有序数据效率较高</li>\n                                        <li>适合增量排序和小规模数据排序</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-red-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2 text-red-800">缺点</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-red-700 text-sm sm:text-base">\n                                        <li>时间复杂度较高，对于大规模数据效率低下</li>\n                                        <li>元素移动次数较多，影响性能</li>\n                                        <li>比较次数较多，尤其是在逆序情况下</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n                    \n                    \x3c!-- 快速排序说明 --\x3e\n                    <div class="algorithm-explanation hidden" data-algorithm="quick">\n                        \x3c!-- 算法信息卡片 --\x3e\n                        <div class="bg-gradient-to-r from-red-50 to-rose-50 p-4 rounded-lg border border-red-100 mb-6 shadow-sm">\n                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4">\n                                <div>\n                                    <h4 class="text-xs font-semibold text-red-600 uppercase tracking-wider mb-1">算法类型</h4>\n                                    <p class="text-sm font-medium text-red-900 flex items-center gap-1"><i class="fa fa-bolt text-red-500"></i> 分治排序</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">稳定性</h4>\n                                    <p class="text-sm font-medium text-red-700">不稳定</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最佳时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n log n)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">平均时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n log n)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最坏时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n²)</p>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 算法原理 --\x3e\n                        <div class="mb-8" id="algorithm-principle">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法原理</h3>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                <strong>快速排序（Quick Sort）</strong>是一种高效的分治排序算法，由C. A. R. Hoare在1960年提出。它的核心思想是通过选择一个"基准"元素，将数组分为两个子数组，小于基准的元素放在左边，大于基准的元素放在右边，然后递归地对子数组进行排序。\n                            </p>\n                            <h4 class="font-medium mb-2 mt-4">排序步骤：</h4>\n                            <div class="step-by-step mb-4">\n                                \x3c!-- 步骤指示器 --\x3e\n                                <div class="flex mb-4 space-x-2">\n                                    <span class="step-indicator active bg-primary text-white rounded-full w-8 h-8 flex items-center justify-center">1</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">2</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">3</span>\n                                </div>\n                                \n                                \x3c!-- 步骤内容 --\x3e\n                                <div class="step-content bg-white p-4 rounded-lg border border-gray-200 shadow-sm mb-4 min-h-[80px]">\n                                    <div class="step-item active">从数列中挑出一个元素，称为"基准"（pivot）；</div>\n                                    <div class="step-item hidden">重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</div>\n                                    <div class="step-item hidden">递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</div>\n                                </div>\n                                \n                                \x3c!-- 导航按钮 --\x3e\n                                <div class="flex justify-between">\n                                    <button class="step-nav-btn prev-btn bg-gray-200 text-gray-500 hover:bg-gray-300 px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>\n                                        上一步\n                                    </button>\n                                    <button class="step-nav-btn next-btn bg-primary text-white hover:bg-primary/90 px-4 py-2 rounded-lg">\n                                        下一步\n                                    </button>\n                                </div>\n                            </div>\n                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100 mb-4">\n                                <h4 class="font-medium mb-2 text-blue-800">算法特点：</h4>\n                                <ul class="list-disc list-inside space-y-1 text-blue-700">\n                                    <li>不稳定排序算法：相等元素的相对位置可能会改变</li>\n                                    <li>原地排序：不需要额外的存储空间（除了递归调用栈）</li>\n                                    <li>分治思想：将大问题分解为小问题，逐个解决</li>\n                                    <li>平均情况下高效：平均时间复杂度为O(n log n)</li>\n                                    <li>Cache友好：由于分区操作是局部性的，快速排序对CPU缓存比较友好</li>\n                                </ul>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 复杂度分析 --\x3e\n                        <div class="mb-8" id="complexity-analysis">\n                            <h3 class="text-lg font-medium mb-3 text-primary">复杂度分析</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-gray-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2">时间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base">\n                                        <li>最佳情况：<span class="font-semibold">O(n log n)</span> - 每次划分都将数组均匀地分成两半，递归深度为log n</li>\n                                        <li>平均情况：<span class="font-semibold">O(n log n)</span> - 对于随机排列的数组，每次划分的基准元素都能将数组分成大致相等的两部分</li>\n                                        <li>最坏情况：<span class="font-semibold">O(n²)</span> - 当数组已经排序或逆序时，每次划分都将数组分成一个空数组和一个长度为n-1的数组，递归深度为n</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-gray-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2">空间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base">\n                                        <li>平均情况：<span class="font-semibold">O(log n)</span> - 递归调用栈的深度为log n</li>\n                                        <li>最坏情况：<span class="font-semibold">O(n)</span> - 当数组已经排序或逆序时，递归调用栈的深度为n</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 适用场景 --\x3e\n                        <div id="application-scenarios" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">适用场景</h3>\n                            <p class="mb-3 text-gray-700">快速排序在以下场景中表现出色：</p>\n                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">\n                                <li>大规模数据集的排序，平均效率高</li>\n                                <li>需要原地排序（空间复杂度要求高）的场景</li>\n                                <li>平均情况下需要高效排序的场景</li>\n                                <li>作为许多编程语言标准库中的默认排序算法（如Python的sort()函数）</li>\n                                <li>需要Cache友好的排序算法的场景</li>\n                            </ul>\n                        </div>\n                        \n                        \x3c!-- 算法优缺点 --\x3e\n                        <div id="algorithm-pros-cons" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法优缺点</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-green-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2 text-green-800">优点</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-green-700 text-sm sm:text-base">\n                                        <li>平均情况下效率高，时间复杂度为O(n log n)</li>\n                                        <li>原地排序，不需要额外的存储空间</li>\n                                        <li>Cache友好，对CPU缓存利用率高</li>\n                                        <li>实现灵活，可以根据不同情况选择不同的基准选择策略</li>\n                                        <li>适用于大规模数据排序</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-red-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2 text-red-800">缺点</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-red-700 text-sm sm:text-base">\n                                        <li>不稳定排序，可能改变相等元素的相对位置</li>\n                                        <li>最坏情况下时间复杂度为O(n²)，对于已经排序或逆序的数据效率低下</li>\n                                        <li>递归实现可能导致栈溢出，需要考虑尾递归优化或非递归实现</li>\n                                        <li>基准选择对性能影响较大，需要合理选择基准</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n                    \n                    \x3c!-- 归并排序说明 --\x3e\n                    <div class="algorithm-explanation hidden" data-algorithm="merge">\n                        \x3c!-- 算法信息卡片 --\x3e\n                        <div class="bg-gradient-to-r from-purple-50 to-violet-50 p-4 rounded-lg border border-purple-100 mb-6 shadow-sm">\n                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4">\n                                <div>\n                                    <h4 class="text-xs font-semibold text-purple-600 uppercase tracking-wider mb-1">算法类型</h4>\n                                    <p class="text-sm font-medium text-purple-900 flex items-center gap-1"><i class="fa fa-code-fork text-purple-500"></i> 分治排序</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">稳定性</h4>\n                                    <p class="text-sm font-medium text-green-700">稳定</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最佳时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n log n)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">平均时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n log n)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最坏时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n log n)</p>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 算法原理 --\x3e\n                        <div class="mb-8" id="algorithm-principle">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法原理</h3>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                <strong>归并排序（Merge Sort）</strong>是一种高效的稳定排序算法，由John von Neumann在1945年提出。它采用分治策略，将待排序序列分成若干个子序列，先将每个子序列排序，然后再将已排序的子序列合并成一个有序序列。\n                            </p>\n                            <h4 class="font-medium mb-2 mt-4">排序步骤：</h4>\n                            <div class="step-by-step mb-4">\n                                \x3c!-- 步骤指示器 --\x3e\n                                <div class="flex mb-4 space-x-2">\n                                    <span class="step-indicator active bg-primary text-white rounded-full w-8 h-8 flex items-center justify-center">1</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">2</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">3</span>\n                                </div>\n                                \n                                \x3c!-- 步骤内容 --\x3e\n                                <div class="step-content bg-white p-4 rounded-lg border border-gray-200 shadow-sm mb-4 min-h-[80px]">\n                                    <div class="step-item active">将待排序数组分成两个长度大致相等的子数组；</div>\n                                    <div class="step-item hidden">递归地对两个子数组进行归并排序；</div>\n                                    <div class="step-item hidden">将两个已排序的子数组合并成一个有序数组。</div>\n                                </div>\n                                \n                                \x3c!-- 导航按钮 --\x3e\n                                <div class="flex justify-between">\n                                    <button class="step-nav-btn prev-btn bg-gray-200 text-gray-500 hover:bg-gray-300 px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>\n                                        上一步\n                                    </button>\n                                    <button class="step-nav-btn next-btn bg-primary text-white hover:bg-primary/90 px-4 py-2 rounded-lg">\n                                        下一步\n                                    </button>\n                                </div>\n                            </div>\n                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100 mb-4">\n                                <h4 class="font-medium mb-2 text-blue-800">算法特点：</h4>\n                                <ul class="list-disc list-inside space-y-1 text-blue-700">\n                                    <li>稳定排序算法：相等元素的相对位置不会改变</li>\n                                    <li>分治思想：将大问题分解为小问题，逐个解决</li>\n                                    <li>时间复杂度稳定：无论输入数据如何，时间复杂度都是O(n log n)</li>\n                                    <li>需要额外空间：需要一个与原数组大小相同的临时数组</li>\n                                    <li>适合外部排序：可以处理无法完全加载到内存中的大规模数据</li>\n                                </ul>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 复杂度分析 --\x3e\n                        <div class="mb-8" id="complexity-analysis">\n                            <h3 class="text-lg font-medium mb-3 text-primary">复杂度分析</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-gray-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2">时间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base">\n                                        <li>最佳情况：<span class="font-semibold">O(n log n)</span> - 无论输入数据如何，都需要进行n log n次操作</li>\n                                        <li>平均情况：<span class="font-semibold">O(n log n)</span> - 时间复杂度稳定，不受输入数据影响</li>\n                                        <li>最坏情况：<span class="font-semibold">O(n log n)</span> - 即使输入数据完全逆序，时间复杂度仍为O(n log n)</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-gray-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2">空间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-gray-700 text-sm sm:text-base">\n                                        <li>额外空间：<span class="font-semibold">O(n)</span> - 需要一个与原数组大小相同的临时数组用于合并操作</li>\n                                        <li>递归调用栈：<span class="font-semibold">O(log n)</span> - 递归深度为log n</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 适用场景 --\x3e\n                        <div id="application-scenarios" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">适用场景</h3>\n                            <p class="mb-3 text-gray-700">归并排序在以下场景中特别有用：</p>\n                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">\n                                <li>需要稳定排序的场景，不允许改变相等元素的相对位置</li>\n                                <li>大规模数据集，尤其是在最坏情况下也需要保证O(n log n)性能的场景</li>\n                                <li>外部排序（数据量太大，无法完全加载到内存中）</li>\n                                <li>链表排序，归并排序对链表的排序效率较高</li>\n                                <li>需要保证稳定性能的场景，不受输入数据影响</li>\n                            </ul>\n                        </div>\n                        \n                        \x3c!-- 算法优缺点 --\x3e\n                        <div id="algorithm-pros-cons" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法优缺点</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-green-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2 text-green-800">优点</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-green-700 text-sm sm:text-base">\n                                        <li>时间复杂度稳定，无论输入数据如何都是O(n log n)</li>\n                                        <li>稳定排序，不改变相等元素的相对位置</li>\n                                        <li>适合处理大规模数据，尤其是外部排序</li>\n                                        <li>适合链表排序，效率较高</li>\n                                        <li>分治思想，代码结构清晰，易于理解和实现</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-red-50 p-3 sm:p-4 rounded-lg shadow-sm">\n                                    <h4 class="font-medium mb-2 text-red-800">缺点</h4>\n                                    <ul class="list-disc list-inside space-y-1 sm:space-y-2 text-red-700 text-sm sm:text-base">\n                                        <li>需要额外的存储空间，空间复杂度为O(n)</li>\n                                        <li>对于小规模数据，效率不如插入排序等简单排序算法</li>\n                                        <li>递归实现可能导致栈溢出，需要考虑非递归实现</li>\n                                        <li>合并操作涉及较多的内存拷贝，影响性能</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n                    \n                    \x3c!-- 希尔排序说明 --\x3e\n                    <div class="algorithm-explanation hidden" data-algorithm="shell">\n                        \x3c!-- 算法信息卡片 --\x3e\n                        <div class="bg-gradient-to-r from-cyan-50 to-teal-50 p-4 rounded-lg border border-cyan-100 mb-6 shadow-sm">\n                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4">\n                                <div>\n                                    <h4 class="text-xs font-semibold text-cyan-600 uppercase tracking-wider mb-1">算法类型</h4>\n                                    <p class="text-sm font-medium text-cyan-900 flex items-center gap-1"><i class="fa fa-sliders text-cyan-500"></i> 插入排序</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">稳定性</h4>\n                                    <p class="text-sm font-medium text-red-700">不稳定</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最佳时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n log n)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">平均时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n^1.3)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最坏时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n²)</p>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 算法原理 --\x3e\n                        <div class="mb-8" id="algorithm-principle">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法原理</h3>\n                            <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-100 mb-4">\n                                <h4 class="font-medium mb-2 text-yellow-800">历史背景</h4>\n                                <p class="text-yellow-700">\n                                    希尔排序是由美国计算机科学家Donald Shell在1959年发表的一篇论文《A High-Speed Sorting Procedure》中提出的，因此也被称为Shell排序。它是第一个突破O(n²)时间复杂度的排序算法，为后续更高效排序算法的发展奠定了基础。希尔排序的核心思想是引入了"增量"的概念，通过分组插入排序来减少数据的逆序对，从而提高排序效率。\n                                </p>\n                            </div>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                <strong>希尔排序（Shell Sort）</strong>是插入排序的一种改进版本，也称为缩小增量排序。它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。\n                            </p>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                希尔排序的核心思想是将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行一次直接插入排序。\n                            </p>\n                            <h4 class="font-medium mb-2 mt-4">排序步骤：</h4>\n                            <div class="step-by-step mb-4">\n                                \x3c!-- 步骤指示器 --\x3e\n                                <div class="flex mb-4 space-x-2">\n                                    <span class="step-indicator active bg-primary text-white rounded-full w-8 h-8 flex items-center justify-center">1</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">2</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">3</span>\n                                </div>\n                                \n                                \x3c!-- 步骤内容 --\x3e\n                                <div class="step-content bg-white p-4 rounded-lg border border-gray-200 shadow-sm mb-4 min-h-[80px]">\n                                    <div class="step-item active">选择一个增量序列t1, t2, …, tk，其中ti > tj，tk = 1；</div>\n                                    <div class="step-item hidden">按增量序列个数k，对序列进行k趟排序；</div>\n                                    <div class="step-item hidden">每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子序列进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。</div>\n                                </div>\n                                \n                                \x3c!-- 导航按钮 --\x3e\n                                <div class="flex justify-between">\n                                    <button class="step-nav-btn prev-btn bg-gray-200 text-gray-500 hover:bg-gray-300 px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>\n                                        上一步\n                                    </button>\n                                    <button class="step-nav-btn next-btn bg-primary text-white hover:bg-primary/90 px-4 py-2 rounded-lg">\n                                        下一步\n                                    </button>\n                                </div>\n                            </div>\n                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100 mb-4">\n                                <h4 class="font-medium mb-2 text-blue-800">算法特点：</h4>\n                                <ul class="list-disc list-inside space-y-1 text-blue-700">\n                                    <li>不稳定排序算法：相等元素的相对位置可能会改变</li>\n                                    <li>原地排序：不需要额外的存储空间</li>\n                                    <li>插入排序的改进版本：通过增量序列提高插入排序的效率</li>\n                                    <li>增量序列影响性能：不同的增量序列会导致不同的时间复杂度</li>\n                                    <li>对于中等规模数据效率较高：比简单插入排序快得多</li>\n                                </ul>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 复杂度分析 --\x3e\n                        <div class="mb-8" id="complexity-analysis">\n                            <h3 class="text-lg font-medium mb-3 text-primary">复杂度分析</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-gray-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2">时间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-gray-700">\n                                        <li>最佳情况：<span class="font-semibold">O(n log n)</span> - 取决于增量序列的选择</li>\n                                        <li>平均情况：<span class="font-semibold">O(n^1.3)</span> - 对于常用的增量序列，如希尔增量，平均时间复杂度约为O(n^1.3)</li>\n                                        <li>最坏情况：<span class="font-semibold">O(n^2)</span> - 当增量序列选择不佳时，可能退化为插入排序</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-gray-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2">空间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-gray-700">\n                                        <li>额外空间：<span class="font-semibold">O(1)</span></li>\n                                        <li>原地排序算法，不需要额外的存储空间</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 适用场景 --\x3e\n                        <div id="application-scenarios" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">适用场景</h3>\n                            <p class="mb-3 text-gray-700">希尔排序在以下场景中表现良好：</p>\n                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">\n                                <li>中等规模数据集（通常n在1000到10000之间）</li>\n                                <li>对内存要求较高的场景，需要原地排序算法</li>\n                                <li>嵌入式系统和资源受限环境</li>\n                                <li>需要比简单插入排序更快的场景</li>\n                                <li>教学场景，用于解释插入排序的改进思想</li>\n                            </ul>\n                        </div>\n                        \n                        \x3c!-- 算法优缺点 --\x3e\n                        <div id="algorithm-pros-cons" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法优缺点</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-green-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2 text-green-800">优点</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-green-700">\n                                        <li>原地排序，不需要额外的存储空间</li>\n                                        <li>对于中等规模数据，效率比插入排序高得多</li>\n                                        <li>实现简单，代码结构清晰</li>\n                                        <li>适用于嵌入式系统和资源受限环境</li>\n                                        <li>可以根据不同数据规模选择合适的增量序列</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-red-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2 text-red-800">缺点</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-red-700">\n                                        <li>不稳定排序，可能改变相等元素的相对位置</li>\n                                        <li>时间复杂度依赖于增量序列的选择，不同增量序列性能差异较大</li>\n                                        <li>对于大规模数据，效率不如快速排序、归并排序等O(n log n)算法</li>\n                                        <li>增量序列的选择缺乏理论指导，主要依赖经验</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n                    \n                    \x3c!-- 堆排序说明 --\x3e\n                    <div class="algorithm-explanation hidden" data-algorithm="heap">\n                        \x3c!-- 算法信息卡片 --\x3e\n                        <div class="bg-gradient-to-r from-amber-50 to-yellow-50 p-4 rounded-lg border border-amber-100 mb-6 shadow-sm">\n                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4">\n                                <div>\n                                    <h4 class="text-xs font-semibold text-amber-600 uppercase tracking-wider mb-1">算法类型</h4>\n                                    <p class="text-sm font-medium text-amber-900 flex items-center gap-1"><i class="fa fa-cubes text-amber-500"></i> 选择排序</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">稳定性</h4>\n                                    <p class="text-sm font-medium text-red-700">不稳定</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最佳时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n log n)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">平均时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n log n)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最坏时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n log n)</p>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 算法原理 --\x3e\n                        <div class="mb-8" id="algorithm-principle">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法原理</h3>\n                            <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-100 mb-4">\n                                <h4 class="font-medium mb-2 text-yellow-800">历史背景</h4>\n                                <p class="text-yellow-700">\n                                    堆排序算法是由J. W. J. Williams在1964年提出的，他同时发明了二叉堆数据结构。堆排序的思想来源于选择排序，但通过使用堆数据结构来高效地选择最大（或最小）元素，从而将时间复杂度从O(n²)降低到O(n log n)。堆排序在许多编程语言的标准库中都有实现，尤其是在需要原地排序和最坏情况性能保证的场景中。\n                                </p>\n                            </div>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                <strong>堆排序（Heap Sort）</strong>是一种基于比较的排序算法，利用堆这种数据结构来进行排序。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。\n                            </p>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                堆排序的基本思想是将待排序序列构造成一个大顶堆（或小顶堆），然后将堆顶元素与末尾元素交换，再重新调整堆结构，如此反复执行，直到整个序列有序。\n                            </p>\n                            <h4 class="font-medium mb-2 mt-4">排序步骤：</h4>\n                            <div class="step-by-step mb-4">\n                                \x3c!-- 步骤指示器 --\x3e\n                                <div class="flex mb-4 space-x-2">\n                                    <span class="step-indicator active bg-primary text-white rounded-full w-8 h-8 flex items-center justify-center">1</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">2</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">3</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">4</span>\n                                </div>\n                                \n                                \x3c!-- 步骤内容 --\x3e\n                                <div class="step-content bg-white p-4 rounded-lg border border-gray-200 shadow-sm mb-4 min-h-[80px]">\n                                    <div class="step-item active">将待排序序列构造成一个大顶堆；</div>\n                                    <div class="step-item hidden">将堆顶元素（最大值）与末尾元素交换，此时末尾为最大值；</div>\n                                    <div class="step-item hidden">将剩余n-1个元素重新构造成一个大顶堆；</div>\n                                    <div class="step-item hidden">重复步骤2~3，直到整个序列有序。</div>\n                                </div>\n                                \n                                \x3c!-- 导航按钮 --\x3e\n                                <div class="flex justify-between">\n                                    <button class="step-nav-btn prev-btn bg-gray-200 text-gray-500 hover:bg-gray-300 px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>\n                                        上一步\n                                    </button>\n                                    <button class="step-nav-btn next-btn bg-primary text-white hover:bg-primary/90 px-4 py-2 rounded-lg">\n                                        下一步\n                                    </button>\n                                </div>\n                            </div>\n                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100 mb-4">\n                                <h4 class="font-medium mb-2 text-blue-800">算法特点：</h4>\n                                <ul class="list-disc list-inside space-y-1 text-blue-700">\n                                    <li>不稳定排序算法：相等元素的相对位置可能会改变</li>\n                                    <li>原地排序：不需要额外的存储空间</li>\n                                    <li>基于堆数据结构：利用堆的性质进行排序</li>\n                                    <li>时间复杂度稳定：无论输入数据如何，时间复杂度都是O(n log n)</li>\n                                    <li>适合大规模数据：在最坏情况下也能保持O(n log n)的时间复杂度</li>\n                                </ul>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 复杂度分析 --\x3e\n                        <div class="mb-8" id="complexity-analysis">\n                            <h3 class="text-lg font-medium mb-3 text-primary">复杂度分析</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-gray-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2">时间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-gray-700">\n                                        <li>最佳情况：<span class="font-semibold">O(n log n)</span> - 无论输入数据如何，都需要进行n log n次操作</li>\n                                        <li>平均情况：<span class="font-semibold">O(n log n)</span> - 时间复杂度稳定，不受输入数据影响</li>\n                                        <li>最坏情况：<span class="font-semibold">O(n log n)</span> - 即使输入数据完全逆序，时间复杂度仍为O(n log n)</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-gray-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2">空间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-gray-700">\n                                        <li>额外空间：<span class="font-semibold">O(1)</span></li>\n                                        <li>原地排序算法，不需要额外的存储空间</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 适用场景 --\x3e\n                        <div id="application-scenarios" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">适用场景</h3>\n                            <p class="mb-3 text-gray-700">堆排序在以下场景中表现良好：</p>\n                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">\n                                <li>需要找出最大或最小元素的场景</li>\n                                <li>大规模数据排序，尤其是在最坏情况下也需要保证O(n log n)性能的场景</li>\n                                <li>内存有限的环境，因为它是原地排序算法</li>\n                                <li>作为优先队列的实现基础</li>\n                                <li>需要稳定性能的场景，不受输入数据影响</li>\n                            </ul>\n                        </div>\n                        \n                        \x3c!-- 算法优缺点 --\x3e\n                        <div id="algorithm-pros-cons" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法优缺点</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-green-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2 text-green-800">优点</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-green-700">\n                                        <li>时间复杂度稳定，无论输入数据如何都是O(n log n)</li>\n                                        <li>原地排序，不需要额外的存储空间</li>\n                                        <li>适合大规模数据排序</li>\n                                        <li>可以高效地找出最大或最小元素</li>\n                                        <li>适用于优先队列的实现</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-red-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2 text-red-800">缺点</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-red-700">\n                                        <li>不稳定排序，可能改变相等元素的相对位置</li>\n                                        <li>对于小规模数据，效率不如插入排序等简单排序算法</li>\n                                        <li>堆调整操作比较复杂，实现难度较大</li>\n                                        <li>Cache不友好，因为堆排序的访问模式不是局部性的</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n                    \n                    \x3c!-- 计数排序说明 --\x3e\n                    <div class="algorithm-explanation hidden" data-algorithm="counting">\n                        \x3c!-- 算法信息卡片 --\x3e\n                        <div class="bg-gradient-to-r from-cyan-50 to-teal-50 p-4 rounded-lg border border-cyan-100 mb-6 shadow-sm">\n                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4">\n                                <div>\n                                    <h4 class="text-xs font-semibold text-cyan-600 uppercase tracking-wider mb-1">算法类型</h4>\n                                    <p class="text-sm font-medium text-cyan-900 flex items-center gap-1"><i class="fa fa-bar-chart text-cyan-500"></i> 非比较排序</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">稳定性</h4>\n                                    <p class="text-sm font-medium text-green-700">稳定</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最佳时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n+k)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">平均时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n+k)</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最坏时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(n+k)</p>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 算法原理 --\x3e\n                        <div class="mb-8" id="algorithm-principle">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法原理</h3>\n                            <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-100 mb-4">\n                                <h4 class="font-medium mb-2 text-yellow-800">历史背景</h4>\n                                <p class="text-yellow-700">\n                                    计数排序的思想可以追溯到早期的统计学和数据处理方法。虽然无法确定具体的发明者，但它在20世纪50年代就已经被计算机科学家们广泛研究和应用。计数排序是最早的线性时间排序算法之一，它的出现展示了非比较排序算法的潜力，可以突破比较排序算法O(n log n)的时间复杂度下限。\n                                </p>\n                            </div>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                <strong>计数排序（Counting Sort）</strong>是一种非比较型整数排序算法，其核心思想是将输入的数据值转化为键存储在额外开辟的数组空间中。计数排序的主要优点是其时间复杂度为O(n+k)，其中n是待排序元素的个数，k是待排序元素的范围，当k不是很大时，计数排序的效率很高。\n                            </p>\n                            <h4 class="font-medium mb-2 mt-4">排序步骤：</h4>\n                            <div class="step-by-step mb-4">\n                                \x3c!-- 步骤指示器 --\x3e\n                                <div class="flex mb-4 space-x-2">\n                                    <span class="step-indicator active bg-primary text-white rounded-full w-8 h-8 flex items-center justify-center">1</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">2</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">3</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">4</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">5</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">6</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">7</span>\n                                </div>\n                                \n                                \x3c!-- 步骤内容 --\x3e\n                                <div class="step-content bg-white p-4 rounded-lg border border-gray-200 shadow-sm mb-4 min-h-[80px]">\n                                    <div class="step-item active">找出待排序数组中的最大值max和最小值min；</div>\n                                    <div class="step-item hidden">创建一个计数数组count，长度为max-min+1，用于统计每个元素出现的次数；</div>\n                                    <div class="step-item hidden">遍历待排序数组，将每个元素出现的次数记录到计数数组的对应位置；</div>\n                                    <div class="step-item hidden">计算累积计数：从count数组的第一个元素开始，每一个元素等于它本身加上前一个元素；</div>\n                                    <div class="step-item hidden">创建输出数组output，长度与待排序数组相同；</div>\n                                    <div class="step-item hidden">从后向前遍历待排序数组，根据累积计数count数组找到每个元素在output数组中的位置，将元素放入output数组，并将count数组中对应位置的值减1；</div>\n                                    <div class="step-item hidden">将output数组复制到原数组，完成排序。</div>\n                                </div>\n                                \n                                \x3c!-- 导航按钮 --\x3e\n                                <div class="flex justify-between">\n                                    <button class="step-nav-btn prev-btn bg-gray-200 text-gray-500 hover:bg-gray-300 px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>\n                                        上一步\n                                    </button>\n                                    <button class="step-nav-btn next-btn bg-primary text-white hover:bg-primary/90 px-4 py-2 rounded-lg">\n                                        下一步\n                                    </button>\n                                </div>\n                            </div>\n                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100 mb-4">\n                                <h4 class="font-medium mb-2 text-blue-800">算法特点：</h4>\n                                <ul class="list-disc list-inside space-y-1 text-blue-700">\n                                    <li>稳定排序算法：相等元素的相对位置不会改变</li>\n                                    <li>非比较型排序：不通过比较元素大小进行排序</li>\n                                    <li>线性时间复杂度：在数据范围不大的情况下，时间复杂度为O(n+k)</li>\n                                    <li>需要额外空间：空间复杂度为O(n+k)</li>\n                                    <li>适合整数排序：尤其是已知范围的整数排序</li>\n                                </ul>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 复杂度分析 --\x3e\n                        <div class="mb-8" id="complexity-analysis">\n                            <h3 class="text-lg font-medium mb-3 text-primary">复杂度分析</h3>\n                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">\n                                <div class="bg-gray-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2">时间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-gray-700">\n                                        <li>最佳情况：<span class="font-semibold">O(n+k)</span> - 无论输入数据如何，都需要遍历数组和计数数组</li>\n                                        <li>平均情况：<span class="font-semibold">O(n+k)</span> - 时间复杂度稳定，与输入数据分布无关</li>\n                                        <li>最坏情况：<span class="font-semibold">O(n+k)</span> - 即使输入数据完全逆序，时间复杂度仍为O(n+k)</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-gray-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2">空间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-gray-700">\n                                        <li>额外空间：<span class="font-semibold">O(n+k)</span></li>\n                                        <li>需要一个计数数组（大小为k）和一个输出数组（大小为n）</li>\n                                        <li>空间复杂度与数据范围k密切相关</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 适用场景 --\x3e\n                        <div id="application-scenarios" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">适用场景</h3>\n                            <p class="mb-3 text-gray-700">计数排序在以下场景中表现良好：</p>\n                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">\n                                <li>已知范围的整数排序，尤其是当数据范围不大时（k << n）</li>\n                                <li>作为基数排序的子过程，用于处理每一位的排序</li>\n                                <li>统计排序、频率排序等场景，需要统计元素出现次数</li>\n                                <li>对大量重复元素进行排序，例如对年龄、成绩、身高体重等数据进行排序</li>\n                                <li>需要稳定排序且时间复杂度要求较高的场景</li>\n                            </ul>\n                        </div>\n                        \n                        \x3c!-- 算法优缺点 --\x3e\n                        <div id="algorithm-pros-cons" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法优缺点</h3>\n                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">\n                                <div class="bg-green-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2 text-green-800">优点</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-green-700">\n                                        <li>线性时间复杂度，当k不大时，效率极高</li>\n                                        <li>稳定排序，不改变相等元素的相对位置</li>\n                                        <li>实现简单，代码结构清晰</li>\n                                        <li>适合处理大量重复元素</li>\n                                        <li>非比较型排序，不受比较排序O(n log n)下界限制</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-red-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2 text-red-800">缺点</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-red-700">\n                                        <li>只适用于整数排序，不适合浮点数或字符串排序</li>\n                                        <li>当数据范围k很大时，空间复杂度会很高</li>\n                                        <li>需要额外的存储空间，不是原地排序</li>\n                                        <li>对于稀疏数据，空间利用率低</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n                    \n                    \x3c!-- 基数排序说明 --\x3e\n                    <div class="algorithm-explanation hidden" data-algorithm="radix">\n                        \x3c!-- 算法信息卡片 --\x3e\n                        <div class="bg-gradient-to-r from-fuchsia-50 to-purple-50 p-4 rounded-lg border border-fuchsia-100 mb-6 shadow-sm">\n                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4">\n                                <div>\n                                    <h4 class="text-xs font-semibold text-fuchsia-600 uppercase tracking-wider mb-1">算法类型</h4>\n                                    <p class="text-sm font-medium text-fuchsia-900 flex items-center gap-1"><i class="fa fa-sort-numeric-asc text-fuchsia-500"></i> 非比较排序</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">稳定性</h4>\n                                    <p class="text-sm font-medium text-green-700">稳定</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最佳时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(d*(n+k))</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">平均时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(d*(n+k))</p>\n                                </div>\n                                <div>\n                                    <h4 class="text-xs font-semibold text-blue-600 uppercase tracking-wider mb-1">最坏时间</h4>\n                                    <p class="text-sm font-medium text-blue-900">O(d*(n+k))</p>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 算法原理 --\x3e\n                        <div class="mb-8" id="algorithm-principle">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法原理</h3>\n                            <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-100 mb-4">\n                                <h4 class="font-medium mb-2 text-yellow-800">历史背景</h4>\n                                <p class="text-yellow-700">\n                                    基数排序的思想可以追溯到19世纪末的制表机时代，当时赫尔曼·霍列瑞斯（Herman Hollerith）发明的制表机就使用了类似的原理来处理人口普查数据。在计算机科学中，基数排序的现代形式是由Harold H. Seward于1954年提出的。基数排序是一种高效的非比较排序算法，特别适合处理大规模的整数数据。\n                                </p>\n                            </div>\n                            <p class="mb-4 text-gray-700 leading-relaxed">\n                                <strong>基数排序（Radix Sort）</strong>是一种非比较型整数排序算法，它按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。基数排序的核心思想是将整数按位数切割成不同的数字，然后按每个位数分别比较。\n                            </p>\n                            <h4 class="font-medium mb-2 mt-4">排序步骤：</h4>\n                            <div class="step-by-step mb-4">\n                                \x3c!-- 步骤指示器 --\x3e\n                                <div class="flex mb-4 space-x-2">\n                                    <span class="step-indicator active bg-primary text-white rounded-full w-8 h-8 flex items-center justify-center">1</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">2</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">3</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">4</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">5</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">6</span>\n                                    <span class="step-indicator bg-gray-200 text-gray-500 rounded-full w-8 h-8 flex items-center justify-center">7</span>\n                                </div>\n                                \n                                \x3c!-- 步骤内容 --\x3e\n                                <div class="step-content bg-white p-4 rounded-lg border border-gray-200 shadow-sm mb-4 min-h-[80px]">\n                                    <div class="step-item active">找出待排序数组中的最大值，确定排序的最大位数d；</div>\n                                    <div class="step-item hidden">从最低位（个位）开始，对每一位进行计数排序：</div>\n                                    <div class="step-item hidden">对于当前位，创建10个桶（0-9）；</div>\n                                    <div class="step-item hidden">遍历待排序数组，将每个元素放入对应的桶中，根据当前位的值决定放入哪个桶；</div>\n                                    <div class="step-item hidden">将所有桶中的元素按照桶的顺序依次取出，重新组成数组；</div>\n                                    <div class="step-item hidden">将位数指针向前移动一位（十位、百位、千位...），重复步骤2-5，直到处理完最高位；</div>\n                                    <div class="step-item hidden">当所有位数都处理完毕后，数组排序完成。</div>\n                                </div>\n                                \n                                \x3c!-- 导航按钮 --\x3e\n                                <div class="flex justify-between">\n                                    <button class="step-nav-btn prev-btn bg-gray-200 text-gray-500 hover:bg-gray-300 px-4 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>\n                                        上一步\n                                    </button>\n                                    <button class="step-nav-btn next-btn bg-primary text-white hover:bg-primary/90 px-4 py-2 rounded-lg">\n                                        下一步\n                                    </button>\n                                </div>\n                            </div>\n                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100 mb-4">\n                                <h4 class="font-medium mb-2 text-blue-800">算法特点：</h4>\n                                <ul class="list-disc list-inside space-y-1 text-blue-700">\n                                    <li>稳定排序算法：相等元素的相对位置不会改变</li>\n                                    <li>非比较型排序：不通过比较元素大小进行排序</li>\n                                    <li>多关键字排序：按照不同位数（或关键字）依次排序</li>\n                                    <li>时间复杂度与位数相关：时间复杂度为O(d*(n+k))</li>\n                                    <li>需要额外空间：空间复杂度为O(n+k)</li>\n                                </ul>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 复杂度分析 --\x3e\n                        <div class="mb-8" id="complexity-analysis">\n                            <h3 class="text-lg font-medium mb-3 text-primary">复杂度分析</h3>\n                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">\n                                <div class="bg-gray-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2">时间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-gray-700">\n                                        <li>最佳情况：<span class="font-semibold">O(d*(n+k))</span> - 其中d是最大数的位数，k是基数（通常为10）</li>\n                                        <li>平均情况：<span class="font-semibold">O(d*(n+k))</span> - 时间复杂度稳定，与输入数据分布无关</li>\n                                        <li>最坏情况：<span class="font-semibold">O(d*(n+k))</span> - 即使输入数据完全逆序，时间复杂度仍为O(d*(n+k))</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-gray-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2">空间复杂度</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-gray-700">\n                                        <li>额外空间：<span class="font-semibold">O(n+k)</span></li>\n                                        <li>需要一个输出数组（大小为n）和一个计数数组（大小为k）</li>\n                                        <li>空间复杂度与基数k密切相关，通常k=10</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 适用场景 --\x3e\n                        <div id="application-scenarios" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">适用场景</h3>\n                            <p class="mb-3 text-gray-700">基数排序在以下场景中表现良好：</p>\n                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">\n                                <li>整数排序，尤其是位数不是很多的情况（d较小）</li>\n                                <li>对电话号码、身份证号等长整数进行排序</li>\n                                <li>作为字符串排序的一种方法，例如字典排序</li>\n                                <li>大规模数据排序，例如数据库中的数据排序、搜索引擎中的关键词排序等</li>\n                                <li>需要稳定排序且时间复杂度要求较高的场景</li>\n                            </ul>\n                        </div>\n                        \n                        \x3c!-- 算法优缺点 --\x3e\n                        <div id="algorithm-pros-cons" class="mb-8">\n                            <h3 class="text-lg font-medium mb-3 text-primary">算法优缺点</h3>\n                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">\n                                <div class="bg-green-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2 text-green-800">优点</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-green-700">\n                                        <li>稳定排序，不改变相等元素的相对位置</li>\n                                        <li>线性时间复杂度，当d和k不大时，效率极高</li>\n                                        <li>非比较型排序，不受比较排序O(n log n)下界限制</li>\n                                        <li>适合处理大量数据，尤其是位数固定的数据</li>\n                                        <li>实现简单，代码结构清晰</li>\n                                    </ul>\n                                </div>\n                                <div class="bg-red-50 p-4 rounded-lg">\n                                    <h4 class="font-medium mb-2 text-red-800">缺点</h4>\n                                    <ul class="list-disc list-inside space-y-2 text-red-700">\n                                        <li>只适用于整数或可以转换为整数的类型排序</li>\n                                        <li>当数据范围很大且位数d很多时，时间复杂度会增加</li>\n                                        <li>需要额外的存储空间，不是原地排序</li>\n                                        <li>对于浮点数排序，需要特殊处理</li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n                    \n                    </div>\n                    \n                    \x3c!-- 排序算法代码实现 --\x3e\n                    <div class="mt-12" id="code-implementation">\n                        <h3 class="text-lg font-medium mb-3 text-primary">排序算法代码实现</h3>\n                        \n                        \x3c!-- 语言标签页 --\x3e\n                        <div class="border-b border-gray-200 mb-4">\n                            <div class="flex overflow-x-auto space-x-1 md:space-x-4">\n                                <button class="code-tab py-2 px-4 border-b-2 border-primary text-primary font-medium" data-lang="c">C</button>\n                                <button class="code-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-lang="python">Python</button>\n                                <button class="code-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-lang="go">Go</button>\n                                <button class="code-tab py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-lang="java">Java</button>\n                            </div>\n                        </div>\n                        \n                        \x3c!-- 代码内容区域 --\x3e\n                        <div class="code-content">\n                            \x3c!-- 冒泡排序代码 --\x3e\n                            <div class="algorithm-content" data-algorithm="bubble">\n                                \x3c!-- C代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>void bubbleSort(int arr[], int n) {\n    int i, j;\n    for (i = 0; i &lt; n-1; i++) {\n        // 最后i个元素已经就位\n        for (j = 0; j &lt; n-i-1; j++) {\n            // 从0到n-i-1遍历\n            if (arr[j] &gt; arr[j+1]) {\n                // 交换元素\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Python代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def bubble_sort(arr):\n    n = len(arr)\n    # 遍历所有数组元素\n    for i in range(n):\n        # 最后i个元素已经就位\n        for j in range(0, n-i-1):\n            # 从0到n-i-1遍历\n            if arr[j] &gt; arr[j+1]:\n                # 交换元素\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr</code></pre>\n                                </div>\n                                \n                                \x3c!-- Go代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func bubbleSort(arr []int) {\n    n := len(arr)\n    for i := 0; i &lt; n-1; i++ {\n        // 最后i个元素已经就位\n        for j := 0; j &lt; n-i-1; j++ {\n            // 从0到n-i-1遍历\n            if arr[j] &gt; arr[j+1] {\n                // 交换元素\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n            }\n        }\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Java代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class BubbleSort {\n    void bubbleSort(int arr[]) {\n        int n = arr.length;\n        for (int i = 0; i &lt; n-1; i++) {\n            // 最后i个元素已经就位\n            for (int j = 0; j &lt; n-i-1; j++) {\n                // 从0到n-i-1遍历\n                if (arr[j] &gt; arr[j+1]) {\n                    // 交换元素\n                    int temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n}</code></pre>\n                                </div>\n                            </div>\n                            \n                            \x3c!-- 选择排序代码 --\x3e\n                            <div class="algorithm-content hidden" data-algorithm="selection">\n                                \x3c!-- C代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>void selectionSort(int arr[], int n) {\n    int i, j, min_idx;\n    \n    // 一个一个地将未排序部分的最小元素放到已排序部分的末尾\n    for (i = 0; i &lt; n-1; i++) {\n        // 找到未排序部分中的最小元素\n        min_idx = i;\n        for (j = i+1; j &lt; n; j++)\n            if (arr[j] &lt; arr[min_idx])\n                min_idx = j;\n        \n        // 将找到的最小元素与第一个元素交换\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Python代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def selection_sort(arr):\n    n = len(arr)\n    \n    # 一个一个地将未排序部分的最小元素放到已排序部分的末尾\n    for i in range(n):\n        # 找到未排序部分中的最小元素\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] &lt; arr[min_idx]:\n                min_idx = j\n                \n        # 将找到的最小元素与第一个元素交换\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n        \n    return arr</code></pre>\n                                </div>\n                                \n                                \x3c!-- Go代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func selectionSort(arr []int) {\n    n := len(arr)\n    \n    // 一个一个地将未排序部分的最小元素放到已排序部分的末尾\n    for i := 0; i < n-1; i++ {\n        // 找到未排序部分中的最小元素\n        min_idx := i\n        for j := i + 1; j < n; j++ {\n            if arr[j] < arr[min_idx] {\n                min_idx = j\n            }\n        }\n        \n        // 将找到的最小元素与第一个元素交换\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Java代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class SelectionSort {\n    void selectionSort(int arr[]) {\n        int n = arr.length;\n        \n        // 一个一个地将未排序部分的最小元素放到已排序部分的末尾\n        for (int i = 0; i < n-1; i++) {\n            // 找到未排序部分中的最小元素\n            int min_idx = i;\n            for (int j = i+1; j < n; j++)\n                if (arr[j] < arr[min_idx])\n                    min_idx = j;\n            \n            // 将找到的最小元素与第一个元素交换\n            int temp = arr[min_idx];\n            arr[min_idx] = arr[i];\n            arr[i] = temp;\n        }\n    }\n}</code></pre>\n                                </div>\n                            </div>\n                            \n                            \x3c!-- 插入排序代码 --\x3e\n                            <div class="algorithm-content hidden" data-algorithm="insertion">\n                                \x3c!-- C代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>void insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n        \n        /* 将arr[0..i-1]中所有大于key的元素向后移动一位 */\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Python代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def insertion_sort(arr):\n    # 遍历从1到数组长度-1的元素\n    for i in range(1, len(arr)):\n        key = arr[i]\n        # 将arr[i]放到已排序序列中的正确位置\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr</code></pre>\n                                </div>\n                                \n                                \x3c!-- Go代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func insertionSort(arr []int) {\n    n := len(arr)\n    for i := 1; i < n; i++ {\n        key := arr[i]\n        j := i - 1\n        \n        // 将arr[0..i-1]中所有大于key的元素向后移动一位\n        for j >= 0 && arr[j] > key {\n            arr[j+1] = arr[j]\n            j--\n        }\n        arr[j+1] = key\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Java代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class InsertionSort {\n    void insertionSort(int arr[]) {\n        int n = arr.length;\n        for (int i = 1; i < n; ++i) {\n            int key = arr[i];\n            int j = i - 1;\n \n            /* 将arr[0..i-1]中所有大于key的元素向后移动一位 */\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n}</code></pre>\n                                </div>\n                            </div>\n                            \n                            \x3c!-- 快速排序代码 --\x3e\n                            <div class="algorithm-content hidden" data-algorithm="quick">\n                                \x3c!-- C代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 交换两个元素\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n \n// 将数组分区的函数\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; // 选择最右边的元素作为基准\n    int i = (low - 1); // 小于基准的元素的索引\n    \n    for (int j = low; j <= high - 1; j++) {\n        // 如果当前元素小于或等于基准\n        if (arr[j] <= pivot) {\n            i++; // 增加小于基准的元素的索引\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n \n// 快速排序的主要函数\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        // pi是分区的索引，arr[pi]现在在正确的位置\n        int pi = partition(arr, low, high);\n        \n        // 分别对分区前后的子数组进行排序\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Python代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def quick_sort(arr, low, high):\n    if low < high:\n        # pi是分区的索引，arr[pi]现在在正确的位置\n        pi = partition(arr, low, high)\n        \n        # 分别对分区前后的子数组进行排序\n        quick_sort(arr, low, pi - 1)\n        quick_sort(arr, pi + 1, high)\n        \ndef partition(arr, low, high):\n    # 选择最右边的元素作为基准\n    pivot = arr[high]\n    \n    # 小于基准的元素的索引\n    i = low - 1\n    \n    for j in range(low, high):\n        # 如果当前元素小于或等于基准\n        if arr[j] <= pivot:\n            # 增加小于基准的元素的索引\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1</code></pre>\n                                </div>\n                                \n                                \x3c!-- Go代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func quickSort(arr []int, low, high int) {\n    if low < high {\n        // pi是分区的索引，arr[pi]现在在正确的位置\n        pi := partition(arr, low, high)\n        \n        // 分别对分区前后的子数组进行排序\n        quickSort(arr, low, pi-1)\n        quickSort(arr, pi+1, high)\n    }\n}\n\nfunc partition(arr []int, low, high int) int {\n    // 选择最右边的元素作为基准\n    pivot := arr[high]\n    \n    // 小于基准的元素的索引\n    i := low - 1\n    \n    for j := low; j < high; j++ {\n        // 如果当前元素小于或等于基准\n        if arr[j] <= pivot {\n            // 增加小于基准的元素的索引\n            i++\n            arr[i], arr[j] = arr[j], arr[i]\n        }\n    }\n    \n    arr[i+1], arr[high] = arr[high], arr[i+1]\n    return i + 1\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Java代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class QuickSort {\n    /* 交换两个元素 */\n    void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n \n    /* 将数组分区的函数 */\n    int partition(int[] arr, int low, int high) {\n        int pivot = arr[high]; // 选择最右边的元素作为基准\n        int i = (low - 1); // 小于基准的元素的索引\n \n        for (int j = low; j <= high - 1; j++) {\n            // 如果当前元素小于或等于基准\n            if (arr[j] <= pivot) {\n                i++; // 增加小于基准的元素的索引\n                swap(arr, i, j);\n            }\n        }\n        swap(arr, i + 1, high);\n        return (i + 1);\n    }\n \n    /* 快速排序的主要函数 */\n    void quickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            // pi是分区的索引，arr[pi]现在在正确的位置\n            int pi = partition(arr, low, high);\n \n            // 分别对分区前后的子数组进行排序\n            quickSort(arr, low, pi - 1);\n            quickSort(arr, pi + 1, high);\n        }\n    }\n}</code></pre>\n                                </div>\n                            </div>\n                            \n                            \x3c!-- 归并排序代码 --\x3e\n                            <div class="algorithm-content hidden" data-algorithm="merge">\n                                \x3c!-- C代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 合并两个子数组arr[l..m]和arr[m+1..r]\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    \n    // 创建临时数组\n    int L[n1], R[n2];\n    \n    // 复制数据到临时数组L[]和R[]\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n    \n    // 合并临时数组回arr[l..r]\n    i = 0; // 初始索引L[]\n    j = 0; // 初始索引R[]\n    k = l; // 初始索引合并的子数组\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    \n    // 复制L[]的剩余元素（如果有）\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    \n    // 复制R[]的剩余元素（如果有）\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// l是第一个索引，r是最后一个索引要排序的子数组\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        // 与(l+r)/2相同，但避免了整数溢出\n        int m = l + (r - l) / 2;\n        \n        // 排序前半部分和后半部分\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        \n        // 合并已排序的部分\n        merge(arr, l, m, r);\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Python代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def merge_sort(arr, l, r):\n    if l < r:\n        # 与(l+r)//2相同，但避免了整数溢出\n        m = l + (r - l) // 2\n        \n        # 排序前半部分和后半部分\n        merge_sort(arr, l, m)\n        merge_sort(arr, m + 1, r)\n        \n        # 合并已排序的部分\n        merge(arr, l, m, r)\n        \ndef merge(arr, l, m, r):\n    n1 = m - l + 1\n    n2 = r - m\n    \n    # 创建临时数组\n    L = [0] * (n1)\n    R = [0] * (n2)\n    \n    # 复制数据到临时数组L[]和R[]\n    for i in range(0, n1):\n        L[i] = arr[l + i]\n        \n    for j in range(0, n2):\n        R[j] = arr[m + 1 + j]\n        \n    # 合并临时数组回arr[l..r]\n    i = 0     # 初始索引L[]\n    j = 0     # 初始索引R[]\n    k = l     # 初始索引合并的子数组\n    \n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n        \n    # 复制L[]的剩余元素（如果有）\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n        \n    # 复制R[]的剩余元素（如果有）\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1</code></pre>\n                                </div>\n                                \n                                \x3c!-- Go代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func mergeSort(arr []int, l, r int) {\n    if l < r {\n        // 与(l+r)/2相同，但避免了整数溢出\n        m := l + (r - l) / 2\n        \n        // 排序前半部分和后半部分\n        mergeSort(arr, l, m)\n        mergeSort(arr, m+1, r)\n        \n        // 合并已排序的部分\n        merge(arr, l, m, r)\n    }\n}\n\nfunc merge(arr []int, l, m, r int) {\n    n1 := m - l + 1\n    n2 := r - m\n    \n    // 创建临时数组\n    L := make([]int, n1)\n    R := make([]int, n2)\n    \n    // 复制数据到临时数组L[]和R[]\n    for i := 0; i < n1; i++ {\n        L[i] = arr[l+i]\n    }\n    for j := 0; j < n2; j++ {\n        R[j] = arr[m+1+j]\n    }\n    \n    // 合并临时数组回arr[l..r]\n    i := 0 // 初始索引L[]\n    j := 0 // 初始索引R[]\n    k := l // 初始索引合并的子数组\n    \n    for i < n1 && j < n2 {\n        if L[i] <= R[j] {\n            arr[k] = L[i]\n            i++\n        } else {\n            arr[k] = R[j]\n            j++\n        }\n        k++\n    }\n    \n    // 复制L[]的剩余元素（如果有）\n    for i < n1 {\n        arr[k] = L[i]\n        i++\n        k++\n    }\n    \n    // 复制R[]的剩余元素（如果有）\n    for j < n2 {\n        arr[k] = R[j]\n        j++\n        k++\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Java代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class MergeSort {\n    // 合并两个子数组arr[l..m]和arr[m+1..r]\n    void merge(int arr[], int l, int m, int r) {\n        // 找到两个子数组的大小\n        int n1 = m - l + 1;\n        int n2 = r - m;\n \n        // 创建临时数组\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n \n        // 复制数据到临时数组\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n \n        // 合并临时数组\n \n        // 初始索引第一个和第二个子数组\n        int i = 0, j = 0;\n \n        // 合并子数组的初始索引\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n \n        // 复制L[]的剩余元素（如果有）\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n \n        // 复制R[]的剩余元素（如果有）\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n \n    // 主函数，用于排序arr[l..r]\n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            // 找到中点\n            int m = l + (r - l) / 2;\n \n            // 排序前半部分和后半部分\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n \n            // 合并已排序的部分\n            merge(arr, l, m, r);\n        }\n    }\n}</code></pre>\n                                </div>\n                            </div>\n                            \n                            \x3c!-- 希尔排序代码 --\x3e\n                            <div class="algorithm-content hidden" data-algorithm="shell">\n                                \x3c!-- C代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 希尔排序实现\nvoid shellSort(int arr[], int n) {\n    // 初始步长为数组长度的一半，然后逐渐减小步长\n    for (int gap = n/2; gap > 0; gap /= 2) {\n        // 对每个步长组进行插入排序\n        for (int i = gap; i < n; i++) {\n            // 保存当前元素\n            int temp = arr[i];\n            int j;\n            // 插入排序当前步长组\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n                arr[j] = arr[j - gap];\n            }\n            // 将当前元素插入到正确位置\n            arr[j] = temp;\n        }\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Python代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def shell_sort(arr):\n    n = len(arr)\n    # 初始步长为数组长度的一半，然后逐渐减小步长\n    gap = n // 2\n    \n    while gap > 0:\n        # 对每个步长组进行插入排序\n        for i in range(gap, n):\n            # 保存当前元素\n            temp = arr[i]\n            j = i\n            # 插入排序当前步长组\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # 将当前元素插入到正确位置\n            arr[j] = temp\n        # 减小步长\n        gap //= 2\n    \n    return arr</code></pre>\n                                </div>\n                                \n                                \x3c!-- Go代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>func shellSort(arr []int) {\n    n := len(arr)\n    // 初始步长为数组长度的一半，然后逐渐减小步长\n    for gap := n / 2; gap > 0; gap /= 2 {\n        // 对每个步长组进行插入排序\n        for i := gap; i < n; i++ {\n            // 保存当前元素\n            temp := arr[i]\n            j := i\n            // 插入排序当前步长组\n            for j >= gap && arr[j - gap] > temp {\n                arr[j] = arr[j - gap]\n                j -= gap\n            }\n            // 将当前元素插入到正确位置\n            arr[j] = temp\n        }\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Java代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class ShellSort {\n    // 希尔排序实现\n    void shellSort(int arr[]) {\n        int n = arr.length;\n        // 初始步长为数组长度的一半，然后逐渐减小步长\n        for (int gap = n/2; gap > 0; gap /= 2) {\n            // 对每个步长组进行插入排序\n            for (int i = gap; i < n; i += 1) {\n                // 保存当前元素\n                int temp = arr[i];\n                int j;\n                // 插入排序当前步长组\n                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n                    arr[j] = arr[j - gap];\n                }\n                // 将当前元素插入到正确位置\n                arr[j] = temp;\n            }\n        }\n    }\n}</code></pre>\n                                </div>\n                            </div>\n                            \n                            \x3c!-- 堆排序代码 --\x3e\n                            <div class="algorithm-content hidden" data-algorithm="heap">\n                                \x3c!-- C代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 交换两个元素\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\n// 堆调整函数，将以root为根的子树调整为最大堆\nvoid heapify(int arr[], int n, int root) {\n    int largest = root;       // 初始化最大值为根节点\n    int left = 2 * root + 1;  // 左子节点\n    int right = 2 * root + 2; // 右子节点\n\n    // 如果左子节点比根节点大\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n\n    // 如果右子节点比最大值大\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n\n    // 如果最大值不是根节点\n    if (largest != root) {\n        swap(&arr[root], &arr[largest]);\n\n        // 递归地调整受影响的子树\n        heapify(arr, n, largest);\n    }\n}\n\n// 堆排序主函数\nvoid heapSort(int arr[], int n) {\n    // 构建最大堆（从最后一个非叶子节点开始）\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    // 一个一个地提取元素\n    for (int i = n - 1; i > 0; i--) {\n        // 将当前根节点（最大值）移到数组末尾\n        swap(&arr[0], &arr[i]);\n\n        // 对剩余的堆进行调整\n        heapify(arr, i, 0);\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Python代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def heapify(arr, n, root):\n    """将以root为根的子树调整为最大堆"""\n    largest = root       # 初始化最大值为根节点\n    left = 2 * root + 1  # 左子节点\n    right = 2 * root + 2 # 右子节点\n\n    # 如果左子节点比根节点大\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # 如果右子节点比最大值大\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # 如果最大值不是根节点\n    if largest != root:\n        # 交换根节点和最大值\n        arr[root], arr[largest] = arr[largest], arr[root]\n\n        # 递归地调整受影响的子树\n        heapify(arr, n, largest)\n\n\ndef heap_sort(arr):\n    """堆排序主函数"""\n    n = len(arr)\n\n    # 构建最大堆（从最后一个非叶子节点开始）\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # 一个一个地提取元素\n    for i in range(n - 1, 0, -1):\n        # 将当前根节点（最大值）移到数组末尾\n        arr[0], arr[i] = arr[i], arr[0]\n\n        # 对剩余的堆进行调整\n        heapify(arr, i, 0)\n\n    return arr</code></pre>\n                                </div>\n                                \n                                \x3c!-- Go代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 堆调整函数，将以root为根的子树调整为最大堆\nfunc heapify(arr []int, n, root int) {\n    largest := root       // 初始化最大值为根节点\n    left := 2*root + 1    // 左子节点\n    right := 2*root + 2   // 右子节点\n\n    // 如果左子节点比根节点大\n    if left < n && arr[left] > arr[largest] {\n        largest = left\n    }\n\n    // 如果右子节点比最大值大\n    if right < n && arr[right] > arr[largest] {\n        largest = right\n    }\n\n    // 如果最大值不是根节点\n    if largest != root {\n        // 交换根节点和最大值\n        arr[root], arr[largest] = arr[largest], arr[root]\n\n        // 递归地调整受影响的子树\n        heapify(arr, n, largest)\n    }\n}\n\n// HeapSort 堆排序主函数\nfunc HeapSort(arr []int) {\n    n := len(arr)\n\n    // 构建最大堆（从最后一个非叶子节点开始）\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(arr, n, i)\n    }\n\n    // 一个一个地提取元素\n    for i := n - 1; i > 0; i-- {\n        // 将当前根节点（最大值）移到数组末尾\n        arr[0], arr[i] = arr[i], arr[0]\n\n        // 对剩余的堆进行调整\n        heapify(arr, i, 0)\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Java代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class HeapSort {\n    // 交换两个元素\n    void swap(int arr[], int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    // 堆调整函数，将以root为根的子树调整为最大堆\n    void heapify(int arr[], int n, int root) {\n        int largest = root;       // 初始化最大值为根节点\n        int left = 2 * root + 1;  // 左子节点\n        int right = 2 * root + 2; // 右子节点\n\n        // 如果左子节点比根节点大\n        if (left < n && arr[left] > arr[largest])\n            largest = left;\n\n        // 如果右子节点比最大值大\n        if (right < n && arr[right] > arr[largest])\n            largest = right;\n\n        // 如果最大值不是根节点\n        if (largest != root) {\n            // 交换根节点和最大值\n            swap(arr, root, largest);\n\n            // 递归地调整受影响的子树\n            heapify(arr, n, largest);\n        }\n    }\n\n    // 堆排序主函数\n    void heapSort(int arr[]) {\n        int n = arr.length;\n\n        // 构建最大堆（从最后一个非叶子节点开始）\n        for (int i = n / 2 - 1; i >= 0; i--)\n            heapify(arr, n, i);\n\n        // 一个一个地提取元素\n        for (int i = n - 1; i > 0; i--) {\n            // 将当前根节点（最大值）移到数组末尾\n            swap(arr, 0, i);\n\n            // 对剩余的堆进行调整\n            heapify(arr, i, 0);\n        }\n    }\n}</code></pre>\n                                </div>\n                            </div>\n                            \n                            \x3c!-- 计数排序代码 --\x3e\n                            <div class="algorithm-content hidden" data-algorithm="counting">\n                                \x3c!-- C代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 计数排序实现\nvoid countingSort(int arr[], int n) {\n    // 找出数组中的最大值\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n\n    // 创建计数数组\n    int count[max + 1];\n    // 初始化计数数组为0\n    for (int i = 0; i <= max; i++) {\n        count[i] = 0;\n    }\n\n    // 统计每个元素出现的次数\n    for (int i = 0; i < n; i++) {\n        count[arr[i]]++;\n    }\n\n    // 计算累积计数\n    for (int i = 1; i <= max; i++) {\n        count[i] += count[i - 1];\n    }\n\n    // 创建输出数组\n    int output[n];\n    // 从后向前遍历原数组，将元素放到正确位置\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n\n    // 将排序结果复制回原数组\n    for (int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Python代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def counting_sort(arr):\n    # 找出数组中的最大值\n    max_val = max(arr)\n    # 找出数组中的最小值\n    min_val = min(arr)\n    # 计算范围\n    range_of_elements = max_val - min_val + 1\n    \n    # 创建计数数组\n    count = [0] * range_of_elements\n    # 创建输出数组\n    output = [0] * len(arr)\n    \n    # 统计每个元素出现的次数\n    for i in range(len(arr)):\n        count[arr[i] - min_val] += 1\n    \n    # 计算累积计数\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    \n    # 从后向前遍历原数组，将元素放到正确位置\n    for i in range(len(arr) - 1, -1, -1):\n        output[count[arr[i] - min_val] - 1] = arr[i]\n        count[arr[i] - min_val] -= 1\n    \n    # 将排序结果复制回原数组\n    for i in range(len(arr)):\n        arr[i] = output[i]\n    \n    return arr</code></pre>\n                                </div>\n                                \n                                \x3c!-- Go代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// CountingSort 计数排序实现\nfunc CountingSort(arr []int) []int {\n    if len(arr) <= 1 {\n        return arr\n    }\n    \n    // 找出数组中的最大值和最小值\n    maxVal := arr[0]\n    minVal := arr[0]\n    for _, v := range arr {\n        if v > maxVal {\n            maxVal = v\n        }\n        if v < minVal {\n            minVal = v\n        }\n    }\n    \n    // 计算范围\n    rangeOfElements := maxVal - minVal + 1\n    \n    // 创建计数数组\n    count := make([]int, rangeOfElements)\n    \n    // 统计每个元素出现的次数\n    for _, v := range arr {\n        count[v-minVal]++\n    }\n    \n    // 计算累积计数\n    for i := 1; i < len(count); i++ {\n        count[i] += count[i-1]\n    }\n    \n    // 创建输出数组\n    output := make([]int, len(arr))\n    \n    // 从后向前遍历原数组，将元素放到正确位置\n    for i := len(arr) - 1; i >= 0; i-- {\n        output[count[arr[i]-minVal]-1] = arr[i]\n        count[arr[i]-minVal]--\n    }\n    \n    return output\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Java代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class CountingSort {\n    // 计数排序实现\n    void countingSort(int arr[]) {\n        // 找出数组中的最大值\n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        \n        // 找出数组中的最小值\n        int min = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] < min) {\n                min = arr[i];\n            }\n        }\n        \n        // 计算范围\n        int range = max - min + 1;\n        \n        // 创建计数数组\n        int count[] = new int[range];\n        // 创建输出数组\n        int output[] = new int[arr.length];\n        \n        // 统计每个元素出现的次数\n        for (int i = 0; i < arr.length; i++) {\n            count[arr[i] - min]++;\n        }\n        \n        // 计算累积计数\n        for (int i = 1; i < count.length; i++) {\n            count[i] += count[i - 1];\n        }\n        \n        // 从后向前遍历原数组，将元素放到正确位置\n        for (int i = arr.length - 1; i >= 0; i--) {\n            output[count[arr[i] - min] - 1] = arr[i];\n            count[arr[i] - min]--;\n        }\n        \n        // 将排序结果复制回原数组\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = output[i];\n        }\n    }\n}</code></pre>\n                                </div>\n                            </div>\n                            \n                            \x3c!-- 基数排序代码 --\x3e\n                            <div class="algorithm-content hidden" data-algorithm="radix">\n                                \x3c!-- C代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base" data-lang="c">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// 找出数组中的最大值\nint getMax(int arr[], int n) {\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\n// 按照指定的位进行计数排序\nvoid countSort(int arr[], int n, int exp) {\n    int output[n]; // 输出数组\n    int i, count[10] = {0};\n    \n    // 统计每个数字出现的次数\n    for (i = 0; i < n; i++) {\n        count[(arr[i] / exp) % 10]++;\n    }\n    \n    // 计算累积计数\n    for (i = 1; i < 10; i++) {\n        count[i] += count[i - 1];\n    }\n    \n    // 从后向前遍历原数组，将元素放到正确位置\n    for (i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    \n    // 将排序结果复制回原数组\n    for (i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\n// 基数排序主函数\nvoid radixSort(int arr[], int n) {\n    // 找出数组中的最大值，确定排序的位数\n    int m = getMax(arr, n);\n    \n    // 对每一位进行计数排序\n    for (int exp = 1; m / exp > 0; exp *= 10) {\n        countSort(arr, n, exp);\n    }\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Python代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="python">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>def radix_sort(arr):\n    # 找出数组中的最大值\n    max_val = max(arr)\n    \n    # 对每一位进行计数排序\n    exp = 1\n    while max_val // exp > 0:\n        count_sort(arr, exp)\n        exp *= 10\n    \n    return arr\n\ndef count_sort(arr, exp):\n    n = len(arr)\n    # 输出数组\n    output = [0] * n\n    # 计数数组\n    count = [0] * 10\n    \n    # 统计每个数字出现的次数\n    for i in range(n):\n        index = arr[i] // exp\n        count[index % 10] += 1\n    \n    # 计算累积计数\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    \n    # 从后向前遍历原数组，将元素放到正确位置\n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n    \n    # 将排序结果复制回原数组\n    for i in range(n):\n        arr[i] = output[i]</code></pre>\n                                </div>\n                                \n                                \x3c!-- Go代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="go">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>// RadixSort 基数排序主函数\nfunc RadixSort(arr []int) []int {\n    if len(arr) <= 1 {\n        return arr\n    }\n    \n    // 找出数组中的最大值\n    maxVal := arr[0]\n    for _, v := range arr {\n        if v > maxVal {\n            maxVal = v\n        }\n    }\n    \n    // 对每一位进行计数排序\n    for exp := 1; maxVal/exp > 0; exp *= 10 {\n        arr = countSort(arr, exp)\n    }\n    \n    return arr\n}\n\n// 按照指定的位进行计数排序\nfunc countSort(arr []int, exp int) []int {\n    n := len(arr)\n    // 输出数组\n    output := make([]int, n)\n    // 计数数组\n    count := make([]int, 10)\n    \n    // 统计每个数字出现的次数\n    for i := 0; i < n; i++ {\n        count[(arr[i]/exp)%10]++\n    }\n    \n    // 计算累积计数\n    for i := 1; i < 10; i++ {\n        count[i] += count[i-1]\n    }\n    \n    // 从后向前遍历原数组，将元素放到正确位置\n    for i := n - 1; i >= 0; i-- {\n        output[count[(arr[i]/exp)%10]-1] = arr[i]\n        count[(arr[i]/exp)%10]--\n    }\n    \n    return output\n}</code></pre>\n                                </div>\n                                \n                                \x3c!-- Java代码 --\x3e\n                                <div class="code-block font-code text-sm md:text-base hidden" data-lang="java">\n<pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto"><code>public class RadixSort {\n    // 找出数组中的最大值\n    int getMax(int arr[]) {\n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        return max;\n    }\n    \n    // 按照指定的位进行计数排序\n    void countSort(int arr[], int exp) {\n        int n = arr.length;\n        // 输出数组\n        int output[] = new int[n];\n        // 计数数组\n        int count[] = new int[10];\n        \n        // 统计每个数字出现的次数\n        for (int i = 0; i < n; i++) {\n            count[(arr[i] / exp) % 10]++;\n        }\n        \n        // 计算累积计数\n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n        \n        // 从后向前遍历原数组，将元素放到正确位置\n        for (int i = n - 1; i >= 0; i--) {\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n            count[(arr[i] / exp) % 10]--;\n        }\n        \n        // 将排序结果复制回原数组\n        for (int i = 0; i < n; i++) {\n            arr[i] = output[i];\n        }\n    }\n    \n    // 基数排序主函数\n    void radixSort(int arr[]) {\n        // 找出数组中的最大值，确定排序的位数\n        int m = getMax(arr);\n        \n        // 对每一位进行计数排序\n        for (int exp = 1; m / exp > 0; exp *= 10) {\n            countSort(arr, exp);\n        }\n    }\n}</code></pre>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                    \n                    \x3c!-- 与其他排序算法的对比 --\x3e\n                    <div class="mt-12" id="algorithm-comparison">\n                        <h3 class="text-lg font-medium mb-3 text-primary">与其他排序算法的对比</h3>\n                        \n                        \x3c!-- 复杂度对比图表 --\x3e\n                        <div class="bg-white rounded-lg border border-gray-200 shadow-sm p-4 mb-6">\n                            <canvas id="complexityChart" height="400"></canvas>\n                        </div>\n                        \n                        <div class="overflow-x-auto">\n                            <table class="min-w-full border-collapse">\n                                <thead>\n                                    <tr class="bg-gray-50">\n                                        <th class="border border-gray-200 px-4 py-2 text-left">排序算法</th>\n                                        <th class="border border-gray-200 px-4 py-2 text-left">最佳时间复杂度</th>\n                                        <th class="border border-gray-200 px-4 py-2 text-left">平均时间复杂度</th>\n                                        <th class="border border-gray-200 px-4 py-2 text-left">最坏时间复杂度</th>\n                                        <th class="border border-gray-200 px-4 py-2 text-left">空间复杂度</th>\n                                        <th class="border border-gray-200 px-4 py-2 text-left">稳定性</th>\n                                    </tr>\n                                </thead>\n                                <tbody>\n                                    <tr class="hover:bg-gray-50 transition-colors">\n                                        <td class="border border-gray-200 px-4 py-2 font-medium">冒泡排序</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n²)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n²)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(1)</td>\n                                        <td class="border border-gray-200 px-4 py-2">稳定</td>\n                                    </tr>\n                                    <tr class="hover:bg-gray-50 transition-colors">\n                                        <td class="border border-gray-200 px-4 py-2 font-medium">选择排序</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n²)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n²)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n²)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(1)</td>\n                                        <td class="border border-gray-200 px-4 py-2">不稳定</td>\n                                    </tr>\n                                    <tr class="hover:bg-gray-50 transition-colors">\n                                        <td class="border border-gray-200 px-4 py-2 font-medium">插入排序</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n²)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n²)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(1)</td>\n                                        <td class="border border-gray-200 px-4 py-2">稳定</td>\n                                    </tr>\n                                    <tr class="hover:bg-gray-50 transition-colors">\n                                        <td class="border border-gray-200 px-4 py-2 font-medium">快速排序</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n log n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n log n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n²)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(log n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">不稳定</td>\n                                    </tr>\n                                    <tr class="hover:bg-gray-50 transition-colors">\n                                        <td class="border border-gray-200 px-4 py-2 font-medium">归并排序</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n log n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n log n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n log n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">稳定</td>\n                                    </tr>\n                                    <tr class="hover:bg-gray-50 transition-colors">\n                                        <td class="border border-gray-200 px-4 py-2 font-medium">堆排序</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n log n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n log n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n log n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(1)</td>\n                                        <td class="border border-gray-200 px-4 py-2">不稳定</td>\n                                    </tr>\n                                    <tr class="hover:bg-gray-50 transition-colors">\n                                        <td class="border border-gray-200 px-4 py-2 font-medium">希尔排序</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n log n)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n^1.3)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n²)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(1)</td>\n                                        <td class="border border-gray-200 px-4 py-2">不稳定</td>\n                                    </tr>\n                                    <tr class="hover:bg-gray-50 transition-colors">\n                                        <td class="border border-gray-200 px-4 py-2 font-medium">计数排序</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n+k)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n+k)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n+k)</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n+k)</td>\n                                        <td class="border border-gray-200 px-4 py-2">稳定</td>\n                                    </tr>\n                                    <tr class="hover:bg-gray-50 transition-colors">\n                                        <td class="border border-gray-200 px-4 py-2 font-medium">基数排序</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(d*(n+k))</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(d*(n+k))</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(d*(n+k))</td>\n                                        <td class="border border-gray-200 px-4 py-2">O(n+k)</td>\n                                        <td class="border border-gray-200 px-4 py-2">稳定</td>\n                                    </tr>\n                                </tbody>\n                            </table>\n                        </div>\n                    </div>\n\n        ')}setupEventListeners(){this.app.addEventListener("click",t=>{if(t.target.closest(".code-toggle")){const n=t.target.closest(".code-toggle"),e=n.closest(".bg-gray-900").querySelector(".code-content"),i=n.querySelector("i"),r=n.querySelector("span");e.classList.toggle("hidden"),e.classList.contains("hidden")?(i.className="fa fa-chevron-down",r.textContent="展开"):(i.className="fa fa-chevron-up",r.textContent="收起")}}),this.app.addEventListener("click",t=>{if(t.target.closest(".explanation-tab")||t.target.closest(".algorithm-tab")){const n=t.target.closest(".explanation-tab")||t.target.closest(".algorithm-tab"),e=n.dataset.algorithm;this.app.querySelectorAll(".explanation-tab").forEach(t=>{t.classList.remove("border-primary","text-primary"),t.classList.add("border-transparent","text-gray-500")}),this.app.querySelectorAll(".algorithm-tab").forEach(t=>{t.classList.remove("border-primary","text-primary"),t.classList.add("border-transparent","text-gray-500")}),n.classList.remove("border-transparent","text-gray-500"),n.classList.add("border-primary","text-primary"),this.app.querySelectorAll(".algorithm-explanation").forEach(t=>{t.classList.add("hidden")});const i=this.app.querySelector(`.algorithm-explanation[data-algorithm="${e}"]`);i&&i.classList.remove("hidden"),this.app.querySelectorAll(".algorithm-content").forEach(t=>{t.dataset.algorithm===e?t.classList.remove("hidden"):t.classList.add("hidden")}),window.hljs&&window.hljs.highlightAll(),i.querySelectorAll(".step-by-step").forEach(t=>{const n=t.querySelectorAll(".step-indicator"),e=t.querySelectorAll(".step-item"),i=t.querySelector(".prev-btn"),r=t.querySelector(".next-btn");n.forEach((t,n)=>{0===n?(t.classList.add("active","bg-primary","text-white"),t.classList.remove("bg-gray-200","text-gray-500")):(t.classList.remove("active","bg-primary","text-white"),t.classList.add("bg-gray-200","text-gray-500"))}),e.forEach((t,n)=>{0===n?(t.classList.add("active"),t.classList.remove("hidden")):(t.classList.remove("active"),t.classList.add("hidden"))}),i&&(i.disabled=!0),r&&(r.disabled=!1)}),this.highlightAlgorithmTableHeader(e)}}),this.app.addEventListener("click",t=>{if(t.target.closest(".step-nav-btn")){const n=t.target.closest(".step-nav-btn"),e=n.closest(".step-by-step"),i=e.querySelectorAll(".step-indicator"),r=e.querySelectorAll(".step-item"),a=e.querySelector(".prev-btn"),s=e.querySelector(".next-btn");let o=Array.from(i).findIndex(t=>t.classList.contains("active"));n.classList.contains("next-btn")&&o<i.length-1&&(i[o].classList.remove("active","bg-primary","text-white"),i[o].classList.add("bg-gray-200","text-gray-500"),r[o].classList.remove("active"),r[o].classList.add("hidden"),o++,i[o].classList.add("active","bg-primary","text-white"),i[o].classList.remove("bg-gray-200","text-gray-500"),r[o].classList.add("active"),r[o].classList.remove("hidden")),n.classList.contains("prev-btn")&&o>0&&(i[o].classList.remove("active","bg-primary","text-white"),i[o].classList.add("bg-gray-200","text-gray-500"),r[o].classList.remove("active"),r[o].classList.add("hidden"),o--,i[o].classList.add("active","bg-primary","text-white"),i[o].classList.remove("bg-gray-200","text-gray-500"),r[o].classList.add("active"),r[o].classList.remove("hidden")),a&&(a.disabled=0===o),s&&(s.disabled=o===i.length-1)}if(t.target.closest(".code-tab")){const n=t.target.closest(".code-tab"),e=n.dataset.lang;this.app.querySelectorAll(".code-tab").forEach(t=>{t.classList.remove("border-primary","text-primary"),t.classList.add("border-transparent","text-gray-500")}),n.classList.remove("border-transparent","text-gray-500"),n.classList.add("border-primary","text-primary"),this.app.querySelectorAll(".algorithm-content:not(.hidden)").forEach(t=>{t.querySelectorAll(".code-block").forEach(t=>{t.dataset.lang===e?(t.classList.remove("hidden"),window.hljs&&window.hljs.highlightAll()):t.classList.add("hidden")})})}}),this.initComplexityChart()}highlightAlgorithmTableHeader(t){const n={bubble:"冒泡排序",selection:"选择排序",insertion:"插入排序",quick:"快速排序",merge:"归并排序",heap:"堆排序",shell:"希尔排序",counting:"计数排序",radix:"基数排序"}[t];this.app.querySelectorAll("th").forEach(t=>{if("排序算法"===t.textContent.trim()){const e=t.closest("table");if(e){const t=e.querySelector("tbody");t&&t.querySelectorAll("tr").forEach(t=>{const e=t.querySelector("td:first-child");e&&e.textContent.trim()===n?t.querySelectorAll("td, th").forEach(t=>{t.classList.add("text-red-500","font-semibold")}):t.querySelectorAll("td, th").forEach(t=>{t.classList.remove("text-red-500","font-semibold")})})}}})}initComplexityChart(){const t=document.getElementById("complexityChart");if(!t)return;const n=[10,100,1e3,1e4,1e5],e=(t,n)=>{switch(n){case"O(n)":default:return Math.log10(t);case"O(n log n)":return Math.log10(t*Math.log10(t));case"O(n^2)":return Math.log10(t*t);case"O(n^1.3)":return Math.log10(Math.pow(t,1.3));case"O(n+k)":return Math.log10(2*t);case"O(d*(n+k))":return Math.log10(10*t*2)}};new Chart(t,{type:"line",data:{labels:n,datasets:[{label:"冒泡排序 (O(n²))",data:n.map(t=>e(t,"O(n²)")),borderColor:"#ef4444",backgroundColor:"rgba(239, 68, 68, 0.1)",tension:.1,fill:!0},{label:"选择排序 (O(n²))",data:n.map(t=>e(t,"O(n²)")),borderColor:"#f97316",backgroundColor:"rgba(249, 115, 22, 0.1)",tension:.1,fill:!0},{label:"插入排序 (O(n²))",data:n.map(t=>e(t,"O(n²)")),borderColor:"#eab308",backgroundColor:"rgba(234, 179, 8, 0.1)",tension:.1,fill:!0},{label:"快速排序 (O(n log n))",data:n.map(t=>e(t,"O(n log n)")),borderColor:"#10b981",backgroundColor:"rgba(16, 185, 129, 0.1)",tension:.1,fill:!0},{label:"归并排序 (O(n log n))",data:n.map(t=>e(t,"O(n log n)")),borderColor:"#3b82f6",backgroundColor:"rgba(59, 130, 246, 0.1)",tension:.1,fill:!0},{label:"堆排序 (O(n log n))",data:n.map(t=>e(t,"O(n log n)")),borderColor:"#8b5cf6",backgroundColor:"rgba(139, 92, 246, 0.1)",tension:.1,fill:!0},{label:"希尔排序 (O(n^1.3))",data:n.map(t=>e(t,"O(n^1.3)")),borderColor:"#ec4899",backgroundColor:"rgba(236, 72, 153, 0.1)",tension:.1,fill:!0},{label:"计数排序 (O(n+k))",data:n.map(t=>e(t,"O(n+k)")),borderColor:"#06b6d4",backgroundColor:"rgba(6, 182, 212, 0.1)",tension:.1,fill:!0},{label:"基数排序 (O(d*(n+k)))",data:n.map(t=>e(t,"O(d*(n+k))")),borderColor:"#6366f1",backgroundColor:"rgba(99, 102, 241, 0.1)",tension:.1,fill:!0}]},options:{responsive:!0,maintainAspectRatio:!1,plugins:{title:{display:!0,text:"排序算法时间复杂度对比 (对数刻度)",font:{size:16}},legend:{position:"top",labels:{boxWidth:12,padding:15}},tooltip:{mode:"index",intersect:!1,callbacks:{label:function(t){return t.dataset.label+": log10(T(n)) = "+t.parsed.y.toFixed(3)}}}},scales:{x:{title:{display:!0,text:"输入规模 (n)",font:{size:14}},type:"logarithmic",ticks:{callback:function(t){return t.toString()}}},y:{title:{display:!0,text:"log10(T(n))",font:{size:14}},type:"linear",ticks:{precision:2}}}}})}}window.ExplanationSection=l;class d{constructor(){this.app=document.getElementById("app"),this.render()}render(){this.app.insertAdjacentHTML("beforeend",'\n            \x3c!-- 页脚信息 --\x3e\n            <footer class="bg-white shadow-md mt-auto p-4 text-center text-xs text-gray-500 border-t border-gray-200 w-full">\n                <p>排序算法可视化演示 &copy; 2025</p>\n                <p class="mt-1">一个直观展示多种排序算法工作原理的交互式工具</p>\n            </footer>\n        ')}}class c{constructor(){this.documentData=[],this.currentAlgorithm="",this.startTime=null,this.endTime=null}init(t){this.documentData=[],this.currentAlgorithm=t,this.startTime=new Date,this.endTime=null,this.documentData.push({type:"header",level:1,content:`${t} 算法执行解释文档`}),this.documentData.push({type:"section",title:"基本信息",content:[`执行时间: ${this.startTime.toLocaleString()}`,`算法名称: ${t}`,"文档类型: 算法执行过程解释"]})}addStep(t,n,e){this.documentData.push({type:"step",stepNumber:t,explanation:n,logs:e,timestamp:new Date})}complete(t){this.endTime=new Date,this.documentData.push({type:"section",title:"执行统计",content:[`总执行时间: ${((this.endTime-this.startTime)/1e3).toFixed(2)} 秒`,`总步骤数: ${this.documentData.filter(t=>"step"===t.type).length} 步`,`比较次数: ${t.comparisonCount}`,`交换次数: ${t.swapCount}`]}),this.documentData.push({type:"section",title:"算法总结",content:[`该${this.currentAlgorithm}算法成功完成了排序任务。`,`通过${this.documentData.filter(t=>"step"===t.type).length}个步骤，将无序数组转换为有序数组。`,`算法执行过程中进行了${t.comparisonCount}次元素比较和${t.swapCount}次元素交换。`]})}generateHTML(){let t=`<!DOCTYPE html>\n<html lang="zh-CN">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>${this.currentAlgorithm} 算法执行解释文档</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            background-color: #f5f5f5;\n        }\n        \n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: white;\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\n            margin-top: 20px;\n            margin-bottom: 20px;\n        }\n        \n        h1 {\n            color: #165DFF;\n            margin-bottom: 20px;\n            text-align: center;\n        }\n        \n        h2 {\n            color: #374151;\n            margin: 20px 0 15px 0;\n            border-bottom: 2px solid #e5e7eb;\n            padding-bottom: 5px;\n        }\n        \n        h3 {\n            color: #4B5563;\n            margin: 15px 0 10px 0;\n        }\n        \n        .section {\n            margin: 20px 0;\n            padding: 15px;\n            background-color: #f9fafb;\n            border-radius: 8px;\n        }\n        \n        .section-title {\n            font-weight: bold;\n            margin-bottom: 10px;\n            color: #1f2937;\n        }\n        \n        .step {\n            margin: 25px 0;\n            padding: 20px;\n            background-color: #ffffff;\n            border: 1px solid #e5e7eb;\n            border-radius: 8px;\n            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n        }\n        \n        .step-number {\n            font-weight: bold;\n            color: #165DFF;\n            font-size: 1.2em;\n            margin-bottom: 10px;\n        }\n        \n        .step-explanation {\n            margin-bottom: 15px;\n            font-size: 1.1em;\n            color: #374151;\n        }\n        \n        .logs-container {\n            margin-left: 20px;\n            border-left: 3px solid #165DFF;\n            padding-left: 15px;\n        }\n        \n        .log-entry {\n            margin: 5px 0;\n            padding: 8px 12px;\n            background-color: #f3f4f6;\n            border-radius: 4px;\n            font-family: 'Courier New', Courier, monospace;\n            font-size: 0.9em;\n        }\n        \n        .log-type-selection {\n            background-color: #dbeafe;\n            border-left: 3px solid #3b82f6;\n        }\n        \n        .log-type-swap {\n            background-color: #fee2e2;\n            border-left: 3px solid #ef4444;\n        }\n        \n        .log-type-comparison {\n            background-color: #d1fae5;\n            border-left: 3px solid #10b981;\n        }\n        \n        .stat-list {\n            list-style-type: none;\n            padding: 0;\n        }\n        \n        .stat-list li {\n            margin: 5px 0;\n            padding: 5px 0;\n        }\n        \n        .footer {\n            margin-top: 30px;\n            padding-top: 20px;\n            border-top: 2px solid #e5e7eb;\n            text-align: center;\n            color: #6b7280;\n            font-size: 0.9em;\n        }\n    </style>\n</head>\n<body>\n    <div class="container">\n`;return this.documentData.forEach(n=>{switch(n.type){case"header":t+=`<h${n.level}>${n.content}</h${n.level}>`;break;case"section":t+=`\n                    <div class="section">\n                        <div class="section-title">${n.title}</div>\n                        <ul class="stat-list">`,n.content.forEach(n=>{t+=`<li>${n}</li>`}),t+="\n                        </ul>\n                    </div>";break;case"step":t+=`\n                    <div class="step">\n                        <div class="step-number">步骤 ${n.stepNumber}</div>\n                        <div class="step-explanation">${n.explanation}</div>\n                        <div class="logs-container">`,n.logs.forEach(n=>{const e=`log-type-${n.type}`;t+=`<div class="log-entry ${e}">${n.content}</div>`}),t+="\n                        </div>\n                    </div>"}}),t+=`\n        <div class="footer">\n            <p>算法执行解释文档 - 生成时间: ${this.endTime.toLocaleString()}</p>\n        </div>\n    </div>\n</body>\n</html>`,t}generateMarkdown(){let t=`# ${this.currentAlgorithm} 算法执行解释文档\n\n`;return this.documentData.forEach(n=>{switch(n.type){case"header":t+=`${"#".repeat(n.level)} ${n.content}\n\n`;break;case"section":t+=`## ${n.title}\n\n`,n.content.forEach(n=>{t+=`- ${n}\n`}),t+="\n";break;case"step":t+=`### 步骤 ${n.stepNumber}\n\n`,t+=`${n.explanation}\n\n`,t+="**执行日志:**\n\n",n.logs.forEach(n=>{let e="";switch(n.type){case"selection":e="🔵 ";break;case"swap":e="🔴 ";break;case"comparison":e="🟢 ";break;default:e="⚪ "}t+=`${e}\`${n.content}\`\n\n`})}}),t}exportDocument(t="html"){if(this.endTime=new Date,"html"===t)return this.generateHTML();if("markdown"===t)return this.generateMarkdown();throw new Error("不支持的文档格式")}saveDocument(t="html"){const n=this.exportDocument(t),e=`${this.currentAlgorithm}-execution-document-${Date.now()}.${t}`,i=new Blob([n],{type:"html"===t?"text/html":"text/markdown"}),r=URL.createObjectURL(i),a=document.createElement("a");return a.href=r,a.download=e,document.body.appendChild(a),a.click(),document.body.removeChild(a),URL.revokeObjectURL(r),e}}function p(t){const n=[],e=[...t];let i=0,r=0;n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],sortedIndices:[],algorithm:"bubble",indices:{i:0,j:0,low:0,high:e.length-1}});for(let s=0;s<e.length-1;s++){const t=Array.from({length:s},(t,n)=>e.length-1-n),a=e.length-s-1;for(let l=0;l<a;l++)i++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[l,l+1],pivotIndex:a,sortedIndices:t,algorithm:"bubble",indices:{i:s,j:l,low:0,high:e.length-1}}),e[l]>e[l+1]&&([e[l],e[l+1]]=[e[l+1],e[l]],r++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[l,l+1],pivotIndex:a,sortedIndices:t,algorithm:"bubble",indices:{i:s,j:l,low:0,high:e.length-1}}));t.push(e.length-1-s);const o=e.length-(s+1)-1;n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:o,sortedIndices:t,algorithm:"bubble",indices:{i:s+1,j:0,low:0,high:e.length-1}})}const a=Array.from({length:e.length},(t,n)=>n);return n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],sortedIndices:a,algorithm:"bubble",indices:{i:e.length,j:0,low:0,high:e.length-1}}),{array:e,history:n,comparisonCount:i,swapCount:r}}function m(t){const n=[],e=[...t];let i=0,r=0;n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],sortedIndices:[],algorithm:"selection",indices:{i:0,j:0,low:0,high:e.length-1}});for(let s=0;s<e.length-1;s++){let t=s;const a=Array.from({length:s},(t,n)=>n);n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[s],pivotIndex:s,sortedIndices:a,algorithm:"selection",indices:{i:s,j:s,low:0,high:e.length-1}});for(let l=s+1;l<e.length;l++)i++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[s,l,t],pivotIndex:s,sortedIndices:a,algorithm:"selection",indices:{i:s,j:l,low:0,high:e.length-1}}),e[l]<e[t]&&(t=l,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[s,l,t],pivotIndex:s,sortedIndices:a,algorithm:"selection",indices:{i:s,j:l,low:0,high:e.length-1}}));t!==s&&([e[s],e[t]]=[e[t],e[s]],r++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[s,t],pivotIndex:s,sortedIndices:a,algorithm:"selection",indices:{i:s,j:e.length,low:0,high:e.length-1}})),a.push(s);const o=s+1;n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:o,sortedIndices:a,algorithm:"selection",indices:{i:s+1,j:0,low:0,high:e.length-1}})}const a=Array.from({length:e.length},(t,n)=>n);return n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],sortedIndices:a,algorithm:"selection",indices:{i:e.length,j:0,low:0,high:e.length-1}}),{array:e,history:n,comparisonCount:i,swapCount:r}}function h(t){const n=[],e=[...t];let i=0,r=0;n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],sortedIndices:[],algorithm:"insertion",indices:{i:0,j:0,low:0,high:e.length-1}});for(let s=1;s<e.length;s++){const t=e[s];let a=s-1;const o=Array.from({length:s},(t,n)=>n);for(n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[s],pivotIndex:s,sortedIndices:o,algorithm:"insertion",indices:{i:s,j:a,low:0,high:e.length-1}});a>=0;){i++;const o=Array.from({length:a},(t,n)=>n);if(n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[a,a+1],pivotIndex:s,sortedIndices:o,algorithm:"insertion",indices:{i:s,j:a,low:0,high:e.length-1}}),!(e[a]>t))break;e[a+1]=e[a],r++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[a,a+1],pivotIndex:s,sortedIndices:o,algorithm:"insertion",indices:{i:s,j:a,low:0,high:e.length-1}}),a--}e[a+1]=t;const l=Array.from({length:s+1},(t,n)=>n),d=s+1;n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[a+1],pivotIndex:d,sortedIndices:l,algorithm:"insertion",indices:{i:s+1,j:0,low:0,high:e.length-1}})}const a=Array.from({length:e.length},(t,n)=>n);return n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],sortedIndices:a,algorithm:"insertion",indices:{i:e.length,j:0,low:0,high:e.length-1}}),{array:e,history:n,comparisonCount:i,swapCount:r}}function g(t){const n=[],e=[...t];let i=0,r=0;n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],sortedIndices:[],algorithm:"quick",indices:{i:0,j:0,low:0,high:e.length-1}}),function t(a,s){if(a<s){n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[a,s],sortedIndices:[],algorithm:"quick",indices:{i:a,j:s,low:a,high:s}});const o=function(t,a){const s=e[a];let o=t-1;for(let l=t;l<a;l++)n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[l],pivotIndex:a,sortedIndices:[],algorithm:"quick",indices:{i:o,j:l,low:t,high:a}}),i++,e[l]<=s&&(o++,o!==l&&([e[o],e[l]]=[e[l],e[o]],r++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[o,l],pivotIndex:a,sortedIndices:[],algorithm:"quick",indices:{i:o,j:l,low:t,high:a}})));return o++,[e[o],e[a]]=[e[a],e[o]],r++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[o],pivotIndex:o,sortedIndices:[],algorithm:"quick",indices:{i:o,j:a,low:t,high:a}}),o}(a,s);t(a,o-1),t(o+1,s)}}(0,e.length-1);const a=Array.from({length:e.length},(t,n)=>n);return n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],sortedIndices:a,algorithm:"quick",indices:{i:0,j:0,low:0,high:e.length-1}}),{array:e,history:n,comparisonCount:i,swapCount:r}}function u(t){const n=[],e=[...t];let i=0,r=0;n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],sortedIndices:[],algorithm:"merge",indices:{i:0,j:0,low:0,high:e.length-1}}),function t(a,s){if(a<s){const o=Math.floor((a+s)/2);n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[a,o,s],pivotIndex:o,sortedIndices:[],algorithm:"merge",indices:{i:a,j:s,low:a,high:s}}),t(a,o),t(o+1,s),function(t,a,s){const o=e.slice(t,a+1),l=e.slice(a+1,s+1);let d=0,c=0,p=t;for(n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[t,a,s],pivotIndex:a,sortedIndices:[],algorithm:"merge",indices:{i:d,j:c,low:t,high:s}});d<o.length&&c<l.length;)n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[t+d,a+1+c],pivotIndex:a,sortedIndices:[],algorithm:"merge",indices:{i:d,j:c,low:t,high:s}}),i++,o[d]<=l[c]?(e[p]=o[d],d++):(e[p]=l[c],c++),r++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[p],pivotIndex:a,sortedIndices:[],algorithm:"merge",indices:{i:d,j:c,low:t,high:s}}),p++;for(;d<o.length;)e[p]=o[d],r++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[p],pivotIndex:a,sortedIndices:[],algorithm:"merge",indices:{i:d,j:c,low:t,high:s}}),d++,p++;for(;c<l.length;)e[p]=l[c],r++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[p],pivotIndex:a,sortedIndices:[],algorithm:"merge",indices:{i:d,j:c,low:t,high:s}}),c++,p++;const m=Array.from({length:s-t+1},(n,e)=>t+e);n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:a,sortedIndices:m,algorithm:"merge",indices:{i:d,j:c,low:t,high:s}})}(a,o,s)}}(0,e.length-1);const a=Array.from({length:e.length},(t,n)=>n);return n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],sortedIndices:a,algorithm:"merge",indices:{i:0,j:0,low:0,high:e.length-1}}),{array:e,history:n,comparisonCount:i,swapCount:r}}function x(t){const n=[],e=[...t];let i=0,r=0;n.push({array:[...e],comparisonCount:0,swapCount:0,highlightIndices:[],pivotIndex:-1,sortedIndices:[],indices:{i:0,j:0,low:0,high:e.length-1},algorithm:"shell"});const a=e.length;let s=Math.floor(a/2);for(;s>0;){for(let t=s;t<a;t++){const o=e[t];let l=t;for(;l>=s&&(i++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[l,l-s],pivotIndex:t,sortedIndices:[],indices:{i:t,j:l,low:0,high:a-1},algorithm:"shell"}),e[l-s]>o);)e[l]=e[l-s],r++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[l,l-s],pivotIndex:t,sortedIndices:[],indices:{i:t,j:l,low:0,high:a-1},algorithm:"shell"}),l-=s;e[l]=o,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[l],pivotIndex:t,sortedIndices:[],indices:{i:t,j:l,low:0,high:a-1},algorithm:"shell"})}s=Math.floor(s/2)}const o=Array.from({length:e.length},(t,n)=>n);return n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:-1,sortedIndices:o,indices:{i:0,j:0,low:0,high:a-1},algorithm:"shell"}),{history:n,array:e,comparisonCount:i,swapCount:r}}function b(t){const n=[],e=[...t];let i=0,r=0,a=[];function s(t,o){let l=o;const d=2*o+1,c=2*o+2;n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[d,c].filter(n=>n<t),pivotIndex:o,sortedIndices:[...a],algorithm:"heap",indices:{i:o,j:t-1,low:0,high:e.length-1}}),d<t&&(i++,e[d]>e[l]&&(l=d)),c<t&&(i++,e[c]>e[l]&&(l=c)),l!==o&&([e[o],e[l]]=[e[l],e[o]],r++,n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[o,l],pivotIndex:o,sortedIndices:[...a],algorithm:"heap",indices:{i:o,j:t-1,low:0,high:e.length-1}}),s(t,l))}n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:-1,sortedIndices:[...a],algorithm:"heap",indices:{i:0,j:0,low:0,high:e.length-1}});const o=e.length;for(let l=Math.floor(o/2)-1;l>=0;l--)s(o,l);for(let l=o-1;l>0;l--)[e[0],e[l]]=[e[l],e[0]],r++,a.unshift(l),n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[0,l],pivotIndex:0,sortedIndices:[...a],algorithm:"heap",indices:{i:0,j:l,low:0,high:e.length-1}}),s(l,0);return a.unshift(0),n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:-1,sortedIndices:[...a],algorithm:"heap",indices:{i:0,j:0,low:0,high:e.length-1}}),{array:e,history:n,comparisonCount:i,swapCount:r}}function y(t){const n=[],e=[...t];if(n.push({array:[...e],comparisonCount:0,swapCount:0,highlightIndices:[],pivotIndex:-1,sortedIndices:[],algorithm:"counting",indices:{i:0,j:0,low:0,high:e.length-1}}),0===e.length){const t=Array.from({length:e.length},(t,n)=>n);return n.push({array:[...e],comparisonCount:0,swapCount:0,highlightIndices:[],pivotIndex:-1,sortedIndices:t,algorithm:"counting",indices:{i:0,j:0,low:0,high:e.length-1}}),{array:e,history:n,comparisonCount:0,swapCount:0}}let i=e[0],r=e[0];for(let l=1;l<e.length;l++){let t=e.indexOf(i),a=e.indexOf(r);e[l]>i&&(i=e[l],t=l),e[l]<r&&(r=e[l],a=l),n.push({array:[...e],comparisonCount:0,swapCount:0,highlightIndices:[l,t,a],pivotIndex:l,sortedIndices:[],algorithm:"counting",indices:{i:l,j:0,low:0,high:e.length-1}})}const a=new Array(i-r+1).fill(0);for(let l=0;l<e.length;l++){const t=e[l]-r;a[t]++;const i=[];for(let n=0;n<=l;n++)e[n]===e[l]&&i.push(n);n.push({array:[...e],comparisonCount:0,swapCount:0,highlightIndices:i,pivotIndex:l,sortedIndices:[],algorithm:"counting",indices:{i:l,j:t,low:0,high:e.length-1},countArray:[...a]})}for(let l=1;l<a.length;l++)a[l]+=a[l-1],n.push({array:[...e],comparisonCount:0,swapCount:0,highlightIndices:[],pivotIndex:-1,sortedIndices:[],algorithm:"counting",indices:{i:l,j:0,low:0,high:e.length-1},countArray:[...a]});const s=new Array(e.length);for(let l=e.length-1;l>=0;l--){const t=e[l]-r,i=a[t]-1;s[i]=e[l],a[t]--,n.push({array:[...s],comparisonCount:0,swapCount:0,highlightIndices:[l,i],pivotIndex:l,sortedIndices:[],algorithm:"counting",indices:{i:l,j:i,low:0,high:e.length-1},countArray:[...a]})}for(let l=0;l<e.length;l++)e[l]=s[l],n.push({array:[...e],comparisonCount:0,swapCount:0,highlightIndices:[l],pivotIndex:l,sortedIndices:[],algorithm:"counting",indices:{i:l,j:0,low:0,high:e.length-1}});for(let l=0;l<e.length;l++){const t=Array.from({length:l+1},(t,n)=>n);n.push({array:[...e],comparisonCount:0,swapCount:0,highlightIndices:[],pivotIndex:l,sortedIndices:t,algorithm:"counting",indices:{i:l,j:0,low:0,high:e.length-1}})}const o=Array.from({length:e.length},(t,n)=>n);return n.push({array:[...e],comparisonCount:0,swapCount:0,highlightIndices:[],pivotIndex:-1,sortedIndices:o,algorithm:"counting",indices:{i:e.length,j:0,low:0,high:e.length-1}}),{array:e,history:n,comparisonCount:0,swapCount:0}}function f(t){const n=[],e=[...t];let i=0,r=0;if(n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:-1,sortedIndices:[],algorithm:"radix",indices:{i:0,j:0,low:0,high:e.length-1}}),0===e.length){const t=Array.from({length:e.length},(t,n)=>n);return n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:-1,sortedIndices:t,algorithm:"radix",indices:{i:0,j:0,low:0,high:e.length-1}}),{array:e,history:n,comparisonCount:i,swapCount:r}}let a=e[0];for(let c=1;c<e.length;c++)i++,e[c]>a&&(a=e[c]),n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[c],pivotIndex:c,sortedIndices:[],algorithm:"radix",indices:{i:c,j:0,low:0,high:e.length-1}});let s=0;for(;a>0;)s++,a=Math.floor(a/10);let o=1;for(let c=0;c<s;c++)n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:c,sortedIndices:[],algorithm:"radix",indices:{i:c,j:0,low:0,high:e.length-1}}),d(e,o),o*=10;for(let c=0;c<e.length;c++){const t=Array.from({length:c+1},(t,n)=>n);n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:c,sortedIndices:t,algorithm:"radix",indices:{i:c,j:0,low:0,high:e.length-1}})}const l=Array.from({length:e.length},(t,n)=>n);function d(t,e){const a=t.length,s=new Array(a),o=new Array(10).fill(0);for(let l=0;l<a;l++)o[Math.floor(t[l]/e)%10]++,n.push({array:[...t],comparisonCount:i,swapCount:r,highlightIndices:[l],pivotIndex:l,sortedIndices:[],algorithm:"radix",indices:{i:l,j:0,low:0,high:a-1}});for(let n=1;n<10;n++)o[n]+=o[n-1];for(let l=a-1;l>=0;l--){const d=Math.floor(t[l]/e)%10;s[o[d]-1]=t[l],o[d]--,r++,n.push({array:[...s],comparisonCount:i,swapCount:r,highlightIndices:[l],pivotIndex:l,sortedIndices:[],algorithm:"radix",indices:{i:l,j:0,low:0,high:a-1}})}for(let l=0;l<a;l++)t[l]=s[l],n.push({array:[...t],comparisonCount:i,swapCount:r,highlightIndices:[l],pivotIndex:l,sortedIndices:[],algorithm:"radix",indices:{i:l,j:0,low:0,high:a-1}})}return n.push({array:[...e],comparisonCount:i,swapCount:r,highlightIndices:[],pivotIndex:-1,sortedIndices:l,algorithm:"radix",indices:{i:e.length,j:0,low:0,high:e.length-1}}),{array:e,history:n,comparisonCount:i,swapCount:r}}const v={bubbleSort:p,selectionSort:m,insertionSort:h,quickSort:g,mergeSort:u,shellSort:x,heapSort:b,countingSort:y,radixSort:f},w=new class{constructor(){this.sortHistory={},this.currentArray=[],this.currentAlgorithm="bubbleSort"}generateHistory(t,n){const e=this.generateKey(t,n);if(this.sortHistory[e])return this.sortHistory[e];const i=v[n];if(!i)throw new Error(`排序算法 ${n} 未实现`);const r=i(t);return this.sortHistory[e]=r,r}generateKey(t,n){return`${n}-${JSON.stringify(t)}`}getHistory(t,n){const e=this.generateKey(t,n);return this.sortHistory[e]||null}clearHistory(){this.sortHistory={}}setCurrent(t,n){this.currentArray=[...t],this.currentAlgorithm=n}getCurrentHistory(){return this.getHistory(this.currentArray,this.currentAlgorithm)}generateCurrentHistory(){return this.generateHistory(this.currentArray,this.currentAlgorithm)}};class S{constructor(){this.currentLanguage=localStorage.getItem("language")||"zh",this.translations={common:{zh:{title:"排序算法可视化",singleMode:"单算法模式",competitionMode:"竞赛模式",visualization:"排序可视化",algorithmPrinciple:"算法原理",complexityAnalysis:"复杂度分析",applicationScenarios:"适用场景",codeImplementation:"代码实现",algorithmComparison:"算法对比",selectAlgorithm:"选择算法",newArray:"新数组",start:"开始",pause:"暂停",reset:"重置",stepBack:"步退",stepForward:"步进",arraySize:"数组大小",sortSpeed:"每秒排序次数",algorithmLog:"算法日志",step:"步骤",generateDocument:"生成文档",exportData:"导出数据",exportFormat:"导出格式",exportContent:"导出内容",sortingProcess:"排序过程",performanceData:"性能数据",algorithmInfo:"算法信息",randomArray:"随机数组",sortedArray:"已排序数组",reverseArray:"逆序数组",nearlySortedArray:"近似排序数组",fewUniqueArray:"少数唯一值",constantArray:"常数数组",alternatingArray:"交替数组",customArray:"自定义数组",confirm:"确认",cancel:"取消",enterArray:"请输入数组（用逗号分隔）",invalidArray:"无效的数组格式",explanatoryDocument:"解释文档"},en:{title:"Sorting Algorithm Visualization",singleMode:"Single Algorithm Mode",competitionMode:"Competition Mode",visualization:"Visualization",algorithmPrinciple:"Algorithm Principle",complexityAnalysis:"Complexity Analysis",applicationScenarios:"Application Scenarios",codeImplementation:"Code Implementation",algorithmComparison:"Algorithm Comparison",selectAlgorithm:"Select Algorithm",newArray:"New Array",start:"Start",pause:"Pause",reset:"Reset",stepBack:"Step Back",stepForward:"Step Forward",arraySize:"Array Size",sortSpeed:"Sorting Speed",algorithmLog:"Algorithm Log",step:"Step",generateDocument:"Generate Document",exportData:"Export Data",exportFormat:"Export Format",exportContent:"Export Content",sortingProcess:"Sorting Process",performanceData:"Performance Data",algorithmInfo:"Algorithm Info",randomArray:"Random Array",sortedArray:"Sorted Array",reverseArray:"Reverse Array",nearlySortedArray:"Nearly Sorted Array",fewUniqueArray:"Few Unique Values",constantArray:"Constant Array",alternatingArray:"Alternating Array",customArray:"Custom Array",confirm:"Confirm",cancel:"Cancel",enterArray:"Please enter array (comma-separated)",invalidArray:"Invalid array format",explanatoryDocument:"Explanatory Document"}},algorithms:{zh:{bubbleSort:"冒泡排序",selectionSort:"选择排序",insertionSort:"插入排序",quickSort:"快速排序",mergeSort:"归并排序",heapSort:"堆排序",shellSort:"希尔排序",countingSort:"计数排序",radixSort:"基数排序"},en:{bubbleSort:"Bubble Sort",selectionSort:"Selection Sort",insertionSort:"Insertion Sort",quickSort:"Quick Sort",mergeSort:"Merge Sort",heapSort:"Heap Sort",shellSort:"Shell Sort",countingSort:"Counting Sort",radixSort:"Radix Sort"}}}}getCurrentLanguage(){return this.currentLanguage}setLanguage(t){this.currentLanguage=t,localStorage.setItem("language",t),document.documentElement.setAttribute("lang",t),document.dispatchEvent(new CustomEvent("languageChanged",{detail:{lang:t}}))}t(t,n="common"){return this.translations[n][this.currentLanguage][t]||t}updateDOMText(){const t=document.querySelector("h1");t&&(t.textContent=this.t("title")),this.updateNavigation(),this.updateModeButtons(),this.updateControlPanel(),this.updateMobileMenu()}updateNavigation(){const t={"#visualization":this.t("visualization"),"#algorithm-principle":this.t("algorithmPrinciple"),"#complexity-analysis":this.t("complexityAnalysis"),"#application-scenarios":this.t("applicationScenarios"),"#code-implementation":this.t("codeImplementation"),"#algorithm-comparison":this.t("algorithmComparison")};Object.entries(t).forEach(([t,n])=>{document.querySelectorAll(`a[href="${t}"]`).forEach(t=>{const e=t.querySelector("i");e?t.innerHTML=`<i class="${e.className}"></i> ${n}`:t.textContent=n})})}updateModeButtons(){const t=document.getElementById("single-mode-btn");if(t){const n=t.querySelector("i");t.innerHTML=`<i class="${n.className}"></i> ${this.t("singleMode")}`}const n=document.getElementById("competition-mode-btn");if(n){const t=n.querySelector("i");n.innerHTML=`<i class="${t.className}"></i> ${this.t("competitionMode")}`}}updateControlPanel(){const t=document.querySelector('label[for="algorithm-selector"]');t&&(t.textContent=this.t("selectAlgorithm"));const n=document.getElementById("new-array");if(n){const t=n.querySelector("i");n.innerHTML=`<i class="${t.className}"></i> ${this.t("newArray")}`}const e=document.getElementById("start-sort");if(e){const t=e.querySelector("i");e.innerHTML=`<i class="${t.className}"></i> ${this.t("start")}`}const i=document.getElementById("pause-sort");if(i){const t=i.querySelector("i");i.innerHTML=`<i class="${t.className}"></i> ${this.t("pause")}`}const r=document.getElementById("reset-sort");if(r){const t=r.querySelector("i");r.innerHTML=`<i class="${t.className}"></i> ${this.t("reset")}`}const a=document.getElementById("step-back");if(a){const t=a.querySelector("i");a.innerHTML=`<i class="${t.className}"></i> ${this.t("stepBack")}`}const s=document.getElementById("step-forward");if(s){const t=s.querySelector("i");s.innerHTML=`<i class="${t.className}"></i> ${this.t("stepForward")}`}document.querySelectorAll('label[for="array-size"]').forEach(t=>{const n=t.querySelector("span");n&&(t.innerHTML=`${this.t("arraySize")}: <span id="array-size-value">${n.textContent}</span>`)}),document.querySelectorAll('label[for="sort-speed"]').forEach(t=>{const n=t.querySelector("span");n&&(t.innerHTML=`${this.t("sortSpeed")}: <span id="sort-speed-value">${n.textContent}</span>`)}),document.querySelectorAll("label").forEach(t=>{const n=t.textContent.trim();if("导出数据"===n||"Export Data"===n)t.textContent=this.t("exportData");else if("导出格式"===n||"Export Format"===n)t.textContent=this.t("exportFormat");else if("导出内容"===n||"Export Content"===n)t.textContent=this.t("exportContent");else if(n.includes("排序过程")||n.includes("Sorting Process")){const n=t.querySelector('input[type="checkbox"]');n&&(t.innerHTML=`<input type="checkbox" name="export-content" value="sorting-process" class="mr-1"${n.checked?" checked":""}> ${this.t("sortingProcess")}`)}else if(n.includes("性能数据")||n.includes("Performance Data")){const n=t.querySelector('input[type="checkbox"]');n&&(t.innerHTML=`<input type="checkbox" name="export-content" value="performance-data" class="mr-1"${n.checked?" checked":""}> ${this.t("performanceData")}`)}else if(n.includes("算法信息")||n.includes("Algorithm Info")){const n=t.querySelector('input[type="checkbox"]');n&&(t.innerHTML=`<input type="checkbox" name="export-content" value="algorithm-info" class="mr-1"${n.checked?" checked":""}> ${this.t("algorithmInfo")}`)}});const o=document.getElementById("export-data");if(o){const t=o.querySelector("i");t?o.innerHTML=`<i class="${t.className}"></i> ${this.t("exportData")}`:o.textContent=this.t("exportData")}}updateMobileMenu(){const t=document.querySelector('label[for="mobile-algorithm-selector"]');t&&(t.textContent=this.t("selectAlgorithm"))}}const C=new S;void 0!==n&&n.exports?n.exports={LanguageManager:S,languageManager:C}:"undefined"!=typeof window&&(window.LanguageManager=S,window.languageManager=C),window.languageManager=C;const k={bubbleSort:{name:"冒泡排序",description:"冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢'浮'到数列的顶端，就如同水中的气泡一样向上冒，因此得名冒泡排序。",timeComplexity:{best:"O(n)",average:"O(n²)",worst:"O(n²)"},spaceComplexity:"O(1)",stability:"稳定",scenarios:"冒泡排序由于其简单性和稳定性，在某些特定场景下仍然有用：对于几乎已经排序的数据，优化版的冒泡排序性能良好；数据量很小的情况，简单性比效率更重要时；教学场景，用于解释排序算法的基本原理；需要稳定排序且实现简单的场景。然而，对于大规模数据集，冒泡排序通常不是一个好的选择，因为其时间复杂度为O(n²)，效率较低。",stepExplanations:{initial:"初始状态：数组尚未开始排序，所有元素均为未排序状态。",compare:"比较相邻元素 arr[j] 和 arr[j+1]，检查它们的顺序是否正确。",swap:"交换 arr[j] 和 arr[j+1]，因为 arr[j] > arr[j+1]，需要调整它们的顺序。",roundComplete:"第 {{i+1}} 轮排序完成，最大的元素已经'冒泡'到正确的位置。",complete:"冒泡排序完成，所有元素都已按升序排列。"}},quickSort:{name:"快速排序",description:"快速排序是一种高效的排序算法，采用分治策略。它选择一个'基准'元素，然后通过一趟排序将待排序的记录分割成独立的两部分，一部分记录的元素值均比基准元素小，另一部分记录的元素值均比基准元素大。然后分别对这两部分记录继续进行快速排序，以达到整个序列有序的目的。",timeComplexity:{best:"O(n log n)",average:"O(n log n)",worst:"O(n²)"},spaceComplexity:"O(log n)",stability:"不稳定",scenarios:"快速排序是一种通用的高效排序算法，适用于大多数场景，特别是处理大型数据集时。它在实践中通常比其他O(n log n)算法（如归并排序）更快，因为其内部循环可以高效地实现。快速排序特别适合需要原地排序（不需要额外内存）的场景，以及对缓存友好的应用。",stepExplanations:{initial:"初始状态：数组尚未开始排序，所有元素均为未排序状态。",selectPivot:"选择最右侧元素作为基准元素。",compare:"比较当前元素与基准元素，决定其应该放在基准元素的左侧还是右侧。",swap:"交换元素，将小于基准的元素移到左侧，大于基准的元素移到右侧。",partitionComplete:"分区完成，基准元素已放在正确的位置。",recursiveSort:"递归地对基准元素左侧和右侧的子数组进行快速排序。",complete:"快速排序完成，所有元素都已按升序排列。"}},selectionSort:{name:"选择排序",description:"选择排序是一种简单直观的排序算法。它的工作原理是每次从待排序的数据元素中选出最小（或最大）的一个元素，放到序列的起始位置，然后再从剩余未排序元素中继续寻找最小（或最大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。",timeComplexity:{best:"O(n²)",average:"O(n²)",worst:"O(n²)"},spaceComplexity:"O(1)",stability:"不稳定",scenarios:"选择排序的主要优点是交换次数少，当内存写入操作非常昂贵时（如在Flash存储器中），选择排序可能是一个很好的选择。此外，选择排序的实现非常简单，对于小型数组可能比更复杂的算法更有效。但对于大型数据集，其O(n²)的时间复杂度使其效率较低。",stepExplanations:{initial:"初始状态：数组尚未开始排序，所有元素均为未排序状态。",selectMin:"从剩余未排序元素中找出最小值的索引。",compare:"比较当前元素与当前最小值，更新最小值索引。",swap:"将找到的最小值与未排序序列的第一个元素交换位置。",roundComplete:"第 {{i+1}} 轮排序完成，已将第 {{i+1}} 小的元素放到正确位置。",complete:"选择排序完成，所有元素都已按升序排列。"}},insertionSort:{name:"插入排序",description:"插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。",timeComplexity:{best:"O(n)",average:"O(n²)",worst:"O(n²)"},spaceComplexity:"O(1)",stability:"稳定",scenarios:"插入排序对于小型数组或几乎已经排序的数据非常高效。在实际应用中，它常用于作为更复杂排序算法（如快速排序或归并排序）的子程序，处理小规模的子数组。插入排序也是在线算法的一个例子，可以在接收新数据时高效地对已有数据进行排序，适用于流式数据处理。",stepExplanations:{initial:"初始状态：数组尚未开始排序，所有元素均为未排序状态。",selectKey:"选择当前元素作为关键字，准备插入到已排序序列中。",compare:"将关键字与已排序序列中的元素从后向前比较。",shift:"将大于关键字的元素向后移动一位，为关键字腾出位置。",insert:"将关键字插入到正确的位置。",roundComplete:"第 {{i+1}} 轮排序完成，已将前 {{i+2}} 个元素排序。",complete:"插入排序完成，所有元素都已按升序排列。"}},mergeSort:{name:"归并排序",description:"归并排序是一种采用分治策略的排序算法。它将一个数组分成两个子数组，分别对这两个子数组进行排序，然后将排序好的子数组合并成一个有序数组。归并排序的主要优点是它的时间复杂度稳定在O(n log n)，不受输入数据的影响。",timeComplexity:{best:"O(n log n)",average:"O(n log n)",worst:"O(n log n)"},spaceComplexity:"O(n)",stability:"稳定",scenarios:"归并排序适用于需要稳定排序的场景，以及对大型数据集进行外部排序（数据不全部在内存中）的情况。由于其稳定的O(n log n)性能，它在处理大规模数据时比冒泡排序、选择排序和插入排序等O(n²)算法更高效。然而，它需要O(n)的额外空间，这在内存受限的环境中可能是一个缺点。",stepExplanations:{initial:"初始状态：数组尚未开始排序，所有元素均为未排序状态。",divide:"将数组分成两个子数组，分别进行排序。",recursiveSort:"递归地对左右子数组进行归并排序。",merge:"将两个已排序的子数组合并成一个有序数组。",compare:"比较两个子数组的当前元素，选择较小的元素放入合并数组。",copyRemaining:"将剩余元素复制到合并数组中。",complete:"归并排序完成，所有元素都已按升序排列。"}},heapSort:{name:"堆排序",description:"堆排序是一种基于比较的排序算法，利用堆这种数据结构来进行排序。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。堆排序的基本思想是将待排序序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。",timeComplexity:{best:"O(n log n)",average:"O(n log n)",worst:"O(n log n)"},spaceComplexity:"O(1)",stability:"不稳定",scenarios:"堆排序适用于需要找出最大或最小元素的场景，如优先队列的实现。它的主要优点是最坏情况下也能保证O(n log n)的时间复杂度，并且是原地排序算法，不需要额外的存储空间。堆排序特别适合于大规模数据的排序，尤其是在内存有限的环境中。然而，由于其不稳定性和缓存不友好的特性，在实践中通常不如快速排序和归并排序常用。",stepExplanations:{initial:"初始状态：数组尚未开始排序，所有元素均为未排序状态。",buildHeap:"构建大顶堆，将最大值移到堆顶。",heapify:"调整堆结构，确保父节点大于子节点。",compare:"比较父节点与子节点，确保堆的性质。",swap:"交换父节点与子节点，维护堆的性质。",extractMax:"将堆顶最大值与末尾元素交换，固定最大值位置。",rebuildHeap:"重新调整剩余元素为大顶堆。",complete:"堆排序完成，所有元素都已按升序排列。"}},shellSort:{name:"希尔排序",description:'希尔排序是插入排序的一种改进版本，也称为缩小增量排序。它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。希尔排序的核心思想是将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行一次直接插入排序。',timeComplexity:{best:"O(n log n)",average:"O(n^1.3)",worst:"O(n^2)"},spaceComplexity:"O(1)",stability:"不稳定",scenarios:"希尔排序适用于中等规模的数据排序，特别是在插入排序效率低下的情况下。它的性能优于简单的插入排序，尤其是在数据量较大时。希尔排序没有快速排序算法快，但它具有简单、易于实现的优点，并且不需要额外的内存空间。希尔排序特别适合嵌入式系统和对内存要求较高的场景。",stepExplanations:{initial:"初始状态：数组尚未开始排序，所有元素均为未排序状态。",setGap:"设置初始间隔（gap）值，将数组分割成多个子序列。",subarraySort:"对每个子序列进行插入排序。",compare:"比较间隔为gap的元素，进行插入排序。",shift:"将大于关键字的元素向后移动gap位，为关键字腾出位置。",insert:"将关键字插入到正确的位置。",reduceGap:"减小间隔值，重复子序列排序过程。",finalInsertionSort:"间隔为1时，进行最后一次插入排序，完成整个数组的排序。",complete:"希尔排序完成，所有元素都已按升序排列。"}},countingSort:{name:"计数排序",description:"计数排序是一种非比较型整数排序算法，其核心思想是将输入的数据值转化为键存储在额外开辟的数组空间中。计数排序的主要优点是其时间复杂度为O(n+k)，其中n是待排序元素的个数，k是待排序元素的范围，当k不是很大时，计数排序的效率很高。",timeComplexity:{best:"O(n+k)",average:"O(n+k)",worst:"O(n+k)"},spaceComplexity:"O(n+k)",stability:"稳定",scenarios:"计数排序适用于已知范围的整数排序，尤其是当数据范围不大时。它常用于作为基数排序的子过程，也适用于统计排序、频率排序等场景。计数排序特别适合对大量重复元素进行排序，例如对年龄、成绩等数据进行排序。",stepExplanations:{initial:"初始状态：数组尚未开始排序，所有元素均为未排序状态。",findRange:"找出数组中的最大值和最小值，确定计数范围。",initializeCount:"初始化计数数组，记录每个元素出现的次数。",countOccurrences:"统计每个元素出现的次数。",calculatePrefixSum:"计算计数数组的前缀和，确定每个元素的位置。",buildOutput:"根据计数数组构建有序输出数组。",copyResult:"将排序结果复制回原数组。",complete:"计数排序完成，所有元素都已按升序排列。"}},radixSort:{name:"基数排序",description:"基数排序是一种非比较型整数排序算法，它按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。基数排序的核心思想是将整数按位数切割成不同的数字，然后按每个位数分别比较。",timeComplexity:{best:"O(d*(n+k))",average:"O(d*(n+k))",worst:"O(d*(n+k))"},spaceComplexity:"O(n+k)",stability:"稳定",scenarios:"基数排序适用于整数排序，尤其是位数不是很多的情况。它常用于对电话号码、身份证号等长整数进行排序，也适用于作为字符串排序的一种方法。基数排序特别适合对大规模数据进行排序，例如数据库中的数据排序、搜索引擎中的关键词排序等。",stepExplanations:{initial:"初始状态：数组尚未开始排序，所有元素均为未排序状态。",findMaxDigits:"找出数组中最大元素的位数，确定排序轮数。",sortByDigit:"按当前位数对所有元素进行计数排序。",extractDigit:"提取元素的当前位数字。",countSortByDigit:"对当前位进行计数排序。",buildOutput:"根据当前位的排序结果构建输出数组。",nextDigit:"处理下一位数字，重复排序过程。",complete:"基数排序完成，所有元素都已按升序排列。"}}};class j{constructor(t,n,e){this.id=n,this.algorithmName=t,this.color=e,this.array=[],this.arraySize=20,this.sortSpeed=10,this.isSorting=!1,this.isPaused=!1,this.isStepping=!1,this.comparisonCount=0,this.swapCount=0,this.animationId=null,this.sortHistory=[],this.currentStep=-1,this.preGeneratedHistory=null,this.initialArray=[],this.startTime=null,this.endTime=null}init(t){this.array=[...t],this.initialArray=[...t],this.arraySize=t.length,this.reset()}reset(){this.isSorting=!1,this.isPaused=!1,this.isStepping=!1,this.comparisonCount=0,this.swapCount=0,this.currentStep=-1,this.startTime=null,this.endTime=null,this.array=[...this.initialArray]}getExecutionTime(){return this.startTime?this.endTime?this.endTime-this.startTime:Date.now()-this.startTime:0}start(){this.isSorting=!0,this.isPaused=!1,this.startTime=Date.now()}pause(){this.isPaused=!0,this.isSorting=!1}finish(){this.isSorting=!1,this.isPaused=!1,this.endTime=Date.now()}}class I{constructor(){this.competitionMode=!1,this.algorithmInstances=[],this.activeAlgorithmCount=2,this.algorithmColors=[{primary:"#165DFF",comparing:"#3B82F6",sorted:"#60A5FA"},{primary:"#f97316",comparing:"#FB923C",sorted:"#FDBA74"},{primary:"#10B981",comparing:"#34D399",sorted:"#6EE7B7"},{primary:"#8B5CF6",comparing:"#A78BFA",sorted:"#C4B5FD"}],this.init()}init(){this.algorithmInstances=[new j("bubble",0,this.algorithmColors[0]),new j("selection",1,this.algorithmColors[1])],this.switchToSingle()}getAlgorithmTypeMap(){return{bubbleSort:"bubble",selectionSort:"selection",insertionSort:"insertion",quickSort:"quick",mergeSort:"merge",heapSort:"heap",shellSort:"shell",countingSort:"counting",radixSort:"radix"}}switchToSingle(){this.competitionMode=!1,this.activeAlgorithmCount=1,this.algorithmContentContainer&&(this.algorithmContentContainer.classList.remove("compare-algorithms","competition-2","competition-3","competition-4"),this.algorithmContentContainer.classList.add("single-algorithm")),this.codeContent&&(this.codeContent.classList.remove("compare-algorithms","competition-2","competition-3","competition-4"),this.codeContent.classList.add("single-algorithm"))}switchToCompetition(t){this.competitionMode=!0,this.activeAlgorithmCount=t,this.ensureAlgorithmInstanceCount(t),this.algorithmContentContainer&&(this.algorithmContentContainer.classList.remove("single-algorithm","compare-algorithms","competition-2","competition-3","competition-4"),this.algorithmContentContainer.classList.add(`competition-${t}`)),this.codeContent&&(this.codeContent.classList.remove("single-algorithm","compare-algorithms","competition-2","competition-3","competition-4"),this.codeContent.classList.add(`competition-${t}`))}ensureAlgorithmInstanceCount(t){for(this.activeAlgorithmCount=t;this.algorithmInstances.length<t;){const t=this.algorithmInstances.length,n=this.getDefaultAlgorithmForIndex(t);this.algorithmInstances.push(new j(n,t,this.algorithmColors[t%this.algorithmColors.length]))}this.algorithmInstances=this.algorithmInstances.slice(0,t)}getDefaultAlgorithmForIndex(t){const n=["bubble","selection","insertion","quick"];return n[t%n.length]}updateAlgorithmInstance(t,n){this.algorithmInstances[t]&&(this.algorithmInstances[t].algorithmName=n)}getAlgorithmInstances(){return this.algorithmInstances.slice(0,this.activeAlgorithmCount)}highlightComparisonTable(){const t={bubbleSort:"冒泡排序",selectionSort:"选择排序",insertionSort:"插入排序",quickSort:"快速排序",mergeSort:"归并排序",heapSort:"堆排序",shellSort:"希尔排序",countingSort:"计数排序",radixSort:"基数排序"},n={bubble:"bubbleSort",selection:"selectionSort",insertion:"insertionSort",quick:"quickSort",merge:"mergeSort",heap:"heapSort",shell:"shellSort",counting:"countingSort",radix:"radixSort"},e=document.querySelectorAll("#explanation table tbody tr");e.forEach(t=>{t.classList.remove("bg-primary/10","bg-orange-50","bg-green-50","bg-purple-50","font-semibold"),t.querySelectorAll("td").forEach(t=>{t.classList.remove("bg-primary/10","bg-orange-50","bg-green-50","bg-purple-50","font-semibold")})}),this.getAlgorithmInstances().forEach((i,r)=>{const a=t[n[i.algorithmName]],s=["bg-primary/10","bg-orange-50","bg-green-50","bg-purple-50"][r];e.forEach(t=>{const n=t.querySelector("td:first-child");n&&n.textContent===a&&t.querySelectorAll("td").forEach(t=>{t.classList.add(s,"font-semibold")})})})}initAlgorithmArrays(t){this.algorithmInstances.forEach(n=>{n.init([...t])})}}class E{constructor(){r(this,"logGroup",null),this.array=[],this.arraySize=20,this.sortSpeed=10,this.isSorting=!1,this.isPaused=!1,this.isStepping=!1,this.comparisonCount=0,this.swapCount=0,this.animationId=null,this.currentAlgorithm="bubbleSort",this.sortGenerator=null,this.sortHistory=[],this.currentStep=-1,this.preGeneratedHistory=null,this.lastPivotIndex=-1,this.lastPivotValue=-1,this.initialArray=[],this.displayStyle="bar",this.animationDuration=500,this.performanceData={time:[],comparisons:[],swaps:[]},this.startTime=null,this.performanceChart=null,this.chartUpdateInterval=null,this.isCompetitionMode=!1,this.competitionAlgorithms=["bubble","selection","insertion","quick"],this.competitionArray=[],this.competitionSpeed=10,this.isCompetitionRunning=!1,this.isCompetitionPaused=!1,this.competitionStartTime=null,this.competitionPerformanceChart=null,this.competitionChartUpdateInterval=null,this.algorithmContainers=[],this.explanatoryDocument=new c,this.logBuffer=[],this.currentStepExplanation="",this.is3DMode=!1,this.visualization3D=null,this.barsContainer3D=null,this.toggle2DBtn=null,this.toggle3DBtn=null,requestAnimationFrame(()=>{this.initModules(),setTimeout(()=>{this.initElements(),this.setupEventListeners(),this.createNewArray(),this.competitionManager=new I,this.updateAlgorithmContent(),this.initPerformanceChart(),this.initCompetitionMode(),this.initLanguageManager(),this.init3DVisualization(),this.initFloatingPanel(),window.sortingVisualizer=this,this.addSliderEventListeners()},100)})}initModules(){new a,new s,new o,new l,new d}initElements(){this.visualizationContainer=document.getElementById("visualization-container"),this.barsContainer=document.getElementById("bars-container"),this.arraySizeSlider=document.getElementById("array-size"),this.arraySizeValue=document.getElementById("array-size-value"),this.sortSpeedSlider=document.getElementById("sort-speed"),this.sortSpeedValue=document.getElementById("sort-speed-value"),this.comparisonCountEl=document.getElementById("comparison-count"),this.swapCountEl=document.getElementById("swap-count"),this.currentArraySizeEl=document.getElementById("current-array-size"),this.newArrayBtn=document.getElementById("new-array"),this.startSortBtn=document.getElementById("start-sort"),this.pauseSortBtn=document.getElementById("pause-sort"),this.resetSortBtn=document.getElementById("reset-sort"),this.stepBackBtn=document.getElementById("step-back"),this.stepForwardBtn=document.getElementById("step-forward"),this.menuToggle=document.getElementById("menu-toggle"),this.mobileMenu=document.getElementById("mobile-menu"),this.codeTabs=document.querySelectorAll(".code-tab"),this.codeBlocks=document.querySelectorAll(".code-block"),this.algorithmTabs=document.querySelectorAll(".algorithm-tab"),this.algorithmContents=document.querySelectorAll(".algorithm-content"),this.explanationTabs=document.querySelectorAll(".explanation-tab"),this.algorithmExplanations=document.querySelectorAll(".algorithm-explanation"),this.displayStyleRadios=document.querySelectorAll('input[name="display-style"]'),this.algorithmSelector=document.getElementById("algorithm-selector"),this.mobileAlgorithmSelector=document.getElementById("mobile-algorithm-selector"),this.currentAlgorithmDisplay=document.getElementById("current-algorithm-display"),this.performanceChartCanvas=document.getElementById("performance-chart"),this.stepExplanationEl=document.getElementById("step-explanation"),this.stepNumberEl=document.getElementById("step-number"),this.customArrayModal=document.getElementById("custom-array-modal"),this.customArrayModalInput=document.getElementById("custom-array-input"),this.customArrayModalError=document.getElementById("custom-array-modal-error"),this.cancelCustomArrayBtn=document.getElementById("cancel-custom-array"),this.confirmCustomArrayBtn=document.getElementById("confirm-custom-array"),this.barsContainer3D=document.getElementById("bars-container-3d"),this.toggle2DBtn=document.getElementById("toggle-2d"),this.toggle3DBtn=document.getElementById("toggle-3d")}initPerformanceChart(){this.performanceChartCanvas&&(this.performanceChart=new Chart(this.performanceChartCanvas,{type:"line",data:{labels:[],datasets:[{label:"比较次数",data:[],borderColor:"#165DFF",backgroundColor:"rgba(22, 93, 255, 0.1)",tension:.4,fill:!0},{label:"交换次数",data:[],borderColor:"#f97316",backgroundColor:"rgba(249, 115, 22, 0.1)",tension:.4,fill:!0}]},options:{responsive:!0,maintainAspectRatio:!1,plugins:{legend:{position:"top",labels:{font:{size:12}}},tooltip:{mode:"index",intersect:!1}},scales:{x:{title:{display:!0,text:"时间 (秒)",font:{size:12}},ticks:{font:{size:10}}},y:{title:{display:!0,text:"次数",font:{size:12}},ticks:{font:{size:10}},beginAtZero:!0}},animation:{duration:0}}}))}initCompetitionMode(){this.initCompetitionPerformanceChart(),this.setupCompetitionEventListeners()}initLanguageManager(){const t=localStorage.getItem("language")||"zh";C.setLanguage(t),C.updateDOMText(),document.addEventListener("languageChanged",()=>{C.updateDOMText()})}init3DVisualization(){if(this.barsContainer3D=this.barsContainer3D||document.getElementById("bars-container-3d"),window.THREE)this.barsContainer3D&&window.Visualization3D&&(this.visualization3D=new window.Visualization3D("bars-container-3d"));else{const t=document.createElement("script");t.src="https://unpkg.com/three@0.160.0/build/three.min.js",t.onload=()=>{const t=document.createElement("script");t.src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js",t.onload=()=>{i(()=>import("./visualization-3d-D6K6EvyW.js"),[]).then(t=>{window.Visualization3D=t.Visualization3D,this.barsContainer3D&&window.Visualization3D&&(this.visualization3D=new window.Visualization3D("bars-container-3d"))})},t.onerror=()=>{console.error("Failed to load OrbitControls.js, 3D visualization may not work properly"),i(()=>import("./visualization-3d-D6K6EvyW.js"),[]).then(t=>{window.Visualization3D=t.Visualization3D})},document.head.appendChild(t)},t.onerror=()=>{console.error("Failed to load Three.js, 3D visualization may not work properly")},document.head.appendChild(t)}}initFloatingPanel(){if(document.getElementById("floating-panel"))return;const t=document.createElement("button");t.id="floating-toggle",t.className="bg-primary text-white p-3 shadow-lg hover:bg-primary/90 active:bg-primary/80 transition-all duration-300",t.innerHTML='<i class="fa fa-chevron-left"></i>',t.style.cssText="\n            position: fixed;\n            right: 0;\n            top: 50%;\n            transform: translateY(-50%);\n            border: none;\n            cursor: pointer;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            width: 40px;\n            height: 40px;\n            border-radius: 20px 0 0 20px;\n            z-index: 1001;\n            transition: all 0.3s ease;\n        ";const n=document.createElement("div");n.id="floating-panel-content",n.className="bg-card rounded-xl shadow-xl border border-gray-100 dark:border-gray-700 overflow-hidden transition-all duration-300",n.style.cssText="\n            position: fixed;\n            right: 0;\n            top: 50%;\n            transform: translateY(-50%) translateX(100%);\n            background-color: white;\n            border-radius: 20px 0 0 20px;\n            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);\n            border: 1px solid #e2e8f0;\n            overflow: hidden;\n            transition: all 0.3s ease;\n            width: 300px;\n            max-height: 80vh;\n            overflow-y: auto;\n            z-index: 1000;\n        ";const e=document.createElement("div");e.className="bg-primary text-white px-4 py-3 flex justify-between items-center",e.innerHTML='\n            <h3 class="font-semibold text-sm">分享与导出</h3>\n            <button id="close-floating-panel" class="text-white hover:text-gray-200">\n                <i class="fa fa-times"></i>\n            </button>\n        ';const i=document.createElement("div");i.className="p-4 space-y-4";const r=document.createElement("div");r.innerHTML='\n            <div class="flex justify-between items-center mb-2">\n                <label class="text-sm font-medium text-gray-700">数据导出</label>\n            </div>\n            <div class="space-y-3">\n                \x3c!-- 导出格式选择 --\x3e\n                <div>\n                    <label class="block text-xs font-medium text-gray-700 mb-1">导出格式</label>\n                    <div class="grid grid-cols-3 gap-2">\n                        <label class="flex items-center">\n                            <input type="radio" name="export-format" value="json" class="mr-1" checked>\n                            <span class="text-xs">JSON</span>\n                        </label>\n                        <label class="flex items-center">\n                            <input type="radio" name="export-format" value="csv" class="mr-1">\n                            <span class="text-xs">CSV</span>\n                        </label>\n                        <label class="flex items-center">\n                            <input type="radio" name="export-format" value="image" class="mr-1">\n                            <span class="text-xs">图片</span>\n                        </label>\n                    </div>\n                </div>\n                \n                \x3c!-- 导出内容选择 --\x3e\n                <div>\n                    <label class="block text-xs font-medium text-gray-700 mb-1">导出内容</label>\n                    <div class="space-y-1">\n                        <label class="flex items-center"><input type="checkbox" name="export-content" value="sorting-process" class="mr-1"> 排序过程</label>\n                        <label class="flex items-center"><input type="checkbox" name="export-content" value="performance-data" class="mr-1"> 性能数据</label>\n                        <label class="flex items-center"><input type="checkbox" name="export-content" value="algorithm-info" class="mr-1"> 算法信息</label>\n                    </div>\n                </div>\n                \n                \x3c!-- 导出按钮 --\x3e\n                <button id="export-data" class="control-btn bg-primary text-white hover:bg-primary/90 active:bg-primary/80 w-full">\n                    <i class="fa fa-download"></i> 导出数据\n                </button>\n            </div>\n        ';const a=document.createElement("div");a.innerHTML='\n            <div class="flex justify-between items-center mb-2">\n                <label class="text-sm font-medium text-gray-700">分享功能</label>\n            </div>\n            <div class="space-y-3">\n                \x3c!-- 生成分享链接 --\x3e\n                <div class="flex gap-2">\n                    <input type="text" id="share-link" placeholder="分享链接将显示在这里" readonly class="flex-1 bg-gray-50 border border-gray-300 text-gray-900 text-xs rounded-lg focus:ring-primary focus:border-primary block p-2">\n                    <button id="generate-share-link" class="control-btn bg-primary text-white hover:bg-primary/90 active:bg-primary/80 whitespace-nowrap">\n                        <i class="fa fa-link"></i>\n                    </button>\n                </div>\n                \n                \x3c!-- 导出为视频/GIF --\x3e\n                <div class="grid grid-cols-2 gap-2">\n                    <button id="export-as-video" class="control-btn bg-secondary text-white hover:bg-secondary/90 active:bg-secondary/80">\n                        <i class="fa fa-video-camera"></i> 导出视频\n                    </button>\n                    <button id="export-as-gif" class="control-btn bg-secondary text-white hover:bg-secondary/90 active:bg-secondary/80">\n                        <i class="fa fa-image"></i> 导出GIF\n                    </button>\n                </div>\n                \n                \x3c!-- 社交媒体分享 --\x3e\n                <div class="flex gap-2">\n                    <button id="share-to-weibo" class="control-btn bg-red-500 text-white hover:bg-red-600 active:bg-red-700 flex-1">\n                        <i class="fa fa-weibo"></i>\n                    </button>\n                    <button id="share-to-wechat" class="control-btn bg-green-500 text-white hover:bg-green-600 active:bg-green-700 flex-1">\n                        <i class="fa fa-weixin"></i>\n                    </button>\n                    <button id="share-to-twitter" class="control-btn bg-blue-400 text-white hover:bg-blue-500 active:bg-blue-600 flex-1">\n                        <i class="fa fa-twitter"></i>\n                    </button>\n                </div>\n            </div>\n        ',i.appendChild(r),i.appendChild(a),n.appendChild(e),n.appendChild(i),document.body.appendChild(n),document.body.appendChild(t);let s=!1;function o(){s=!s,s?(n.style.transform="translateY(-50%) translateX(0)",t.innerHTML='<i class="fa fa-chevron-right"></i>',t.style.right="300px",t.style.borderRadius="20px 0 0 20px"):(n.style.transform="translateY(-50%) translateX(100%)",t.innerHTML='<i class="fa fa-chevron-left"></i>',t.style.right="0",t.style.borderRadius="20px 0 0 20px")}t.addEventListener("click",o),e.querySelector("#close-floating-panel").addEventListener("click",o),this.bindShareExportEvents()}bindShareExportEvents(){const t=document.getElementById("generate-share-link"),n=document.getElementById("share-link");t&&n&&t.addEventListener("click",()=>{const t={algorithm:this.currentAlgorithm,array:this.array,arraySize:this.arraySize,sortSpeed:this.sortSpeed},e=btoa(JSON.stringify(t)),i=`${window.location.origin}${window.location.pathname}?share=${e}`;n.value=i,n.select(),document.execCommand("copy"),alert("分享链接已复制到剪贴板！")});const e=document.getElementById("export-as-video");e&&e.addEventListener("click",()=>{alert("视频导出功能开发中...")});const i=document.getElementById("export-as-gif");i&&i.addEventListener("click",()=>{alert("GIF导出功能开发中...")});const r=document.getElementById("share-to-weibo");r&&r.addEventListener("click",()=>{const t=`我在排序算法可视化工具中使用了${k[this.currentAlgorithm].name}，快来看看吧！`,n=`https://service.weibo.com/share/share.php?url=${encodeURIComponent(window.location.href)}&title=${encodeURIComponent(t)}`;window.open(n,"_blank")});const a=document.getElementById("share-to-wechat");a&&a.addEventListener("click",()=>{alert("请使用微信扫描二维码分享")});const s=document.getElementById("share-to-twitter");s&&s.addEventListener("click",()=>{const t=`I used ${k[this.currentAlgorithm].name} in the Sorting Algorithm Visualizer!`,n=`https://twitter.com/intent/tweet?url=${encodeURIComponent(window.location.href)}&text=${encodeURIComponent(t)}`;window.open(n,"_blank")})}addSliderEventListeners(){const t=document.getElementById("array-size"),n=document.getElementById("array-size-value"),e=document.getElementById("sort-speed"),i=document.getElementById("sort-speed-value");t&&n&&(t.removeEventListener("input",this.arraySizeInputHandler),this.arraySizeInputHandler=t=>{const r=t.target.value;n.textContent=r,this.isSorting||(this.arraySize=parseInt(r),this.currentArraySizeEl.textContent=r,this.sortSpeed=Math.min(5*this.arraySize,250),e.value=this.sortSpeed,i.textContent=this.sortSpeed,this.createNewArray())},t.addEventListener("input",this.arraySizeInputHandler)),e&&i&&(e.removeEventListener("input",this.sortSpeedInputHandler),this.sortSpeedInputHandler=t=>{const n=t.target.value;i.textContent=n,this.sortSpeed=parseInt(n)},e.addEventListener("input",this.sortSpeedInputHandler))}switchTo2D(){this.is3DMode=!1,this.toggle2DBtn&&this.toggle3DBtn&&(this.toggle2DBtn.classList.remove("bg-white","text-primary"),this.toggle2DBtn.classList.add("bg-primary","text-white"),this.toggle3DBtn.classList.remove("bg-primary","text-white"),this.toggle3DBtn.classList.add("bg-white","text-primary"),this.barsContainer.classList.remove("hidden"),this.barsContainer3D.classList.add("hidden"),this.renderArray())}switchTo3D(){this.is3DMode=!0,this.toggle2DBtn&&this.toggle3DBtn&&(this.toggle3DBtn.classList.remove("bg-white","text-primary"),this.toggle3DBtn.classList.add("bg-primary","text-white"),this.toggle2DBtn.classList.remove("bg-primary","text-white"),this.toggle2DBtn.classList.add("bg-white","text-primary"),this.barsContainer.classList.add("hidden"),this.barsContainer3D.classList.remove("hidden"),this.barsContainer3D&&i(()=>import("./visualization-3d-D6K6EvyW.js"),[]).then(t=>{this.visualization3D=new t.Visualization3D("bars-container-3d"),this.renderArray()}).catch(t=>{console.error("Failed to initialize 3D visualization:",t),this.switchTo2D()}))}initCompetitionPerformanceChart(){const t=document.getElementById("competition-performance-chart");t&&(this.competitionPerformanceChart=new Chart(t,{type:"line",data:{labels:[],datasets:[{label:"算法1 - 比较次数",data:[],borderColor:"#165DFF",backgroundColor:"rgba(22, 93, 255, 0.1)",tension:.4,fill:!0},{label:"算法1 - 交换次数",data:[],borderColor:"#165DFF",backgroundColor:"rgba(22, 93, 255, 0.05)",tension:.4,fill:!1,borderDash:[5,5],borderWidth:2},{label:"算法2 - 比较次数",data:[],borderColor:"#f97316",backgroundColor:"rgba(249, 115, 22, 0.1)",tension:.4,fill:!0},{label:"算法2 - 交换次数",data:[],borderColor:"#f97316",backgroundColor:"rgba(249, 115, 22, 0.05)",tension:.4,fill:!1,borderDash:[5,5],borderWidth:2}]},options:{responsive:!0,maintainAspectRatio:!1,plugins:{legend:{position:"top",labels:{font:{size:12}}},tooltip:{mode:"index",intersect:!1}},scales:{x:{title:{display:!0,text:"时间 (秒)",font:{size:12}},ticks:{font:{size:10}}},y:{title:{display:!0,text:"比较次数",font:{size:12}},ticks:{font:{size:10}},beginAtZero:!0}},animation:{duration:0}}}))}setupCompetitionEventListeners(){const t=document.getElementById("single-mode-btn"),n=document.getElementById("competition-mode-btn");t&&t.addEventListener("click",()=>this.switchToSingleMode()),n&&n.addEventListener("click",()=>this.switchToCompetitionMode());for(let p=0;p<2;p++){const t=document.getElementById(`algorithm-select-${p}`);t&&t.addEventListener("change",t=>{this.initializeAlgorithmView(p,t.target.value)})}const e=document.getElementById("competition-array-size"),i=document.getElementById("competition-array-size-value"),r=document.getElementById("competition-speed"),a=document.getElementById("competition-speed-value");e&&i&&e.addEventListener("input",t=>{const n=parseInt(t.target.value);i.textContent=n;const e=Math.min(5*n,250);r&&a&&(r.value=e,a.textContent=e,this.competitionSpeed=e),this.isCompetitionRunning&&!this.isCompetitionPaused||this.generateNewCompetitionArray()}),r&&a&&r.addEventListener("input",t=>{const n=parseInt(t.target.value);a.textContent=n,this.competitionSpeed=n});const s=document.getElementById("competition-start-btn");s&&s.addEventListener("click",()=>{this.isCompetitionPaused?this.resumeCompetition():this.startCompetition()});const o=document.getElementById("competition-pause-btn");o&&o.addEventListener("click",()=>{this.isCompetitionPaused?this.resumeCompetition():this.pauseCompetition()});const l=document.getElementById("competition-new-array-btn"),d=document.getElementById("competition-new-array-menu");l&&d&&(l.addEventListener("click",()=>{d.classList.contains("hidden")?(d.classList.remove("hidden"),setTimeout(()=>{d.classList.remove("opacity-0","translate-y-2"),d.classList.add("opacity-100","translate-y-0")},10)):(d.classList.remove("opacity-100","translate-y-0"),d.classList.add("opacity-0","translate-y-2"),setTimeout(()=>{d.classList.add("hidden")},300))}),l.addEventListener("mouseenter",()=>{d.classList.contains("hidden")&&(d.classList.remove("hidden"),setTimeout(()=>{d.classList.remove("opacity-0","translate-y-2"),d.classList.add("opacity-100","translate-y-0")},10))}),l.addEventListener("mouseleave",()=>{setTimeout(()=>{d.matches(":hover")||(d.classList.remove("opacity-100","translate-y-0"),d.classList.add("opacity-0","translate-y-2"),setTimeout(()=>{d.classList.add("hidden")},300))},100)}),d.addEventListener("mouseleave",()=>{d.classList.remove("opacity-100","translate-y-0"),d.classList.add("opacity-0","translate-y-2"),setTimeout(()=>{d.classList.add("hidden")},300)})),document.addEventListener("click",t=>{if(t.target.hasAttribute("data-distribution")){const n=t.target.getAttribute("data-distribution");this.generateNewCompetitionArray(n)}"custom"===t.target.getAttribute("data-action")&&this.openCustomArrayModal()});const c=document.getElementById("competition-reset-btn");c&&c.addEventListener("click",()=>{this.resetCompetition()})}initializeAlgorithmView(t,n){const e=document.getElementById(`algorithm-name-${t}`),i=e?e.textContent:"",r=this.getAlgorithmName(n);i!==r&&(e&&(e.textContent=r),this.competitionManager.updateAlgorithmInstance(t,n),this.isCompetitionRunning||this.initCompetitionVisualization())}resetPerformanceData(){this.performanceData={time:[],comparisons:[],swaps:[]},this.startTime=null,this.performanceChart&&(this.performanceChart.data.labels=[],this.performanceChart.data.datasets.forEach(t=>{t.data=[]}),this.performanceChart.update("none")),this.chartUpdateInterval&&(clearInterval(this.chartUpdateInterval),this.chartUpdateInterval=null)}resetCompetitionPerformanceData(){this.competitionPerformanceChart&&(this.competitionPerformanceChart.data.labels=[],this.competitionPerformanceChart.data.datasets.forEach(t=>{t.data=[]}),this.competitionPerformanceChart.update("none")),this.competitionChartUpdateInterval&&(clearInterval(this.competitionChartUpdateInterval),this.competitionChartUpdateInterval=null)}switchToSingleMode(){this.isCompetitionMode=!1;const t=document.getElementById("single-mode-btn"),n=document.getElementById("competition-mode-btn");t&&(t.classList.remove("bg-transparent","text-gray-700","hover:bg-gray-200"),t.classList.add("bg-primary","text-white","shadow-md","hover:shadow-lg")),n&&(n.classList.remove("bg-primary","text-white","shadow-md","hover:shadow-lg"),n.classList.add("bg-transparent","text-gray-700","hover:bg-gray-200"));const e=document.getElementById("single-algorithm-layout"),i=document.getElementById("competition-layout"),r=document.getElementById("competition-config-panel");i&&(i.classList.add("opacity-0","scale-95"),i.classList.remove("opacity-100","scale-100"),setTimeout(()=>{i&&i.classList.add("hidden"),r&&r.classList.add("hidden")},500)),e&&(e.classList.remove("hidden"),setTimeout(()=>{e&&(e.classList.add("opacity-100","scale-100"),e.classList.remove("opacity-0","scale-95"))},50)),this.isCompetitionRunning=!1,this.isCompetitionPaused=!1;const a=document.querySelector(".keyboard-shortcuts");a&&a.classList.remove("hidden")}switchToCompetitionMode(){this.isCompetitionMode=!0;const t=document.getElementById("single-mode-btn"),n=document.getElementById("competition-mode-btn");t&&(t.classList.remove("bg-primary","text-white","shadow-md","hover:shadow-lg"),t.classList.add("bg-transparent","text-gray-700","hover:bg-gray-200")),n&&(n.classList.remove("bg-transparent","text-gray-700","hover:bg-gray-200"),n.classList.add("bg-primary","text-white","shadow-md","hover:shadow-lg"));const e=document.getElementById("single-algorithm-layout"),i=document.getElementById("competition-layout"),r=document.getElementById("competition-config-panel");e&&(e.classList.add("opacity-0","scale-95"),e.classList.remove("opacity-100","scale-100"),setTimeout(()=>{e&&e.classList.add("hidden")},500)),i&&(i.classList.remove("hidden"),setTimeout(()=>{i&&(i.classList.add("opacity-100","scale-100"),i.classList.remove("opacity-0","scale-95")),r&&r.classList.remove("hidden")},50)),this.competitionManager.switchToCompetition(2),this.updateCompetitionLayout(2);const a=document.querySelector(".keyboard-shortcuts");a&&a.classList.add("hidden")}onAlgorithmCountChange(t){const n=parseInt(t);for(let e=0;e<4;e++){const t=document.getElementById(`algorithm-select-container-${e}`);t&&(e<n?t.classList.remove("hidden"):t.classList.add("hidden"))}this.updateCompetitionLayout(n),this.competitionPerformanceChart&&(this.competitionPerformanceChart.data.datasets[2].hidden=n<3,this.competitionPerformanceChart.data.datasets[3].hidden=n<4,this.competitionPerformanceChart.update("none"))}updateCompetitionLayout(t=2){for(let e=2;e<=4;e++){const t=document.getElementById(`competition-layout-${e}`);t&&t.classList.add("hidden")}const n=document.getElementById(`competition-layout-${t}`);n&&n.classList.remove("hidden")}startCompetition(){var t;this.isCompetitionRunning=!0,this.isCompetitionPaused=!1,this.competitionStartTime=Date.now();const n=parseInt((null==(t=document.getElementById("competition-array-size"))?void 0:t.value)||"20"),e=document.getElementById("competition-speed"),i=document.getElementById("competition-speed-value");if(e&&i){const t=parseInt(e.value);this.competitionSpeed=t,i.textContent=t}this.competitionAlgorithms=[];for(let s=0;s<2;s++){const t=document.getElementById(`algorithm-select-${s}`);t&&this.competitionAlgorithms.push(t.value)}this.competitionArray&&this.competitionArray.length===n||(this.competitionArray=this.generateArray(n,"random")),this.competitionManager.ensureAlgorithmInstanceCount(2),this.competitionManager.initAlgorithmArrays(this.competitionArray);for(let s=0;s<2;s++)this.competitionManager.updateAlgorithmInstance(s,this.competitionAlgorithms[s]);for(let s=0;s<2;s++){const t=document.getElementById(`algorithm-name-${s}`);t&&(t.textContent=this.getAlgorithmName(this.competitionAlgorithms[s]))}const r=document.getElementById("competition-array-size-display");r&&(r.textContent=n);const a=document.getElementById("competition-pause-btn");a&&(a.disabled=!1),this.resetCompetitionPerformanceData(),this.initCompetitionVisualization(),this.startCompetitionPerformanceTracking(),this.startParallelExecution()}resetCompetition(){this.isCompetitionRunning=!1,this.isCompetitionPaused=!1,this.competitionStartTime=null;const t=document.getElementById("competition-pause-btn");t&&(t.disabled=!0,t.textContent="暂停",t.className="w-full px-4 py-2 bg-yellow-500 text-white rounded-lg font-medium hover:bg-yellow-600 transition-all duration-200 shadow-sm hover:shadow-md active:scale-95"),this.competitionManager.activeAlgorithmCount,this.competitionManager.initAlgorithmArrays(this.competitionArray||this.array);for(let n=0;n<4;n++){const t=document.getElementById(`algorithm-status-${n}`);t&&(t.textContent="就绪",t.className="text-xs font-medium");const e=document.getElementById(`comparison-count-${n}`);e&&(e.textContent="0");const i=document.getElementById(`swap-count-${n}`);i&&(i.textContent="0");const r=document.getElementById(`execution-time-${n}`);r&&(r.textContent="0ms")}this.resetCompetitionPerformanceData(),this.initCompetitionVisualization()}generateArray(t,n){const e=[];switch(n){case"sorted":for(let r=0;r<t;r++)e.push(5*r+1);break;case"reverse":for(let r=t;r>0;r--)e.push(5*r+1);break;case"nearly-sorted":for(let r=0;r<t;r++)e.push(5*r+1);const n=Math.max(1,Math.floor(.1*t));for(let r=0;r<n;r++){const n=Math.floor(Math.random()*t),i=Math.floor(Math.random()*t);[e[n],e[i]]=[e[i],e[n]]}break;case"few-unique":const i=[10,20,30,40,50];for(let r=0;r<t;r++)e.push(i[Math.floor(Math.random()*i.length)]);break;default:for(let r=0;r<t;r++)e.push(Math.floor(100*Math.random())+1)}return e}getAlgorithmName(t){return{bubble:"冒泡排序",selection:"选择排序",insertion:"插入排序",quick:"快速排序",merge:"归并排序",heap:"堆排序",shell:"希尔排序",counting:"计数排序",radix:"基数排序"}[t]||t}getAlgorithmComplexity(t){return{bubble:{time:"O(n²)",space:"O(1)"},selection:{time:"O(n²)",space:"O(1)"},insertion:{time:"O(n²)",space:"O(1)"},quick:{time:"O(n log n)",space:"O(log n)"},merge:{time:"O(n log n)",space:"O(n)"},heap:{time:"O(n log n)",space:"O(1)"},shell:{time:"O(n log² n)",space:"O(1)"},counting:{time:"O(n + k)",space:"O(k)"},radix:{time:"O(nk)",space:"O(n + k)"}}[t]||{time:"O(n)",space:"O(1)"}}initCompetitionVisualization(){this.competitionManager.getAlgorithmInstances().forEach((t,n)=>{this.renderCompetitionArray(t.array,n,[])})}startCompetitionPerformanceTracking(){this.updateCompetitionPerformance(),this.competitionChartUpdateInterval=setInterval(()=>{this.updateCompetitionPerformance()},1e3)}updateCompetitionPerformance(){if(!this.isCompetitionRunning)return;const t=Math.floor((Date.now()-this.competitionStartTime)/1e3),n=document.getElementById("competition-elapsed-time");n&&(n.textContent=Date.now()-this.competitionStartTime+"ms"),this.competitionPerformanceChart&&(this.competitionPerformanceChart.data.labels.includes(t.toString())||this.competitionPerformanceChart.data.labels.push(t.toString()),this.competitionManager.getAlgorithmInstances().forEach((n,e)=>{const i=document.getElementById(`comparison-count-${e}`);i&&(i.textContent=n.comparisonCount);const r=document.getElementById(`swap-count-${e}`);r&&(r.textContent=n.swapCount);const a=document.getElementById(`execution-time-${e}`);a&&(a.textContent=`${n.getExecutionTime()}ms`);const s=this.competitionPerformanceChart.data.datasets[2*e],o=this.competitionPerformanceChart.data.datasets[2*e+1];if(s&&o){s.data[t]=n.comparisonCount,o.data[t]=n.swapCount;for(let e=0;e<t;e++)void 0===s.data[e]&&(s.data[e]=s.data[e-1]||n.comparisonCount),void 0===o.data[e]&&(o.data[e]=o.data[e-1]||n.swapCount)}}),this.competitionPerformanceChart.update("none")),this.updateCompetitionTotalStats()}updateCompetitionTotalStats(){const t=this.competitionManager.getAlgorithmInstances();let n=0,e=0;t.forEach(t=>{n+=t.comparisonCount,e+=t.swapCount});const i=document.getElementById("total-comparisons");i&&(i.textContent=n);const r=document.getElementById("total-swaps");r&&(r.textContent=e)}startParallelExecution(){this.competitionManager.getAlgorithmInstances().forEach((t,n)=>{this.executeAlgorithm(t,n)})}executeAlgorithm(t,n){const e={bubble:p,selection:m,insertion:h,quick:g,merge:u,heap:b,shell:x,counting:y,radix:f}[t.algorithmName];if(!e)return;t.start();const i=e(t.array);t.sortHistory=i.history,t.currentStep=0;const r=document.getElementById(`algorithm-status-${n}`);r&&(r.textContent="运行中",r.className="text-xs font-medium text-yellow-500"),setTimeout(()=>{this.runAlgorithmSteps(t,n)},0)}runAlgorithmSteps(t,n){if(this.isCompetitionRunning&&!t.isPaused)if(t.currentStep<t.sortHistory.length){if(this.executeAlgorithmStep(t,n),t.isSorting&&!t.isPaused){const e=1e3/this.competitionSpeed;setTimeout(()=>{this.runAlgorithmSteps(t,n)},e)}}else{t.finish();const e=document.getElementById(`algorithm-status-${n}`);e&&(e.textContent="完成",e.className="text-xs font-medium text-green-500"),this.checkCompetitionCompletion()}}executeAlgorithmStep(t,n){if(t.currentStep>=t.sortHistory.length)return;const e=t.sortHistory[t.currentStep];t.comparisonCount=e.comparisonCount,t.swapCount=e.swapCount,t.array=[...e.array],this.renderCompetitionArray(e.array,n,e.highlightIndices||[],e.sortedIndices||[]),t.currentStep++}renderCompetitionArray(t,n,e=[],i=[]){const r=document.getElementById(`bars-container-${n}`);if(!r)return;r.innerHTML="";const a=r.clientWidth,s=Math.max(6,(a-2*t.length)/t.length),o=r.clientHeight-20,l=Math.max(...t),d=["#165DFF","#f97316","#10B981","#8B5CF6"],c=d[n%d.length];t.forEach((t,a)=>{const d=document.createElement("div");d.className="bar-shadow transition-all duration-200 ease-out rounded-sm",d.style.width=`${s}px`,d.style.height=t/l*o+"px",i.includes(a)?(d.style.backgroundColor="#60A5FA",d.style.zIndex="3"):e.includes(a)?(d.style.backgroundColor=c,d.style.zIndex="10",d.style.transform="scaleY(1.05)"):(d.style.backgroundColor="#64748b",d.style.zIndex="1"),this.isCompetitionRunning||(d.draggable=!0,d.addEventListener("dragstart",t=>{t.dataTransfer.setData("text/plain",`${n},${a}`),d.style.opacity="0.5",d.style.cursor="grabbing"}),d.addEventListener("dragend",()=>{d.style.opacity="1",d.style.cursor="grab"}),d.addEventListener("dragenter",t=>{t.preventDefault(),d.style.border="2px dashed #165DFF"}),d.addEventListener("dragleave",()=>{d.style.border=""}),d.addEventListener("dragover",t=>{t.preventDefault()}),d.addEventListener("drop",t=>{t.preventDefault(),d.style.border="";const[e,i]=t.dataTransfer.getData("text/plain").split(",").map(Number),r=a;if(e===n){[this.competitionArray[i],this.competitionArray[r]]=[this.competitionArray[r],this.competitionArray[i]],this.competitionManager.initAlgorithmArrays(this.competitionArray),this.initCompetitionVisualization();const t=document.getElementById("competition-array-size-display");t&&(t.textContent=this.competitionArray.length)}}),d.addEventListener("mouseenter",()=>{d.style.cursor="grab"})),r.appendChild(d)})}checkCompetitionCompletion(){const t=this.competitionManager.getAlgorithmInstances();t.every(t=>!t.isSorting&&!t.isPaused)&&(this.isCompetitionRunning=!1,this.competitionEndTime=Date.now(),t.forEach((t,n)=>{const e=document.getElementById(`algorithm-status-${n}`);e&&(e.textContent="完成",e.className="text-xs font-medium text-green-500")}),this.updateCompetitionPerformance(),this.competitionChartUpdateInterval&&(clearInterval(this.competitionChartUpdateInterval),this.competitionChartUpdateInterval=null))}pauseCompetition(){this.isCompetitionPaused=!0,this.isCompetitionRunning=!1;const t=document.getElementById("competition-pause-btn");t&&(t.textContent="继续",t.className="w-full px-4 py-2 bg-blue-500 text-white rounded-lg font-medium hover:bg-blue-600 transition-all duration-200 shadow-sm hover:shadow-md active:scale-95"),this.competitionManager.getAlgorithmInstances().forEach((t,n)=>{t.pause();const e=document.getElementById(`algorithm-status-${n}`);e&&(e.textContent="暂停",e.className="text-xs font-medium text-orange-500")})}resumeCompetition(){this.isCompetitionPaused=!1,this.isCompetitionRunning=!0;const t=document.getElementById("competition-pause-btn");t&&(t.textContent="暂停",t.className="w-full px-4 py-2 bg-yellow-500 text-white rounded-lg font-medium hover:bg-yellow-600 transition-all duration-200 shadow-sm hover:shadow-md active:scale-95"),this.competitionManager.getAlgorithmInstances().forEach((t,n)=>{t.isSorting=!0,t.isPaused=!1;const e=document.getElementById(`algorithm-status-${n}`);e&&(e.textContent="运行中",e.className="text-xs font-medium text-yellow-500"),this.runAlgorithmSteps(t,n)})}generateNewCompetitionArray(t="random"){var n;const e=parseInt((null==(n=document.getElementById("competition-array-size"))?void 0:n.value)||"20");this.competitionArray=this.generateArray(e,t),this.competitionManager.initAlgorithmArrays(this.competitionArray);const i=document.getElementById("competition-array-size-display");i&&(i.textContent=e);const r=Math.min(5*e,500);this.competitionSpeed=r;const a=document.getElementById("competition-speed"),s=document.getElementById("competition-speed-value");a&&s&&(a.value=r,s.textContent=r),this.resetCompetitionPerformanceData(),this.initCompetitionVisualization()}validateCustomArray(t){if(!t||""===t.trim())return{valid:!1,message:"请输入数组"};const n=t.trim().split(",").map(t=>t.trim());if(0===n.length)return{valid:!1,message:"请输入有效的数字数组"};const e=[];for(const i of n){const t=parseFloat(i);if(isNaN(t))return{valid:!1,message:`"${i}" 不是有效的数字`};e.push(t)}return e.length<5||e.length>50?{valid:!1,message:`数组大小必须在5到50之间，当前大小为${e.length}`}:{valid:!0,numbers:e}}analyzeArrayFeatures(t){if(!t||0===t.length)return{};const n={size:t.length,isSorted:!0,isReverseSorted:!0,nearlySorted:0,uniqueValues:new Set(t).size,uniqueRatio:new Set(t).size/t.length,minValue:Math.min(...t),maxValue:Math.max(...t),range:Math.max(...t)-Math.min(...t),isFewUnique:new Set(t).size<.2*t.length};let e=0;for(let i=0;i<t.length-1;i++)t[i]>t[i+1]&&(n.isSorted=!1,e++),t[i]<t[i+1]&&(n.isReverseSorted=!1);return n.sortedDegree=1-e/(t.length*(t.length-1)/2),n.nearlySorted=n.sortedDegree>.8,n}recommendAlgorithm(t){const n=[];t.isSorted?(n.push({algorithm:"bubbleSort",reason:"数组已经是有序的，冒泡排序在这种情况下时间复杂度为O(n)",performance:"优秀",priority:10}),n.push({algorithm:"insertionSort",reason:"数组已经是有序的，插入排序在这种情况下时间复杂度为O(n)",performance:"优秀",priority:9})):t.nearlySorted?(n.push({algorithm:"insertionSort",reason:"数组近乎有序，插入排序对近乎有序的数据具有良好的性能",performance:"优秀",priority:10}),n.push({algorithm:"bubbleSort",reason:"数组近乎有序，冒泡排序在这种情况下性能较好",performance:"良好",priority:8})):t.isReverseSorted?(n.push({algorithm:"heapSort",reason:"数组是逆序的，堆排序对逆序数据具有稳定的O(n log n)性能",performance:"优秀",priority:9}),n.push({algorithm:"quickSort",reason:"快速排序对逆序数据性能较好",performance:"良好",priority:8})):t.isFewUnique?(n.push({algorithm:"countingSort",reason:"数组只有少数唯一值，计数排序可以在线性时间内完成排序",performance:"优秀",priority:10}),n.push({algorithm:"radixSort",reason:"数组只有少数唯一值，基数排序可以在线性时间内完成排序",performance:"优秀",priority:9})):t.range<1e3&&n.push({algorithm:"countingSort",reason:"数组范围较小，计数排序可以在线性时间内完成排序",performance:"优秀",priority:9}),t.size<20?(n.push({algorithm:"insertionSort",reason:"数组较小，插入排序实现简单且性能良好",performance:"优秀",priority:8}),n.push({algorithm:"selectionSort",reason:"数组较小，选择排序实现简单",performance:"良好",priority:7})):t.size<100?(n.push({algorithm:"quickSort",reason:"数组大小适中，快速排序平均性能优秀",performance:"优秀",priority:9}),n.push({algorithm:"mergeSort",reason:"数组大小适中，归并排序具有稳定的O(n log n)性能",performance:"良好",priority:8}),n.push({algorithm:"heapSort",reason:"数组大小适中，堆排序具有稳定的O(n log n)性能",performance:"良好",priority:7})):(n.push({algorithm:"quickSort",reason:"数组较大，快速排序平均性能优秀",performance:"优秀",priority:10}),n.push({algorithm:"mergeSort",reason:"数组较大，归并排序具有稳定的O(n log n)性能",performance:"优秀",priority:9}),n.push({algorithm:"heapSort",reason:"数组较大，堆排序具有稳定的O(n log n)性能且不需要额外空间",performance:"良好",priority:8}));const e=[...new Map(n.map(t=>[t.algorithm,t])).values()];return e.sort((t,n)=>n.priority-t.priority),e.slice(0,3)}displayRecommendations(t){const n=document.getElementById("algorithm-recommendation");if(!n)return;if(0===t.length)return void(n.innerHTML='<p class="text-sm text-gray-600">无法生成算法推荐</p>');const e={bubbleSort:"冒泡排序",selectionSort:"选择排序",insertionSort:"插入排序",quickSort:"快速排序",mergeSort:"归并排序",heapSort:"堆排序",shellSort:"希尔排序",countingSort:"计数排序",radixSort:"基数排序"};let i='<div class="space-y-3">';t.forEach((t,n)=>{const r=e[t.algorithm]||t.algorithm;i+=`\n                <div class="bg-white p-2 rounded-md shadow-sm border border-gray-200">\n                    <div class="flex items-center justify-between">\n                        <h4 class="font-medium text-sm text-primary">\n                            ${n+1}. ${r}\n                        </h4>\n                        <span class="text-xs font-semibold px-2 py-0.5 rounded-full bg-${"优秀"===t.performance?"green":"blue"}-100 text-${"优秀"===t.performance?"green":"blue"}-700">\n                            ${t.performance}\n                        </span>\n                    </div>\n                    <p class="text-xs text-gray-600 mt-1">${t.reason}</p>\n                </div>\n            `}),i+="</div>",n.innerHTML=i}openCustomArrayModal(){this.customArrayModal&&this.customArrayModalInput&&(this.customArrayModalInput.value="",this.customArrayModalError.classList.add("hidden"),this.customArrayModal.classList.remove("hidden"),this.customArrayModalInput.focus())}closeCustomArrayModal(){this.customArrayModal&&this.customArrayModal.classList.add("hidden")}applyCustomArrayFromModal(){if(!this.customArrayModalInput||!this.customArrayModalError)return;const t=this.customArrayModalInput.value,n=this.validateCustomArray(t);if(!n.valid)return this.customArrayModalError.textContent=n.message,void this.customArrayModalError.classList.remove("hidden");this.customArrayModalError.classList.add("hidden"),this.array=n.numbers,this.arraySize=this.array.length,this.initialArray=[...this.array],this.arraySizeSlider.value=this.arraySize,this.arraySizeValue.textContent=this.arraySize,this.currentArraySizeEl.textContent=this.arraySize,this.comparisonCount=0,this.swapCount=0,this.currentStep=-1,this.updateCounters(),this.resetPerformanceData(),this.startSortBtn.disabled=!1,this.newArrayBtn.disabled=!1,this.arraySizeSlider.disabled=!1,this.pauseSortBtn.disabled=!0,this.pauseSortBtn.innerHTML='<i class="fa fa-pause"></i> 暂停',w.setCurrent(this.array,this.currentAlgorithm),this.preGeneratedHistory=w.generateCurrentHistory(),this.sortHistory=this.preGeneratedHistory.history,this.updateStepButtons(),this.renderArray();const e=document.getElementById("algorithm-log");e&&(e.innerHTML=""),this.closeCustomArrayModal()}startPerformanceTracking(){this.resetPerformanceData(),this.startTime=Date.now(),this.chartUpdateInterval=setInterval(()=>{this.updatePerformanceData()},1e3)}stopPerformanceTracking(){this.chartUpdateInterval&&(clearInterval(this.chartUpdateInterval),this.chartUpdateInterval=null),this.updatePerformanceData()}updatePerformanceData(){if(!this.startTime||!this.performanceChart)return;const t=(Date.now()-this.startTime)/1e3;this.performanceData.time.push(t),this.performanceData.comparisons.push(this.comparisonCount),this.performanceData.swaps.push(this.swapCount),this.performanceChart.data.labels=this.performanceData.time,this.performanceChart.data.datasets[0].data=this.performanceData.comparisons,this.performanceChart.data.datasets[1].data=this.performanceData.swaps,this.performanceChart.update("none")}setupEventListeners(){document.querySelectorAll('a[href^="#"]').forEach(t=>{t.addEventListener("click",function(t){t.preventDefault();const n=this.getAttribute("href");let e;if("#algorithm-principle"===n||"#complexity-analysis"===n||"#application-scenarios"===n){const t=document.querySelectorAll(".algorithm-explanation:not(.hidden)");for(const i of t){const t=i.querySelector(n);if(t){e=t;break}}}else e=document.querySelector(n);if(e){const t=document.querySelector("header").offsetHeight,n=e.offsetTop-t;window.scrollTo({top:n,behavior:"smooth"});const i=document.getElementById("mobile-menu");i&&i.classList.add("hidden")}})}),this.arraySizeSlider&&this.arraySizeValue&&(this.arraySizeSlider.value=this.arraySize,this.arraySizeValue.textContent=this.arraySize,this.sortSpeed=Math.min(5*this.arraySize,250),this.sortSpeedSlider.value=this.sortSpeed,this.sortSpeedValue.textContent=this.sortSpeed,this.arraySizeSlider.addEventListener("input",t=>{this.isSorting||(this.arraySize=parseInt(t.target.value),this.arraySizeValue.textContent=this.arraySize,this.currentArraySizeEl.textContent=this.arraySize,this.sortSpeed=Math.min(5*this.arraySize,250),this.sortSpeedSlider.value=this.sortSpeed,this.sortSpeedValue.textContent=this.sortSpeed,this.createNewArray())})),this.sortSpeedSlider&&this.sortSpeedValue&&(this.sortSpeedSlider.value=this.sortSpeed,this.sortSpeedValue.textContent=this.sortSpeed,this.sortSpeedSlider.addEventListener("input",t=>{this.sortSpeed=parseInt(t.target.value),this.sortSpeedValue.textContent=this.sortSpeed}));const t=document.getElementById("generate-share-link"),n=document.getElementById("share-link");t&&n&&t.addEventListener("click",()=>{const t={algorithm:this.currentAlgorithm,array:this.array,arraySize:this.arraySize,sortSpeed:this.sortSpeed},e=btoa(JSON.stringify(t)),i=`${window.location.origin}${window.location.pathname}?share=${e}`;n.value=i,n.select(),document.execCommand("copy"),alert("分享链接已复制到剪贴板！")});const e=document.getElementById("export-as-video");e&&e.addEventListener("click",()=>{alert("视频导出功能开发中...")});const i=document.getElementById("export-as-gif");i&&i.addEventListener("click",()=>{alert("GIF导出功能开发中...")});const r=document.getElementById("share-to-weibo");r&&r.addEventListener("click",()=>{const t=`我在排序算法可视化工具中使用了${k[this.currentAlgorithm].name}，快来看看吧！`,n=`https://service.weibo.com/share/share.php?url=${encodeURIComponent(window.location.href)}&title=${encodeURIComponent(t)}`;window.open(n,"_blank")});const a=document.getElementById("share-to-wechat");a&&a.addEventListener("click",()=>{alert("请使用微信扫描二维码分享")});const s=document.getElementById("share-to-twitter");s&&s.addEventListener("click",()=>{const t=`I used ${k[this.currentAlgorithm].name} in the Sorting Algorithm Visualizer!`,n=`https://twitter.com/intent/tweet?url=${encodeURIComponent(window.location.href)}&text=${encodeURIComponent(t)}`;window.open(n,"_blank")}),this.handleShareLink();const o=document.getElementById("new-array-menu");this.newArrayBtn.addEventListener("mouseenter",()=>{o.classList.remove("hidden")}),this.newArrayBtn.addEventListener("mouseleave",t=>{setTimeout(()=>{o.matches(":hover")||o.classList.add("hidden")},100)}),o.addEventListener("mouseleave",()=>{o.classList.add("hidden")}),o.querySelectorAll("button[data-array-type]").forEach(t=>{t.addEventListener("click",t=>{const n=t.target.getAttribute("data-array-type");"custom"===n?this.openCustomArrayModal():this.createNewArray(n),o.classList.add("hidden")})}),this.newArrayBtn.addEventListener("click",()=>this.createNewArray()),this.startSortBtn.addEventListener("click",()=>this.startSort()),this.pauseSortBtn.addEventListener("click",()=>this.togglePause()),this.resetSortBtn.addEventListener("click",()=>this.resetSort()),this.stepBackBtn.addEventListener("click",()=>this.stepBack()),this.stepForwardBtn.addEventListener("click",()=>this.stepForward()),this.cancelCustomArrayBtn&&this.cancelCustomArrayBtn.addEventListener("click",()=>{this.closeCustomArrayModal()}),this.confirmCustomArrayBtn&&this.confirmCustomArrayBtn.addEventListener("click",()=>{this.applyCustomArrayFromModal()}),this.customArrayModalInput&&this.customArrayModalInput.addEventListener("keypress",t=>{"Enter"===t.key&&this.applyCustomArrayFromModal()}),this.customArrayModal&&this.customArrayModal.addEventListener("click",t=>{t.target===this.customArrayModal&&this.closeCustomArrayModal()}),this.algorithmSelector.addEventListener("change",t=>{const n=t.target.value;this.isSorting&&!this.isPaused||(this.currentAlgorithm=n,this.updateAlgorithmContent(),this.mobileAlgorithmSelector.value=this.currentAlgorithm,this.isSorting&&(this.isSorting=!1,this.isPaused=!1,this.animationId&&(clearTimeout(this.animationId),this.animationId=null)),this.comparisonCount=0,this.swapCount=0,this.isStepping=!0,w.setCurrent(this.array,this.currentAlgorithm),this.preGeneratedHistory=w.generateCurrentHistory(),this.sortHistory=this.preGeneratedHistory.history,this.currentStep=-1,this.updateCounters(),this.renderArray(),this.startSortBtn.disabled=!1,this.pauseSortBtn.disabled=!0,this.pauseSortBtn.innerHTML='<i class="fa fa-pause"></i> 暂停',this.updateStepButtons())}),this.mobileAlgorithmSelector.addEventListener("change",t=>{const n=t.target.value;this.isSorting&&!this.isPaused||(this.currentAlgorithm=n,this.updateAlgorithmContent(),this.algorithmSelector.value=this.currentAlgorithm,this.isSorting&&(this.isSorting=!1,this.isPaused=!1,this.animationId&&(clearTimeout(this.animationId),this.animationId=null)),this.comparisonCount=0,this.swapCount=0,this.isStepping=!0,w.setCurrent(this.array,this.currentAlgorithm),this.preGeneratedHistory=w.generateCurrentHistory(),this.sortHistory=this.preGeneratedHistory.history,this.currentStep=-1,this.updateCounters(),this.renderArray(),this.startSortBtn.disabled=!1,this.pauseSortBtn.disabled=!0,this.pauseSortBtn.innerHTML='<i class="fa fa-pause"></i> 暂停',this.updateStepButtons())}),this.menuToggle&&this.mobileMenu&&this.menuToggle.addEventListener("click",()=>{this.mobileMenu.classList.toggle("hidden")}),this.algorithmTabs.forEach(t=>{t.addEventListener("click",()=>{const n=t.getAttribute("data-algorithm");this.algorithmTabs.forEach(t=>{t.classList.remove("border-primary","text-primary"),t.classList.add("border-transparent","text-gray-500")}),t.classList.remove("border-transparent","text-gray-500"),t.classList.add("border-primary","text-primary"),document.querySelectorAll(".algorithm-content").forEach(t=>{t.getAttribute("data-algorithm")===n?t.classList.remove("hidden"):t.classList.add("hidden")})})}),this.codeTabs.forEach(t=>{t.addEventListener("click",()=>{const n=t.getAttribute("data-lang");this.codeTabs.forEach(t=>{t.classList.remove("border-primary","text-primary"),t.classList.add("border-transparent","text-gray-500")}),t.classList.remove("border-transparent","text-gray-500"),t.classList.add("border-primary","text-primary"),document.querySelectorAll(".algorithm-content:not(.hidden)").forEach(t=>{t.querySelectorAll(".code-block").forEach(t=>{t.getAttribute("data-lang")===n?t.classList.remove("hidden"):t.classList.add("hidden")})})})}),this.algorithmSelector.addEventListener("change",()=>{this.comparisonManager.updateLeftAlgorithm(this.currentAlgorithm),this.explanationTabs.forEach(t=>{t.classList.remove("border-primary","text-primary"),t.classList.add("border-transparent","text-gray-500")});const t=this.comparisonManager.leftAlgorithm,n=document.querySelector(`.explanation-tab[data-algorithm="${t}"]`);n&&(n.classList.remove("border-transparent","text-gray-500"),n.classList.add("border-primary","text-primary"))}),this.explanationTabs.forEach(t=>{t.addEventListener("click",()=>{const n=t.getAttribute("data-algorithm"),e=this.comparisonManager.leftAlgorithm,i=this.comparisonManager.rightAlgorithm;this.comparisonManager.comparisonMode&&n===i?this.comparisonManager.switchToSingle():n===e||this.comparisonManager.updateRightAlgorithm(n),this.explanationTabs.forEach(t=>{t.classList.remove("border-primary","text-primary"),t.classList.add("border-transparent","text-gray-500")});const r=this.comparisonManager.leftAlgorithm,a=document.querySelector(`.explanation-tab[data-algorithm="${r}"]`);if(a&&(a.classList.remove("border-transparent","text-gray-500"),a.classList.add("border-primary","text-primary")),this.comparisonManager.comparisonMode){const t=this.comparisonManager.rightAlgorithm,n=document.querySelector(`.explanation-tab[data-algorithm="${t}"]`);n&&(n.classList.remove("border-transparent","text-gray-500"),n.classList.add("border-primary","text-primary"))}})}),this.displayStyleRadios.forEach(t=>{t.addEventListener("change",t=>{this.isSorting||(this.displayStyle=t.target.value,this.renderArray())})});const l=document.getElementById("clear-log");l&&l.addEventListener("click",()=>{const t=document.getElementById("algorithm-log");t&&(t.innerHTML="")}),window.addEventListener("scroll",()=>{const t=document.querySelector("header");window.scrollY>10?(t.classList.add("py-2","shadow"),t.classList.remove("py-4")):(t.classList.add("py-4"),t.classList.remove("py-2","shadow"))}),this.applyCustomArrayBtn&&this.applyCustomArrayBtn.addEventListener("click",()=>{this.applyCustomArray()}),this.clearCustomArrayBtn&&this.clearCustomArrayBtn.addEventListener("click",()=>{this.clearCustomArray()}),this.customArrayInput&&this.customArrayInput.addEventListener("keypress",t=>{"Enter"===t.key&&this.applyCustomArray()});const d=document.getElementById("generate-document-html");d&&d.addEventListener("click",()=>{this.generateExplanatoryDocument("html")});const c=document.getElementById("generate-document-md");c&&c.addEventListener("click",()=>{this.generateExplanatoryDocument("markdown")});const p=document.getElementById("export-data");p&&p.addEventListener("click",()=>{this.exportData()}),document.addEventListener("keydown",t=>{if("INPUT"!==t.target.tagName&&"TEXTAREA"!==t.target.tagName&&!this.isCompetitionMode)switch(t.key){case" ":t.preventDefault(),this.isSorting?this.togglePause():this.startSort();break;case"ArrowRight":(this.isPaused||this.isStepping)&&this.stepForward();break;case"ArrowLeft":(this.isPaused||this.isStepping)&&this.stepBack();break;case"r":case"R":this.resetSort();break;case"n":case"N":this.createNewArray()}}),this.toggle2DBtn&&this.toggle2DBtn.addEventListener("click",()=>{this.switchTo2D()}),this.toggle3DBtn&&this.toggle3DBtn.addEventListener("click",()=>{this.switchTo3D()})}createNewArray(t="random"){switch(this.resetSort(),this.array=[],t){case"sorted":for(let i=0;i<this.arraySize;i++)this.array.push(5*i+1);break;case"reverse":for(let i=this.arraySize;i>0;i--)this.array.push(5*i+1);break;case"nearly-sorted":for(let i=0;i<this.arraySize;i++)this.array.push(5*i+1);const t=Math.max(1,Math.floor(.1*this.arraySize));for(let i=0;i<t;i++){const t=Math.floor(Math.random()*this.arraySize),n=Math.floor(Math.random()*this.arraySize);[this.array[t],this.array[n]]=[this.array[n],this.array[t]]}break;case"few-unique":const n=[10,20,30,40,50];for(let i=0;i<this.arraySize;i++)this.array.push(n[Math.floor(Math.random()*n.length)]);break;case"constant":const e=50;for(let i=0;i<this.arraySize;i++)this.array.push(e);break;case"alternating":for(let i=0;i<this.arraySize;i++)this.array.push(i%2==0?20:80);break;default:for(let i=0;i<this.arraySize;i++)this.array.push(Math.floor(100*Math.random())+1)}this.initialArray=[...this.array],w.setCurrent(this.array,this.currentAlgorithm),this.preGeneratedHistory=w.generateCurrentHistory(),this.sortHistory=this.preGeneratedHistory.history,this.currentStep=-1,this.renderArray(),this.currentArraySizeEl.textContent=this.arraySize;const n=document.getElementById("algorithm-log");n&&(n.innerHTML="");const e=this.analyzeArrayFeatures(this.array),i=this.recommendAlgorithm(e);"function"==typeof this.displayRecommendations&&this.displayRecommendations(i)}renderArray(t=[],n=[],e=-1){var i;if(this.is3DMode&&this.visualization3D)return void this.visualization3D.renderArray(this.array,t,n);this.animationDuration=Math.max(500,this.animationDuration||500),this.animationIntensity=this.animationIntensity||1,this.barsContainer.style.position="relative",this.barsContainer.style.overflowX="auto",this.barsContainer.style.overflowY="visible",this.barsContainer.style.whiteSpace="nowrap";const r=this.barsContainer.clientWidth||(null==(i=this.visualizationContainer)?void 0:i.clientWidth)||.8*window.innerWidth,a=Math.max(2,(r-1*this.arraySize)/this.arraySize),s=this.array.length>0?Math.max(...this.array):100,o=this.array.length>0?this.array:[50,30,80,60,20,40,70,10,90,5],l=Math.max(0,this.barsContainer.clientHeight)-16,d=.95*Math.max(0,l-24),c=this.barsContainer.querySelectorAll(".flex.flex-col.items-center.w-full"),p=new Map;c.forEach((t,n)=>{p.set(n,t)}),this.barsContainer.innerHTML="",o.forEach((i,r)=>{this.createBarElement(r,i,o,a,d,s,t,n,e)});const m=this.currentAlgorithm.replace("Sort","").toLowerCase();if(["quick","merge","heap"].includes(m)&&e>=0&&(this.array.length>0?e<this.array.length:e<o.length)){const t=this.array.length>0?this.array[e]:o[e%o.length],n=s>0?t/s*d:0,i=24,r=8,a=this.barsContainer.clientHeight-r-i-n;let l=this.barsContainer.querySelector(".pivot-dash-line"),c=this.barsContainer.querySelector(".pivot-dash-label");l||(l=document.createElement("div"),l.className="pivot-dash-line absolute left-0 right-0 pointer-events-none",l.style.borderTop="2px dashed #9333ea",l.style.zIndex="5",this.barsContainer.appendChild(l)),c||(c=document.createElement("div"),c.className="pivot-dash-label absolute left-0 transform -translate-y-1/2 bg-white px-2 py-1 rounded text-xs font-medium text-purple-600 shadow-sm",c.style.left="12px",c.style.zIndex="6",this.barsContainer.appendChild(c)),l.style.top=`${a}px`,c.style.top=`${a}px`,c.textContent=`基准值: ${t}`}else{const t=this.barsContainer.querySelector(".pivot-dash-line"),n=this.barsContainer.querySelector(".pivot-dash-label");t&&t.remove(),n&&n.remove()}if(t&&t.length>0){const n=t[0],e=this.barsContainer.querySelectorAll(".flex.flex-col.items-center.w-full");if(e[n]){const t=e[n].getBoundingClientRect(),i=this.barsContainer.getBoundingClientRect(),r=t.left-i.left+this.barsContainer.scrollLeft-i.width/2+t.width/2;this.barsContainer.scrollTo({left:r,behavior:"smooth"})}}}createBarElement(t,n,e,i,r,a,s,o,l){const d=a>0?n/a*r:0,c=(this.array.length,t),p=document.createElement("div");p.className="flex flex-col items-center w-full",p.style.width=`${i}px`;const m=document.createElement("div");m.className="flex flex-col items-center w-full flex-1";const h=document.createElement("div");h.className="bar-shadow w-full",h.style.borderRadius="4px 4px 0 0",h.style.height=`${d}px`,h.style.transform="scaleY(1)",h.style.transformOrigin="bottom",h.style.opacity="1",this.setBarColor(h,c,n,e,s,o,l);const g=document.createElement("div");g.className="absolute text-xs -translate-y-full -mb-1 text-gray-600 font-medium",g.textContent=n,g.style.zIndex="10",g.style.opacity="1";const u=document.createElement("div");u.className="w-full bg-gray-100 rounded-sm p-1 flex items-center justify-center",u.style.height="24px";const x=document.createElement("div");x.className="text-gray-600 whitespace-nowrap",x.textContent=t,x.style.fontSize="10px",x.style.fontWeight="500",x.style.lineHeight="1",this.addDragAndDropEvents(h,t,n),u.appendChild(x),m.appendChild(h),m.appendChild(g),p.appendChild(m),p.appendChild(u),this.barsContainer.appendChild(p)}updateBarElement(t,n,e,i,r,a,s,o,l,d){const c=s>0?e/s*a:0,p=(this.array.length,n),m=t.querySelector(".flex.flex-col.items-center.w-full.flex-1");if(!m)return t.remove(),void this.createBarElement(n,e,i,r,a,s,o,l,d);const h=m.querySelector(".bar-shadow"),g=m.querySelector(".absolute.text-xs.-translate-y-full.-mb-1.text-gray-600.font-medium");if(!h||!g)return t.remove(),void this.createBarElement(n,e,i,r,a,s,o,l,d);t.style.width=`${r}px`,h.style.transformOrigin="bottom",h.style.height=`${c}px`,this.setBarColor(h,p,e,i,o,l,d),g.textContent=e,g.style.opacity="1"}setBarColor(t,n,e,i,r,a,s){if(t.style.transformOrigin="bottom",t.style.transition="none",a.includes(n))t.style.backgroundColor="#10b981",t.style.zIndex="1",t.style.transform="scaleY(1)";else if(n===s)t.style.backgroundColor="#9333ea",t.style.zIndex="5",t.style.transform="scaleY(1)",this.lastPivotIndex=n,this.lastPivotValue=e;else if(n===this.lastPivotIndex)t.style.backgroundColor="#9333ea",t.style.zIndex="5",t.style.transform="scaleY(1)";else if(r.includes(n))if(2===r.length){const a=r[0]===n?r[1]:r[0];(this.array[n]||e)>(this.array[a]||i[a%i.length])?(t.style.backgroundColor="#165DFF",t.style.zIndex="10",t.style.transform="scaleY(1)"):(t.style.backgroundColor="#f97316",t.style.zIndex="1",t.style.transform="scaleY(1)")}else t.style.backgroundColor="#f97316",t.style.zIndex="1",t.style.transform="scaleY(1)";else t.style.backgroundColor="#64748b",t.style.zIndex="1",t.style.transform="scaleY(1)"}addDragAndDropEvents(t,n,e){t.draggable=!0,t.addEventListener("dragstart",e=>{this.isSorting?e.preventDefault():(e.dataTransfer.setData("text/plain",n),t.style.opacity="0.5",t.style.cursor="grabbing")}),t.addEventListener("dragend",()=>{t.style.opacity="1",t.style.cursor="grab"}),t.addEventListener("dragenter",n=>{this.isSorting||(n.preventDefault(),t.style.border="2px dashed #165DFF")}),t.addEventListener("dragleave",()=>{t.style.border=""}),t.addEventListener("dragover",t=>{this.isSorting||t.preventDefault()}),t.addEventListener("drop",e=>{if(!this.isSorting){e.preventDefault(),t.style.border="";const i=parseInt(e.dataTransfer.getData("text/plain")),r=n;[this.array[i],this.array[r]]=[this.array[r],this.array[i]],this.initialArray=[...this.array],this.renderArray(),w.setCurrent(this.array,this.currentAlgorithm),this.preGeneratedHistory=w.generateCurrentHistory(),this.sortHistory=this.preGeneratedHistory.history,this.currentStep=-1;const a=document.getElementById("algorithm-log");a&&(a.innerHTML="")}}),t.addEventListener("mouseenter",()=>{this.isSorting||(t.style.cursor="grab",t.style.transform="scaleY(1.1)",t.style.transition="transform 150ms ease-out")}),t.addEventListener("mouseleave",()=>{this.isSorting||(t.style.transform="scaleY(1)",t.style.transition="transform 150ms ease-out")})}updateAlgorithmContent(){const t=k[this.currentAlgorithm].name;this.currentAlgorithmDisplay.textContent=t;const n=document.getElementById("algorithm-name-tag");if(n&&(n.textContent=t),this.competitionManager.competitionMode?this.competitionManager.updateAlgorithmInstance(0,this.currentAlgorithm.replace("Sort","").toLowerCase()):this.competitionManager.switchToSingle(),this.explanationTabs.forEach(t=>{t.classList.remove("border-primary","text-primary"),t.classList.add("border-transparent","text-gray-500")}),this.competitionManager.competitionMode)this.competitionManager.getAlgorithmInstances().forEach((t,n)=>{const e=document.querySelector(`.explanation-tab[data-algorithm="${t.algorithmName}"]`);e&&(e.classList.remove("border-transparent","text-gray-500"),e.classList.add("border-primary","text-primary"))});else{const t=this.currentAlgorithm.replace("Sort","").toLowerCase(),n=document.querySelector(`.explanation-tab[data-algorithm="${t}"]`);n&&(n.classList.remove("border-transparent","text-gray-500"),n.classList.add("border-primary","text-primary"))}}highlightComparisonTable(){this.competitionManager.highlightComparisonTable()}startSort(){this.isSorting&&this.isPaused?(this.isPaused=!1,this.isStepping=!1,this.pauseSortBtn.innerHTML='<i class="fa fa-pause"></i> 暂停',this.stepBackBtn.disabled=!0,this.stepForwardBtn.disabled=!0,null===this.chartUpdateInterval&&this.startPerformanceTracking(),this.playFromCurrentStep()):this.isSorting||(this.isSorting=!0,this.isPaused=!1,this.isStepping=!1,this.currentStep=-1,this.preGeneratedHistory&&w.getCurrentHistory()!==this.preGeneratedHistory&&(this.preGeneratedHistory=w.generateCurrentHistory(),this.sortHistory=this.preGeneratedHistory.history,this.currentStep=-1),this.startPerformanceTracking(),this.updateCounters(),this.startSortBtn.disabled=!0,this.newArrayBtn.disabled=!0,this.arraySizeSlider.disabled=!0,this.pauseSortBtn.disabled=!1,this.pauseSortBtn.innerHTML='<i class="fa fa-pause"></i> 暂停',this.stepBackBtn.disabled=!0,this.stepForwardBtn.disabled=!0,this.playFromCurrentStep())}playFromCurrentStep(){if(this.isSorting&&!this.isPaused&&this.currentStep<this.sortHistory.length-1){this.currentStep++,this.restoreStep(this.sortHistory[this.currentStep]);const t=1e3/this.sortSpeed;this.animationId=setTimeout(()=>this.playFromCurrentStep(),t)}else this.currentStep>=this.sortHistory.length-1&&(this.isSorting=!1,this.stopPerformanceTracking(),this.startSortBtn.disabled=!1,this.newArrayBtn.disabled=!1,this.arraySizeSlider.disabled=!1,this.pauseSortBtn.disabled=!0,this.stepBackBtn.disabled=this.sortHistory.length<=0,this.stepForwardBtn.disabled=this.sortHistory.length<=0||this.currentStep>=this.sortHistory.length-1)}togglePause(){this.isSorting&&(this.isPaused?(this.isPaused=!1,this.isStepping=!1,this.pauseSortBtn.innerHTML='<i class="fa fa-pause"></i> 暂停',this.stepBackBtn.disabled=!0,this.stepForwardBtn.disabled=!0,null===this.chartUpdateInterval&&this.startPerformanceTracking(),this.playFromCurrentStep()):(this.isPaused=!0,this.isStepping=!0,this.pauseSortBtn.innerHTML='<i class="fa fa-play"></i> 继续',this.stepBackBtn.disabled=!1,this.stepForwardBtn.disabled=!1,this.animationId&&(clearTimeout(this.animationId),this.animationId=null),this.stopPerformanceTracking()))}stepForward(){this.currentStep<this.sortHistory.length-1&&(this.currentStep++,this.restoreStep(this.sortHistory[this.currentStep]))}stepBack(){this.currentStep>0&&(this.currentStep--,this.restoreStep(this.sortHistory[this.currentStep]))}resetSort(){this.isSorting&&(this.isSorting=!1,this.isPaused=!1,this.isStepping=!1,this.animationId&&(clearTimeout(this.animationId),this.animationId=null),this.stopPerformanceTracking()),this.initialArray&&(this.array=[...this.initialArray]),this.comparisonCount=0,this.swapCount=0,this.currentStep=-1,this.updateCounters(),this.resetPerformanceData(),this.startSortBtn.disabled=!1,this.newArrayBtn.disabled=!1,this.arraySizeSlider.disabled=!1,this.pauseSortBtn.disabled=!0,this.pauseSortBtn.innerHTML='<i class="fa fa-pause"></i> 暂停',w.setCurrent(this.array,this.currentAlgorithm),this.preGeneratedHistory=w.generateCurrentHistory(),this.sortHistory=this.preGeneratedHistory.history,this.currentStep=-1,this.updateStepButtons(),this.renderArray();const t=document.getElementById("algorithm-log");t&&(t.innerHTML="")}handleShareLink(){const t=new URLSearchParams(window.location.search).get("share");if(t)try{const n=atob(t),e=JSON.parse(n);if(e.algorithm&&(this.currentAlgorithm=e.algorithm,this.algorithmSelector.value=this.currentAlgorithm,this.mobileAlgorithmSelector.value=this.currentAlgorithm,this.updateAlgorithmContent()),e.array&&(this.array=e.array,this.initialArray=[...this.array],this.arraySize=this.array.length,this.arraySizeSlider.value=this.arraySize,this.arraySizeValue.textContent=this.arraySize,this.currentArraySizeEl.textContent=this.arraySize),e.sortSpeed&&(this.sortSpeed=e.sortSpeed,this.sortSpeedSlider.value=this.sortSpeed,this.sortSpeedValue.textContent=this.sortSpeed),e.animationDuration){this.animationDuration=e.animationDuration;const t=document.getElementById("animation-speed"),n=document.getElementById("animation-speed-value");t&&n&&(t.value=this.animationDuration,n.textContent=`${this.animationDuration}ms`)}if(e.animationIntensity){this.animationIntensity=e.animationIntensity;const t=document.getElementById("animation-intensity"),n=document.getElementById("animation-intensity-value");t&&n&&(t.value=this.animationIntensity,n.textContent=this.animationIntensity)}this.renderArray(),w.setCurrent(this.array,this.currentAlgorithm),this.preGeneratedHistory=w.generateCurrentHistory(),this.sortHistory=this.preGeneratedHistory.history,this.currentStep=-1,this.updateStepButtons();const i=document.getElementById("algorithm-log");i&&(i.innerHTML="");const r=this.analyzeArrayFeatures(this.array),a=this.recommendAlgorithm(r);"function"==typeof this.displayRecommendations&&this.displayRecommendations(a)}catch(n){console.error("处理分享链接时出错:",n),alert("分享链接无效或已过期")}}restoreStep(t){this.array=[...t.array],this.comparisonCount=t.comparisonCount,this.swapCount=t.swapCount,window.currentAlgorithm=t.algorithm,window.currentI=t.indices.i,window.currentJ=t.indices.j,window.currentLow=t.indices.low,window.currentHigh=t.indices.high,this.updateCounters(),this.renderArray(t.highlightIndices,t.sortedIndices,t.pivotIndex||-1),this.updateStepButtons(),this.updateLog(t),this.updateStepExplanation(t),this.saveStepToDocument(t)}saveStepToDocument(t){const n=document.getElementById("step-explanation");if(!n)return;const e=n.textContent.trim();0===this.currentStep&&this.explanatoryDocument.init(k[this.currentAlgorithm].name),this.explanatoryDocument.addStep(this.currentStep+1,e,[...this.logBuffer]),this.logBuffer=[]}generateExplanatoryDocument(t="html"){this.explanatoryDocument.complete({comparisonCount:this.comparisonCount,swapCount:this.swapCount,totalSteps:this.sortHistory.length});const n=this.explanatoryDocument.saveDocument(t);return alert(`解释文档已生成并下载：${n}`),n}exportData(){const t=document.querySelector('input[name="export-format"]:checked').value,n=Array.from(document.querySelectorAll('input[name="export-content"]:checked')).map(t=>t.value),e={timestamp:(new Date).toISOString(),algorithm:this.currentAlgorithm,arraySize:this.arraySize,initialArray:this.initialArray,finalArray:[...this.array].sort((t,n)=>t-n),comparisonCount:this.comparisonCount,swapCount:this.swapCount,executionTime:this.getExecutionTime(),performanceData:this.performanceData,sortingHistory:this.sortHistory};switch(t){case"json":this.exportAsJSON(e,n);break;case"csv":this.exportAsCSV(e,n);break;case"image":this.exportAsImage();break;default:console.error("不支持的导出格式:",t)}}exportAsJSON(t,n){const e=this.filterExportData(t,n),i=JSON.stringify(e,null,2);this.downloadFile(i,`${this.currentAlgorithm}-${(new Date).toISOString().slice(0,10)}.json`,"application/json")}exportAsCSV(t,n){let e="";if(n.includes("performance-data")){e+="时间,比较次数,交换次数\n";for(let n=0;n<t.performanceData.time.length;n++)e+=`${t.performanceData.time[n]},${t.performanceData.comparisons[n]},${t.performanceData.swaps[n]}\n`}n.includes("algorithm-info")&&(e+="\n算法,数组大小,比较次数,交换次数,执行时间\n",e+=`${t.algorithm},${t.arraySize},${t.comparisonCount},${t.swapCount},${t.executionTime}\n`),n.includes("sorting-process")&&(e+="\n步骤类型,数组状态\n",t.sortingHistory.forEach((t,n)=>{e+=`${t.type},${t.array.join(",")}\n`})),this.downloadFile(e,`${this.currentAlgorithm}-${(new Date).toISOString().slice(0,10)}.csv`,"text/csv")}exportAsImage(){const t=document.createElement("canvas"),n=document.getElementById("visualization-container");if(!n)return;const e=n.getBoundingClientRect();t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.fillStyle=getComputedStyle(document.documentElement).getPropertyValue("--color-background"),i.fillRect(0,0,t.width,t.height);const r=document.getElementById("bars-container");r&&r.querySelectorAll(".bar").forEach(t=>{const n=t.getBoundingClientRect(),r=n.left-e.left,a=n.top-e.top;i.fillStyle=t.style.backgroundColor,i.fillRect(r,a,n.width,n.height),i.strokeStyle=t.style.borderColor||"transparent",i.lineWidth=1,i.strokeRect(r,a,n.width,n.height)});const a=t.toDataURL("image/png");this.downloadImage(a,`${this.currentAlgorithm}-visualization-${(new Date).toISOString().slice(0,10)}.png`)}filterExportData(t,n){const e={};return n.includes("algorithm-info")&&(e.algorithm=t.algorithm,e.arraySize=t.arraySize,e.initialArray=t.initialArray,e.finalArray=t.finalArray,e.comparisonCount=t.comparisonCount,e.swapCount=t.swapCount,e.executionTime=t.executionTime),n.includes("performance-data")&&(e.performanceData=t.performanceData),n.includes("sorting-process")&&(e.sortingHistory=t.sortingHistory),e}downloadFile(t,n,e){const i=new Blob([t],{type:e}),r=URL.createObjectURL(i),a=document.createElement("a");a.href=r,a.download=n,document.body.appendChild(a),a.click(),document.body.removeChild(a),URL.revokeObjectURL(r)}downloadImage(t,n){const e=document.createElement("a");e.href=t,e.download=n,document.body.appendChild(e),e.click(),document.body.removeChild(e)}updateStepExplanation(t){var n;if(!this.stepExplanationEl||!this.stepNumberEl)return;this.stepNumberEl.textContent=`步骤: ${this.currentStep+1}`;const e=null==(n=k[this.currentAlgorithm])?void 0:n.stepExplanations;if(!e)return this.currentStepExplanation="当前算法暂不支持步骤解释。",void(this.stepExplanationEl.textContent=this.currentStepExplanation);let i="";const r=this.currentAlgorithm.replace("Sort","").toLowerCase();if(-1!==this.currentStep&&t)if(this.currentStep===this.sortHistory.length-1||t.sortedIndices.length===t.array.length)i=e.complete||"排序完成，所有元素都已按升序排列。";else{let n="";if("quick"===r&&t.pivotIndex>=0){const e=this.currentStep>0?this.sortHistory[this.currentStep-1]:null;e&&e.pivotIndex===t.pivotIndex||(n="selectPivot")}else if("heap"===r&&t.highlightIndices.length>0)n="buildHeap";else if("merge"===r&&3===t.highlightIndices.length)n="merge";else if("counting"===r)t.highlightIndices.length>=2&&t.highlightIndices.includes(0)?n="findRange":t.highlightIndices.length>0&&t.countArray?n="countOccurrences":!t.highlightIndices.length&&t.countArray?n="calculatePrefixSum":2===t.highlightIndices.length&&(n="buildOutput");else if("radix"===r&&1===t.highlightIndices.length)n="sortByDigit";else if(0===t.highlightIndices.length)n="roundComplete";else if("selection"===r&&1===t.highlightIndices.length)n="selectMin";else if("insertion"===r&&1===t.highlightIndices.length)n="selectKey";else if(t.highlightIndices.length>=2){const e=this.currentStep>0?this.sortHistory[this.currentStep-1]:null;n=e&&JSON.stringify(e.array)!==JSON.stringify(t.array)?"swap":"compare"}else n="default";if(i=e[n]||e.default||"执行排序操作。","swap"===n&&t.highlightIndices.length>=2){const[n,e]=t.highlightIndices;i=i.replace("{{i}}",n).replace("{{j}}",e),i=i.replace("{{value_i}}",t.array[n]).replace("{{value_j}}",t.array[e]);const r=this.currentStep>0?this.sortHistory[this.currentStep-1]:null;r&&(i+=` 具体变化：${r.array[n]}(arr[${n}])<->${r.array[e]}(arr[${e}])`)}if("compare"===n&&t.highlightIndices.length>=2){const[n,e]=t.highlightIndices;if(i=i.replace("{{i}}",n).replace("{{j}}",e),i=i.replace("{{value_i}}",t.array[n]).replace("{{value_j}}",t.array[e]),i+=` 比较结果：${t.array[n]} ${t.array[n]>t.array[e]?">":t.array[n]<t.array[e]?"<":"="} ${t.array[e]}`,"quick"===r&&t.pivotIndex>=0){const n=t.array[t.pivotIndex];i=i.replace("{{pivot}}",n),i=i.replace("{{pivotIndex}}",t.pivotIndex),i+=` （与基准值 ${n} 比较）`}}if("selectPivot"===n&&t.pivotIndex>=0&&(i=i.replace("{{pivot}}",t.array[t.pivotIndex]),i=i.replace("{{pivotIndex}}",t.pivotIndex),i+=` 选择原因：在当前分区 [${t.indices.low}, ${t.indices.high}] 中选择一个基准元素，用于将数组分为两部分`),"selectMin"===n){const n=t.highlightIndices[0];i+=` 当前最小值：${t.array[n]}（位置 ${n}）`}if("selectKey"===n){const n=t.highlightIndices[0];i+=` 关键字：${t.array[n]}（位置 ${n}），将插入到已排序区间`}}else i=e.initial||"初始状态：数组尚未开始排序。";i=i.replace(/arr\[j\]/g,`arr[${t.indices.j}]`),i=i.replace(/arr\[j\+1\]/g,`arr[${t.indices.j+1}]`),i=i.replace(/arr\[i\]/g,`arr[${t.indices.i}]`),i=i.replace(/arr\[i\+1\]/g,`arr[${t.indices.i+1}]`),i=i.replace("{{i}}",t.indices.i).replace("{{j}}",t.indices.j),i=i.replace("{{i+1}}",t.indices.i+1).replace("{{j+1}}",t.indices.j+1),i=i.replace("{{low}}",t.indices.low).replace("{{high}}",t.indices.high);const a=this.getStepContextInfo(t,r);a&&(i+=` ${a}`),this.currentStepExplanation=i,this.stepExplanationEl.textContent=this.currentStepExplanation}getStepContextInfo(t,n){let e="";if("bubble"===n)e=`（已排序元素：${t.sortedIndices.length}个）`;else if("selection"===n)e=`（已找到${t.indices.i+1}个最小值）`;else if("insertion"===n)e=`（已排序${t.indices.i+1}个元素）`;else if("quick"===n)e=`（当前分区：[${t.indices.low}, ${t.indices.high}]）`;else if("merge"===n)e="（合并区间）";else if("heap"===n)e="（堆调整中）";else if("shell"===n)e=`（当前间隔：${Math.floor((t.indices.high-t.indices.low+1)/2)}）`;else if("counting"===n)if(t.countArray){const n=Math.min(...t.array);e=`（计数数组：[${t.countArray.map((t,e)=>`${n+e}:${t}`).join(", ")}]）`}else e="（查找最值中）";return e}updateLog(t){const n=document.getElementById("algorithm-log");if(!n)return;if(this.currentStep<n.children.length-1){for(;n.children.length>this.currentStep+1;)n.removeChild(n.lastChild);return this.logGroup=null,void(this.logBuffer=[])}let e="";const i=this.currentStep+1;let r="",a=!1,s="",o="";switch(s={bubble:"冒泡排序",quick:"快速排序",selection:"选择排序",insertion:"插入排序",merge:"归并排序",heap:"堆排序",shell:"希尔排序",counting:"计数排序",radix:"基数排序"}[t.algorithm]||t.algorithm,t.algorithm){case"bubble":if(2===t.highlightIndices.length){const[n,s]=t.highlightIndices;void 0!==this.array[n]&&void 0!==this.array[s]&&(e=`${i}: 比较相邻元素 ${this.array[n]} 和 ${this.array[s]}`,a=this.array[n]>this.array[s],r=a?"swap":"comparison",o=a?'💡 较大的元素会像气泡一样"浮"到右边':"💡 相邻元素已按顺序排列")}break;case"quick":if(t.pivotIndex>=0)t.pivotIndex===this.lastPivotIndex&&this.array[t.pivotIndex]===this.lastPivotValue||(e=`${i}: 选择基准元素 ${this.array[t.pivotIndex]}（位置 ${t.pivotIndex}）`,r="selection",o="💡 快速排序会选择一个基准元素，将数组分为两部分",this.lastPivotIndex=t.pivotIndex,this.lastPivotValue=this.array[t.pivotIndex]);else if(2===t.highlightIndices.length){const[n,s]=t.highlightIndices;if(void 0!==this.array[n]&&void 0!==this.array[s]){const s=this.array[t.pivotIndex||0];e=`${i}: 比较元素 ${this.array[n]} 和基准值 ${s}`,a=this.array[n]>s,r=a?"swap":"comparison",o=a?"💡 大于基准的元素移到右边，小于的移到左边":"💡 元素已在正确的分区"}}break;case"selection":if(1===t.highlightIndices.length){const n=t.highlightIndices[0];void 0!==this.array[n]&&(e=`${i}: 开始从位置 ${n} 寻找最小值`,r="selection",o="💡 选择排序每次从剩余元素中找到最小值")}else if(2===t.highlightIndices.length){const[n,s]=t.highlightIndices;void 0!==this.array[n]&&void 0!==this.array[s]&&(e=`${i}: 比较元素 ${this.array[n]} 和当前最小值 ${this.array[s]}`,a=this.array[n]<this.array[s],r="comparison",o=a?"💡 找到新的最小值":"💡 继续寻找更小的值")}break;case"insertion":if(1===t.highlightIndices.length){const n=t.highlightIndices[0];void 0!==this.array[n]&&(e=`${i}: 准备插入元素 ${this.array[n]}`,r="selection",o="💡 插入排序将元素插入到已排序序列的合适位置")}else if(2===t.highlightIndices.length){const[n,s]=t.highlightIndices;void 0!==this.array[n]&&void 0!==this.array[s]&&(e=`${i}: 比较元素 ${this.array[n]} 和已排序元素 ${this.array[s]}`,a=this.array[n]<this.array[s],r="comparison",o=a?"💡 需要将已排序元素右移，腾出插入位置":"💡 找到合适的插入位置")}break;case"merge":if(3===t.highlightIndices.length){const[n,a,s]=t.highlightIndices;e=`${i}: 合并区间 [${n}, ${a}] 和 [${a+1}, ${s}]`,r="selection",o="💡 归并排序先分割数组，再合并排序结果"}else if(2===t.highlightIndices.length){const[n,s]=t.highlightIndices;void 0!==this.array[n]&&void 0!==this.array[s]&&(e=`${i}: 比较左右区间元素 ${this.array[n]} 和 ${this.array[s]}`,a=this.array[n]>this.array[s],r="comparison",o="💡 选择较小的元素放入合并结果")}break;case"heap":if(t.highlightIndices.length>=1)if(1===t.highlightIndices.length){const n=t.highlightIndices[0];e=`${i}: 构建最大堆，处理节点 ${this.array[n]}`,r="selection",o="💡 堆排序先将数组构建为最大堆"}else{const[n,s]=t.highlightIndices;e=`${i}: 比较节点 ${this.array[n]} 和 ${this.array[s]}`,a=this.array[n]<this.array[s],r=a?"swap":"comparison",o=a?"💡 确保父节点大于子节点，维持最大堆性质":"💡 堆性质已满足"}break;case"shell":if(2===t.highlightIndices.length){const[n,s]=t.highlightIndices;void 0!==this.array[n]&&void 0!==this.array[s]&&(e=`${i}: 比较间隔为 ${Math.abs(n-s)} 的元素 ${this.array[n]} 和 ${this.array[s]}`,a=this.array[n]>this.array[s],r=a?"swap":"comparison",o=a?"💡 希尔排序使用间隔分组，逐步减小间隔":"💡 间隔内元素已排序")}break;case"counting":if(t.highlightIndices.length>=2&&t.highlightIndices.includes(0)){const[n,a,s]=t.highlightIndices;e=`${i}: 查找最值，当前最大值: ${this.array[a]}，当前最小值: ${this.array[s]}`,r="selection",o="💡 计数排序首先找出数组中的最大值和最小值，确定计数范围"}else if(t.highlightIndices.length>0&&t.countArray){const n=t.highlightIndices,a=this.array[n[0]];e=`${i}: 统计元素 ${a} 的出现次数，当前计数: ${t.countArray[a-Math.min(...this.array)]}`,r="selection",o="💡 计数排序统计每个元素出现的次数"}else if(!t.highlightIndices.length&&t.countArray){const n=t.indices.i;e=`${i}: 计算累积计数，位置 ${n} 的累积计数: ${t.countArray[n]}`,r="selection",o="💡 累积计数用于确定每个元素在输出数组中的位置"}else if(2===t.highlightIndices.length){const[n,a]=t.highlightIndices;e=`${i}: 放置元素 ${this.array[n]} 到位置 ${a}`,r="swap",o="💡 根据累积计数，将元素放置到输出数组的正确位置"}break;case"radix":if(1===t.highlightIndices.length){const n=t.highlightIndices[0];e=`${i}: 处理元素 ${this.array[n]} 的某一位`,r="selection",o="💡 基数排序从低位到高位依次排序"}else if(2===t.highlightIndices.length){const[n,s]=t.highlightIndices;e=`${i}: 比较元素 ${this.array[n]} 和 ${this.array[s]} 的某一位`,a=this.array[n]>this.array[s],r=a?"swap":"comparison",o="💡 根据当前位的值进行排序"}break;default:if(2===t.highlightIndices.length){const[n,s]=t.highlightIndices;void 0!==this.array[n]&&void 0!==this.array[s]&&(e=`${i}: 比较元素 ${this.array[n]} 和 ${this.array[s]}`,a=this.array[n]>this.array[s],r=a?"swap":"comparison")}else if(1===t.highlightIndices.length){const n=t.highlightIndices[0];void 0!==this.array[n]&&(e=`${i}: 处理元素 ${this.array[n]}`,r="selection")}}if(!e)return;this.logBuffer.push({type:r,content:e,stepNumber:i,algorithm:s,tip:o});const l=document.createElement("div");if("selection"===r){this.logGroup=document.createElement("div"),this.logGroup.className="border-b border-gray-200 mb-1 bg-white rounded-md shadow-sm";const t=document.createElement("div");t.className="flex items-center justify-between text-xs p-2 bg-blue-50 font-semibold cursor-pointer rounded-t-md",t.innerHTML=`\n                <span>${e}</span>\n                <span class="fold-icon">▼</span>\n            `;const i=document.createElement("div");if(i.className="group-content p-2 bg-white rounded-b-md",i.style.display="block",o){const t=document.createElement("div");t.className="text-xs p-2 mb-2 bg-yellow-50 border-l-4 border-yellow-400 rounded text-gray-700",t.textContent=o,i.appendChild(t)}t.addEventListener("click",()=>{const n="block"===i.style.display;i.style.display=n?"none":"block",t.querySelector(".fold-icon").textContent=n?"▶":"▼"}),this.logGroup.appendChild(t),this.logGroup.appendChild(i),n.appendChild(this.logGroup)}else if("swap"===r)if(this.logGroup){const t=this.logGroup.querySelector(".group-content"),n=document.createElement("div");if(n.className="text-xs p-2 pl-4 border-l-4 border-red-400 bg-red-50 rounded text-gray-800 mb-1",n.textContent=`${e} → 交换位置`,t.appendChild(n),o){const n=document.createElement("div");n.className="text-xs p-2 pl-4 bg-yellow-50 border-l-4 border-yellow-400 rounded text-gray-700 mb-1",n.textContent=o,t.appendChild(n)}this.logGroup=null}else l.className="text-xs p-2 border-l-4 border-red-400 bg-red-50 rounded text-gray-800 mb-1",l.textContent=`${e} → 交换位置`,n.appendChild(l);else if("comparison"===r)if(this.logGroup){const t=this.logGroup.querySelector(".group-content"),n=document.createElement("div");if(n.className="text-xs p-2 pl-4 border-l-4 border-blue-300 bg-blue-50 rounded text-gray-800 mb-1",n.textContent=`${e} → 保持不变`,t.appendChild(n),o){const n=document.createElement("div");n.className="text-xs p-2 pl-4 bg-yellow-50 border-l-4 border-yellow-400 rounded text-gray-700 mb-1",n.textContent=o,t.appendChild(n)}}else l.className="text-xs p-2 border-l-4 border-blue-300 bg-blue-50 rounded text-gray-800 mb-1",l.textContent=`${e} → 保持不变`,n.appendChild(l);if(this.stepExplanationEl&&this.currentStepExplanation){this.stepExplanationEl.remove();const t=document.createElement("div");t.id="step-explanation",t.className="pl-4 border-l-2 border-blue-200 ml-2 mt-1 text-gray-600 text-xs p-2 bg-blue-50 rounded",t.textContent=this.currentStepExplanation,this.stepExplanationEl=t,n.appendChild(t)}n.children.length>15&&n.removeChild(n.firstChild),n.scrollTop=n.scrollHeight}updateCounters(){this.comparisonCountEl.textContent=this.comparisonCount,this.swapCountEl.textContent=this.swapCount}updateStepButtons(){this.stepBackBtn.disabled=this.currentStep<=0,this.stepForwardBtn.disabled=this.currentStep>=this.sortHistory.length-1}}window.SortingVisualizer=E,document.addEventListener("DOMContentLoaded",()=>{new E,setTimeout(()=>{hljs.highlightAll()},100)});let L={passed:0,failed:0,total:0};function A(t,n){L.total++,t?(L.passed++,console.log(`✅ PASS: ${n}`)):(L.failed++,console.error(`❌ FAIL: ${n}`))}const B=new class{constructor(){this.tests=[]}addTest(t,n){this.tests.push({name:t,testFunction:n})}runTests(){L={passed:0,failed:0,total:0},console.log("🧪 开始运行测试..."),console.log("========================================="),this.tests.forEach(t=>{console.log(`\n📋 测试: ${t.name}`);try{t.testFunction()}catch(n){L.failed++,L.total++,console.error(`❌ FAIL: 测试执行出错 - ${n.message}`)}}),console.log("\n========================================="),console.log("📊 测试结果汇总:"),console.log(`总测试数: ${L.total}`),console.log(`通过: ${L.passed}`),console.log(`失败: ${L.failed}`),0===L.failed?console.log("🎉 所有测试通过！"):console.log("❌ 有测试失败，请检查错误信息。")}};function O(){"loading"===document.readyState?document.addEventListener("DOMContentLoaded",()=>{B.runTests()}):B.runTests()}B.addTest("DOM元素存在性测试",()=>{const t=document.getElementById("app"),n=document.getElementById("visualization"),e=document.getElementById("control-panel-container");A(null!==t,"应用容器元素存在"),A(null!==n,"可视化区域元素存在"),A(null!==e,"控制面板容器元素存在")}),B.addTest("算法日志功能测试",()=>{const t=document.getElementById("algorithm-log"),n=document.getElementById("step-explanation"),e=document.getElementById("step-number");A(null!==t,"算法日志容器存在"),A(null!==n,"步骤解释容器存在"),A(null!==e,"步骤编号元素存在")}),B.addTest("样式加载测试",()=>{const t=document.styleSheets;let n=!1;for(let i=0;i<t.length;i++){const r=t[i];try{const t=r.cssRules||r.rules;if(t)for(let e=0;e<t.length;e++){const i=t[e];if(i.selectorText&&(i.selectorText.includes(".array-name")||i.selectorText.includes(".array-index")||i.selectorText.includes(".comparison-operator"))){n=!0;break}}}catch(e){}if(n)break}A(n,"自定义CSS样式存在")}),"undefined"!=typeof window&&document.addEventListener("DOMContentLoaded",()=>{const t=document.createElement("button");t.textContent="运行测试",t.style.position="fixed",t.style.top="10px",t.style.right="10px",t.style.zIndex="9999",t.style.padding="10px 20px",t.style.backgroundColor="#165DFF",t.style.color="white",t.style.border="none",t.style.borderRadius="4px",t.style.cursor="pointer",t.style.fontSize="14px",t.style.fontWeight="bold",t.style.boxShadow="0 2px 4px rgba(0,0,0,0.2)",t.addEventListener("click",O),document.body.appendChild(t),setTimeout(()=>{O()},1e3)}),"undefined"!=typeof window&&(window.testFramework=B,window.runTests=O)}},function(){return n||(0,t[i(t)[0]])((n={exports:{}}).exports,n),n.exports});export default a();
